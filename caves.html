<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caves and Castles</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-page: #f0f0f0; --bg-container: #ffffff; --bg-panel: #f3f4f6;
            --text-default: #1f2937; --text-muted: #4b5563; --text-highlight: #4338ca;
            --border-color: #e5e7eb; --canvas-bg: #ffffff; --canvas-border: #cccccc;
            --player-color: blue; --terrain-color: #d1d5db;
        }
        [data-theme="dark"] {
            --bg-page: #1a202c; --bg-container: #2d3748; --bg-panel: #4a5568;
            --text-default: #f7fafc; --text-muted: #a0aec0; --text-highlight: #f6e05e;
            --border-color: #4a5568; --canvas-bg: #000000; --canvas-border: #ffffff;
            --player-color: #63b3ed; --terrain-color: #4a5568;
        }
        body { background-color: var(--bg-page); color: var(--text-default); transition: background-color 0.3s, color 0.3s; }
        .game-container { background-color: var(--bg-container); border-color: var(--border-color); }
        .panel { background-color: var(--bg-panel); border-color: var(--border-color); }
        .highlight-text { color: var(--text-highlight); }
        .muted-text { color: var(--text-muted); }
        canvas { background-color: var(--canvas-bg); border: 1px solid var(--canvas-border); box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); }
        #messageLog { background-color: color-mix(in srgb, var(--bg-panel) 90%, transparent); border-top: 2px solid var(--border-color); color: var(--text-muted); }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 font-mono">
    <div class="game-container container mx-auto max-w-2xl p-6 rounded-2xl shadow-xl border-2">
        <div class="relative">
            <h1 class="text-4xl font-bold text-center mb-4">Caves and Castles</h1>
            <button id="darkModeToggle" class="absolute top-0 right-0 p-2 text-2xl" title="Toggle Dark Mode">🌙</button>
        </div>
        <div class="flex flex-col sm:flex-row justify-between items-center text-sm mb-4 gap-4">
            <div id="statusPanel" class="panel flex flex-col justify-between items-start w-full sm:w-1/3 p-2 rounded-lg border gap-y-1">
                <span id="healthDisplay" class="font-bold text-red-500">Health: 10</span>
                <span id="manaDisplay" class="font-bold text-blue-500">Mana: 10</span>
                <span id="staminaDisplay" class="font-bold text-green-500">Stamina: 10</span>
                <span id="psycheDisplay" class="font-bold text-indigo-500">Psyche: 10</span>
            </div>
            <div id="coreStatsPanel" class="panel grid grid-cols-2 gap-x-4 w-full sm:w-2/3 p-2 rounded-lg border">
                <span id="strengthDisplay" class="font-bold">Strength: 1</span><span id="witsDisplay" class="font-bold">Wits: 1</span>
                <span id="constitutionDisplay" class="font-bold">Constitution: 1</span><span id="dexterityDisplay" class="font-bold">Dexterity: 1</span>
                <span id="charismaDisplay" class="font-bold">Charisma: 1</span><span id="luckDisplay" class="font-bold">Luck: 1</span>
                <span id="willpowerDisplay" class="font-bold">Willpower: 1</span><span id="perceptionDisplay" class="font-bold">Perception: 1</span>
                <span id="enduranceDisplay" class="font-bold">Endurance: 1</span><span id="intuitionDisplay" class="font-bold">Intuition: 1</span>
            </div>
        </div>
        <div class="relative w-full rounded-xl overflow-hidden flex items-center justify-center">
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
            <div id="messageLog" class="absolute bottom-0 left-0 w-full p-2 text-sm hidden"></div>
        </div>
        <div id="inventoryPanel" class="panel mt-4 p-4 w-full rounded-2xl border-2">
            <h2 class="text-xl font-bold mb-2">Inventory</h2>
            <div id="inventoryList" class="flex flex-wrap gap-2"><span class="muted-text italic">Inventory is empty.</span></div>
        </div>
        <div id="controls" class="mt-4 text-center">
            <p class="text-lg">Use <span class="highlight-text font-bold">W, A, S, D</span> or <span class="highlight-text font-bold">Arrow Keys</span> to move.</p>
        </div>
    </div>
    <script>
        const TILE_SIZE = 14;
        const VIEWPORT_WIDTH = 40;
        const VIEWPORT_HEIGHT = 25;
        const WORLD_WIDTH = 500;
        const WORLD_HEIGHT = 500;
        const WORLD_SEED = 'caves-and-castles-v1';
        const HEALING_AMOUNT = 3;
        const DAMAGE_AMOUNT = 2;
        const MANA_RESTORE_AMOUNT = 3;
        const STAMINA_RESTORE_AMOUNT = 4;
        const PSYCHE_RESTORE_AMOUNT = 2;
        const STAT_INCREASE_AMOUNT = 1;

        // --- GENERATION & UTILITIES ---

        function Alea(seed) {
            let s0 = 0, s1 = 0, s2 = 0, c = 1;
            if (seed == null) { seed = +new Date; }
            s0 = (seed >>> 0) * 0x9e3779b9;
            s1 = (seed >>> 0) * 0x9e3779b9;
            s2 = (seed >>> 0) * 0x9e3779b9;
            for (let i = 0; i < 4; i++) {
                s0 = Math.sin(s0) * 1e9;
                s1 = Math.sin(s1) * 1e9;
                s2 = Math.sin(s2) * 1e9;
            }
            return function() {
                const t = (s0 * 0x9e3779b9 + c * 0x2b759141) | 0;
                c = t < 0 ? 1 : 0;
                s0 = s1; s1 = s2; s2 = t;
                return (s2 >>> 0) / 0x100000000;
            };
        }

        const Perlin = {
            p: [],
            init: function(seed) {
                const random = Alea(seed);
                this.p = new Array(512);
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const n = Math.floor((i + 1) * random());
                    const t = p[i]; p[i] = p[n]; p[n] = t;
                }
                for (let i=0; i < 256; i++) { this.p[i] = this.p[i + 256] = p[i]; }
            },
            noise: function(x, y, z = 0) {
                const floor = Math.floor;
                const X = floor(x) & 255, Y = floor(y) & 255, Z = floor(z) & 255;
                x -= floor(x); y -= floor(y); z -= floor(z);
                const u = this.fade(x), v = this.fade(y), w = this.fade(z);
                const A = this.p[X]+Y, AA = this.p[A]+Z, AB = this.p[A+1]+Z, B = this.p[X+1]+Y, BA = this.p[B]+Z, BB = this.p[B+1]+Z;
                return this.scale(this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x-1, y, z)), this.lerp(u, this.grad(this.p[AB], x, y-1, z), this.grad(this.p[BB], x-1, y-1, z))), this.lerp(v, this.lerp(u, this.grad(this.p[AA+1], x, y, z-1), this.grad(this.p[BA+1], x-1, y, z-1)), this.lerp(u, this.grad(this.p[AB+1], x, y-1, z-1), this.grad(this.p[BB+1], x-1, y-1, z-1)))));
            },
            fade: t => t * t * t * (t * (t * 6 - 15) + 10),
            lerp: (t, a, b) => a + t * (b - a),
            grad: (hash, x, y, z) => {
                const h = hash & 15;
                const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            },
            scale: n => (1 + n) / 2
        };

        // --- GAME DATA & STATE ---

        const TERRAIN_COST = {
            '.': 0, '^': 3, '~': Infinity, 'F': 2, '+': 0, 'o': 0, 'S': 0, 'Y': 0, '$': 0, '!': 0, '?': 0,
            'E': 0, 'D': 0, 'C': 0, 'W': 0, 'P': 0, '&': 0, '>': 0,
        };
        const ITEM_DATA = {
            '+': { name: 'Healing Potion', effect: (state) => { state.player.health = Math.min(state.player.maxHealth, state.player.health + HEALING_AMOUNT); logMessage(`Restored ${HEALING_AMOUNT} health!`); } },
            'o': { name: 'Mana Orb', effect: (state) => { state.player.mana = Math.min(state.player.maxMana, state.player.mana + MANA_RESTORE_AMOUNT); logMessage('Restored mana!'); } },
            'S': { name: 'Stamina Crystal', effect: (state) => { state.player.stamina = Math.min(state.player.maxStamina, state.player.stamina + STAMINA_RESTORE_AMOUNT); logMessage(`Restored ${STAMINA_RESTORE_AMOUNT} stamina!`); } },
            'Y': { name: 'Psyche Shard', effect: (state) => { state.player.psyche = Math.min(state.player.maxPsyche, state.player.psyche + PSYCHE_RESTORE_AMOUNT); logMessage('Restored psyche.'); } },
            '$': { name: 'Gold Coin', effect: (state) => { state.player.health -= DAMAGE_AMOUNT; logMessage(`It was a trap! Lost ${DAMAGE_AMOUNT} health!`); } },
            '!': { name: 'Wit Elixir', effect: (state) => { state.player.wits += STAT_INCREASE_AMOUNT; logMessage('Wits increased!'); } },
            '?': { name: 'Lucky Charm', effect: (state) => { state.player.luck += STAT_INCREASE_AMOUNT; logMessage('Luck increased!'); } },
            'E': { name: 'Constitution Stone', effect: (state) => { state.player.constitution += STAT_INCREASE_AMOUNT; logMessage('Constitution increased!'); } },
            'D': { name: 'Dexterity Token', effect: (state) => { state.player.dexterity += STAT_INCREASE_AMOUNT; logMessage('Dexterity increased!'); } },
            'C': { name: 'Charisma Emblem', effect: (state) => { state.player.charisma += STAT_INCREASE_AMOUNT; logMessage('Charisma increased!'); } },
            'W': { name: 'Willpower Shard', effect: (state) => { state.player.willpower += STAT_INCREASE_AMOUNT; logMessage('Willpower increased!'); } },
            'P': { name: 'Perception Gem', effect: (state) => { state.player.perception += STAT_INCREASE_AMOUNT; logMessage('Perception increased!'); } },
            '&': { name: 'Endurance Rune', effect: (state) => { state.player.endurance += STAT_INCREASE_AMOUNT; logMessage('Endurance increased!'); } },
            '>': { name: 'Intuition Crystal', effect: (state) => { state.player.intuition += STAT_INCREASE_AMOUNT; logMessage('Intuition increased!'); } },
        };
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const messageLog = document.getElementById('messageLog');
        const healthDisplay = document.getElementById('healthDisplay');
        const manaDisplay = document.getElementById('manaDisplay');
        const staminaDisplay = document.getElementById('staminaDisplay');
        const psycheDisplay = document.getElementById('psycheDisplay');
        const strengthDisplay = document.getElementById('strengthDisplay');
        const witsDisplay = document.getElementById('witsDisplay');
        const luckDisplay = document.getElementById('luckDisplay');
        const constitutionDisplay = document.getElementById('constitutionDisplay');
        const dexterityDisplay = document.getElementById('dexterityDisplay');
        const charismaDisplay = document.getElementById('charismaDisplay');
        const willpowerDisplay = document.getElementById('willpowerDisplay');
        const perceptionDisplay = document.getElementById('perceptionDisplay');
        const enduranceDisplay = document.getElementById('enduranceDisplay');
        const intuitionDisplay = document.getElementById('intuitionDisplay');
        const inventoryList = document.getElementById('inventoryList');

        canvas.width = VIEWPORT_WIDTH * TILE_SIZE;
        canvas.height = VIEWPORT_HEIGHT * TILE_SIZE;
        
        const elevationNoise = Object.create(Perlin);
        elevationNoise.init(Alea(WORLD_SEED + ':elevation')());
        const moistureNoise = Object.create(Perlin);
        moistureNoise.init(Alea(WORLD_SEED + ':moisture')());

        const chunkManager = {
            CHUNK_SIZE: 16,
            loadedChunks: {},
            generateChunk(chunkX, chunkY) {
                const chunkKey = `${chunkX},${chunkY}`;
                let chunkData = Array.from({ length: this.CHUNK_SIZE }, () => Array(this.CHUNK_SIZE));
                for (let y = 0; y < this.CHUNK_SIZE; y++) {
                    for (let x = 0; x < this.CHUNK_SIZE; x++) {
                        const worldX = chunkX * this.CHUNK_SIZE + x;
                        const worldY = chunkY * this.CHUNK_SIZE + y;
                        const elev = elevationNoise.noise(worldX / 70, worldY / 70);
                        const moist = moistureNoise.noise(worldX / 50, worldY / 50);
                        let tile = '.';
                        if (elev < 0.35) tile = '~';
                        else if (elev > 0.8) tile = '^';
                        else if (moist > 0.55) tile = 'F';
                        else tile = '.';
                        chunkData[y][x] = tile;
                    }
                }
                this.loadedChunks[chunkKey] = chunkData;
            },
            getTile(worldX, worldY) {
                if (worldX < 0 || worldX >= WORLD_WIDTH || worldY < 0 || worldY >= WORLD_HEIGHT) { return ' '; }
                const chunkX = Math.floor(worldX / this.CHUNK_SIZE);
                const chunkY = Math.floor(worldY / this.CHUNK_SIZE);
                const chunkKey = `${chunkX},${chunkY}`;
                if (!this.loadedChunks[chunkKey]) { this.generateChunk(chunkX, chunkY); }
                const chunk = this.loadedChunks[chunkKey];
                const localX = worldX % this.CHUNK_SIZE;
                const localY = worldY % this.CHUNK_SIZE;
                return chunk[localY][localX];
            },
            setTile(worldX, worldY, tile) {
                const chunkX = Math.floor(worldX / this.CHUNK_SIZE);
                const chunkY = Math.floor(worldY / this.CHUNK_SIZE);
                const chunkKey = `${chunkX},${chunkY}`;
                if (!this.loadedChunks[chunkKey]) { this.generateChunk(chunkX, chunkY); }
                const chunk = this.loadedChunks[chunkKey];
                const localX = worldX % this.CHUNK_SIZE;
                const localY = worldY % this.CHUNK_SIZE;
                chunk[localY][localX] = tile;
            }
        };

        const gameState = {
            player: {
                x: Math.floor(WORLD_WIDTH / 2), y: Math.floor(WORLD_HEIGHT / 2), character: '@', color: 'blue',
                health: 10, maxHealth: 10, mana: 10, maxMana: 10, stamina: 10, maxStamina: 10, psyche: 10, maxPsyche: 10,
                strength: 1, wits: 1, luck: 1, constitution: 1, dexterity: 1, charisma: 1, willpower: 1, perception: 1, endurance: 1, intuition: 1,
                inventory: []
            },
            messages: []
        };
        
        ctx.font = `${TILE_SIZE}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // --- CORE GAME LOOP FUNCTIONS ---

        const logMessage = (text) => {
            messageLog.innerHTML = text;
            messageLog.classList.remove('hidden');
        };

        const renderStats = () => {
            healthDisplay.textContent = `Health: ${gameState.player.health}`; manaDisplay.textContent = `Mana: ${gameState.player.mana}`; staminaDisplay.textContent = `Stamina: ${gameState.player.stamina}`;
            psycheDisplay.textContent = `Psyche: ${gameState.player.psyche}`; strengthDisplay.textContent = `Strength: ${gameState.player.strength}`; witsDisplay.textContent = `Wits: ${gameState.player.wits}`;
            luckDisplay.textContent = `Luck: ${gameState.player.luck}`; constitutionDisplay.textContent = `Constitution: ${gameState.player.constitution}`; dexterityDisplay.textContent = `Dexterity: ${gameState.player.dexterity}`;
            charismaDisplay.textContent = `Charisma: ${gameState.player.charisma}`; willpowerDisplay.textContent = `Willpower: ${gameState.player.willpower}`; perceptionDisplay.textContent = `Perception: ${gameState.player.perception}`;
            enduranceDisplay.textContent = `Endurance: ${gameState.player.endurance}`; intuitionDisplay.textContent = `Intuition: ${gameState.player.intuition}`;
        };

        const renderInventory = () => {
            inventoryList.innerHTML = '';
            if (gameState.player.inventory.length === 0) {
                inventoryList.innerHTML = '<span class="muted-text italic">Inventory is empty.</span>';
            } else {
                gameState.player.inventory.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'p-1 rounded-md bg-gray-200 text-gray-800';
                    itemDiv.textContent = `${item.name}`;
                    inventoryList.appendChild(itemDiv);
                });
            }
        };

        const render = () => {
            const style = getComputedStyle(document.documentElement);
            const canvasBg = style.getPropertyValue('--canvas-bg');
            const playerColor = style.getPropertyValue('--player-color');
            const terrainColor = style.getPropertyValue('--terrain-color');
            ctx.fillStyle = canvasBg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const viewportCenterX = Math.floor(VIEWPORT_WIDTH / 2);
            const viewportCenterY = Math.floor(VIEWPORT_HEIGHT / 2);
            const startX = gameState.player.x - viewportCenterX;
            const startY = gameState.player.y - viewportCenterY;
            for (let y = 0; y < VIEWPORT_HEIGHT; y++) {
                for (let x = 0; x < VIEWPORT_WIDTH; x++) {
                    const mapX = startX + x;
                    const mapY = startY + y;
                    let tile = chunkManager.getTile(mapX, mapY);
                    let color = terrainColor;
                    switch (tile) {
                        case '~': color = '#60a5fa'; break;
                        case 'F': color = '#228B22'; break;
                        case '+': color = '#FF4500'; break; case 'o': color = '#6a0dad'; break; case 'S': color = '#ADFF2F'; break; case 'Y': color = '#4B0082'; break;
                        case '$': color = '#ffd700'; break; case '!': color = '#d4a017'; break; case '?': color = '#ff69b4'; break; case 'E': color = '#964B00'; break;
                        case 'D': color = '#54876b'; break; case 'C': color = '#ff8c00'; break; case 'W': color = '#800080'; break; case 'P': color = '#00CED1'; break;
                        case '&': color = '#a9a9a9'; break; case '>': color = '#add8e6'; break;
                    }
                    ctx.fillStyle = color;
                    ctx.fillText(tile, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
                }
            }
            ctx.fillStyle = playerColor;
            gameState.player.color = playerColor;
            ctx.fillText(gameState.player.character, viewportCenterX * TILE_SIZE + TILE_SIZE / 2, viewportCenterY * TILE_SIZE + TILE_SIZE / 2);
        };

        document.addEventListener('keydown', (event) => {
            if (gameState.player.health <= 0) return;
            let newX = gameState.player.x; let newY = gameState.player.y;
            switch (event.key) {
                case 'ArrowUp': case 'w': case 'W': newY--; break;
                case 'ArrowDown': case 's': case 'S': newY++; break;
                case 'ArrowLeft': case 'a': case 'A': newX--; break;
                case 'ArrowRight': case 'd': case 'D': newX++; break;
                default: return;
            }
            event.preventDefault();
            const newTile = chunkManager.getTile(newX, newY);
            if (newTile === ' ') { logMessage("You've reached the edge of the known world."); return; }
            const moveCost = TERRAIN_COST[newTile] ?? 0;
            if (moveCost === Infinity) { logMessage("That way is blocked."); return; }
            if (gameState.player.stamina >= moveCost) {
                gameState.player.stamina -= moveCost;
                const itemData = ITEM_DATA[newTile];
                if (itemData) {
                    itemData.effect(gameState);
                    chunkManager.setTile(newX, newY, '.');
                } else if (moveCost > 0) {
                    logMessage(`Traversing the terrain costs ${moveCost} stamina.`);
                } else {
                    logMessage(`Moved to world coordinate (${newX}, ${newY}).`);
                }
                gameState.player.x = newX;
                gameState.player.y = newY;
            } else {
                logMessage("You're too tired to move there!");
            }
            if (gameState.player.health <= 0) {
                gameState.player.health = 0;
                logMessage("You have perished! Game Over.");
            }
            render();
            renderStats();
            renderInventory();
        });

        const applyTheme = (theme) => {
            document.documentElement.setAttribute('data-theme', theme);
            darkModeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
            localStorage.setItem('theme', theme);
            ctx.font = `${TILE_SIZE}px monospace`;
            render();
        };

        darkModeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
        });

        window.onload = () => {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme) { applyTheme(savedTheme); } 
            else if (prefersDark) { applyTheme('dark'); } 
            else { applyTheme('light'); }
            renderStats();
            renderInventory();
            logMessage('Welcome to Caves and Castles! Find your way.');
        };
    </script>
</body>
</html>
