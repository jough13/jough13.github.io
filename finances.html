<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Contained Budget Tracker</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and Babel for running the application -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Chart.js for analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Google Fonts for typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900">

    <!-- The root element where the React app will be mounted -->
    <div id="root"></div>
    
    <!-- React Application Code (transpiled by Babel) -->
    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;
        
        // --- Child Components ---
        
        // Monthly Report Component
        const MonthlyReport = ({ rows }) => {
            const [selectedDate, setSelectedDate] = useState(new Date());

            const handleDateChange = (e) => {
                const [year, month] = e.target.value.split('-');
                setSelectedDate(new Date(year, month - 1, 1));
            };

            const reportData = useMemo(() => {
                const year = selectedDate.getFullYear();
                const month = selectedDate.getMonth();

                const monthlyTransactions = rows.filter(row => {
                    const rowDate = new Date(row.date + 'T00:00:00');
                    return rowDate.getFullYear() === year && rowDate.getMonth() === month;
                });

                const income = monthlyTransactions
                    .filter(r => r.type === 'income')
                    .reduce((sum, r) => sum + r.amount, 0);
                
                const expenses = monthlyTransactions
                    .filter(r => r.type === 'expense')
                    .reduce((sum, r) => sum + r.amount, 0);

                const categorySpending = monthlyTransactions
                    .filter(r => r.type === 'expense')
                    .reduce((acc, r) => {
                        const category = r.category || 'Uncategorized';
                        acc[category] = (acc[category] || 0) + r.amount;
                        return acc;
                    }, {});

                return {
                    income,
                    expenses,
                    net: income - expenses,
                    categorySpending: Object.entries(categorySpending).sort(([,a], [,b]) => b - a)
                };
            }, [rows, selectedDate]);

            return (
                 <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mt-8">
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Monthly Financial Report</h2>
                    <div className="mb-4">
                        <label className="text-sm font-medium mb-1 block">Select Month:</label>
                        <input 
                            type="month" 
                            value={`${selectedDate.getFullYear()}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}`}
                            onChange={handleDateChange}
                            className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"
                        />
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <div className="bg-green-100 dark:bg-green-900/50 p-4 rounded-lg">
                            <h4 className="font-semibold text-green-800 dark:text-green-300">Total Income</h4>
                            <p className="text-2xl font-bold text-green-600 dark:text-green-400">${reportData.income.toFixed(2)}</p>
                        </div>
                        <div className="bg-red-100 dark:bg-red-900/50 p-4 rounded-lg">
                            <h4 className="font-semibold text-red-800 dark:text-red-300">Total Expenses</h4>
                            <p className="text-2xl font-bold text-red-600 dark:text-red-400">${reportData.expenses.toFixed(2)}</p>
                        </div>
                        <div className={`p-4 rounded-lg ${reportData.net >= 0 ? 'bg-blue-100 dark:bg-blue-900/50' : 'bg-orange-100 dark:bg-orange-900/50'}`}>
                            <h4 className={`font-semibold ${reportData.net >= 0 ? 'text-blue-800 dark:text-blue-300' : 'text-orange-800 dark:text-orange-300'}`}>Net Savings/Loss</h4>
                            <p className={`text-2xl font-bold ${reportData.net >= 0 ? 'text-blue-600 dark:text-blue-400' : 'text-orange-600 dark:text-orange-400'}`}>${reportData.net.toFixed(2)}</p>
                        </div>
                    </div>
                    <div>
                        <h3 className="text-lg font-bold mt-4 mb-2 text-gray-900 dark:text-white">Spending by Category</h3>
                        <ul className="space-y-2">
                            {reportData.categorySpending.map(([category, amount]) => (
                                <li key={category} className="flex justify-between items-center bg-gray-50 dark:bg-gray-700/50 p-3 rounded-lg">
                                    <span className="font-medium text-gray-800 dark:text-gray-200">{category}</span>
                                    <span className="font-bold text-red-500">${amount.toFixed(2)}</span>
                                </li>
                            ))}
                        </ul>
                        {reportData.categorySpending.length === 0 && <p className="text-center text-gray-500 dark:text-gray-400 p-4">No expenses for this month.</p>}
                    </div>
                </div>
            );
        };

        // Debt Tracker Component with Payoff Calculator
        const DebtTracker = ({ debts, onAdd, onDelete }) => {
            const [newDebt, setNewDebt] = useState({ description: '', totalAmount: '', apr: '', minPayment: '' });
            const [extraPayment, setExtraPayment] = useState('');
            const [payoffScenarios, setPayoffScenarios] = useState(null);

            const handleInputChange = (e) => {
                const { name, value } = e.target;
                setNewDebt(prev => ({ ...prev, [name]: value }));
            };

            const handleAddDebt = (e) => {
                e.preventDefault();
                if (!newDebt.description || !newDebt.totalAmount) return;
                onAdd({
                    ...newDebt,
                    totalAmount: parseFloat(newDebt.totalAmount),
                    apr: parseFloat(newDebt.apr || 0),
                    minPayment: parseFloat(newDebt.minPayment || 0),
                    amountPaid: 0
                });
                setNewDebt({ description: '', totalAmount: '', apr: '', minPayment: '' });
            };

            const calculatePayoff = (strategy) => {
                let tempDebts = JSON.parse(JSON.stringify(debts.map(d => ({...d, balance: d.totalAmount - (d.amountPaid || 0)}))));
                let totalInterestPaid = 0;
                let months = 0;
                const monthlyExtra = parseFloat(extraPayment) || 0;
                
                const totalMonthlyCashForDebt = debts.reduce((sum, d) => sum + (d.minPayment || 0), 0) + monthlyExtra;

                while (tempDebts.some(d => d.balance > 0)) {
                    months++;
                    if (months > 1200) break; // Safety break after 100 years

                    let paymentPool = totalMonthlyCashForDebt;

                    tempDebts.forEach(debt => {
                        if (debt.balance > 0) {
                            const monthlyInterest = (debt.balance * (debt.apr / 100)) / 12;
                            totalInterestPaid += monthlyInterest;
                            debt.balance += monthlyInterest;
                        }
                    });

                    tempDebts.forEach(debt => {
                        if (debt.balance > 0) {
                            const payment = Math.min(debt.balance, debt.minPayment || 0);
                            debt.balance -= payment;
                            paymentPool -= payment;
                        }
                    });

                    if (strategy === 'avalanche') {
                        tempDebts.sort((a, b) => b.apr - a.apr);
                    } else { // snowball
                        tempDebts.sort((a, b) => a.balance - b.balance);
                    }

                    for (const debt of tempDebts) {
                        if (debt.balance > 0 && paymentPool > 0) {
                            const payment = Math.min(debt.balance, paymentPool);
                            debt.balance -= payment;
                            paymentPool -= payment;
                        }
                    }
                }
                return { months, totalInterestPaid };
            };

            const handleCalculateScenarios = () => {
                const avalanche = calculatePayoff('avalanche');
                const snowball = calculatePayoff('snowball');
                setPayoffScenarios({ avalanche, snowball });
            };
            
            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mt-8">
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Debt Paydown Tracker</h2>
                    <form onSubmit={handleAddDebt} className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end mb-6">
                        <div className="flex flex-col md:col-span-2"><label className="text-sm font-medium mb-1">Debt Description</label><input type="text" name="description" value={newDebt.description} onChange={handleInputChange} placeholder="e.g., Credit Card" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                        <div className="flex flex-col"><label className="text-sm font-medium mb-1">Total Owed</label><input type="number" name="totalAmount" value={newDebt.totalAmount} onChange={handleInputChange} placeholder="5000" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                        <div className="flex flex-col"><label className="text-sm font-medium mb-1">APR (%)</label><input type="number" name="apr" value={newDebt.apr} onChange={handleInputChange} placeholder="19.9" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                        <div className="flex flex-col"><label className="text-sm font-medium mb-1">Min. Payment</label><input type="number" name="minPayment" value={newDebt.minPayment} onChange={handleInputChange} placeholder="100" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                        <button type="submit" className="bg-red-600 text-white font-semibold p-2 rounded-md hover:bg-red-700 h-10">Add Debt</button>
                    </form>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {debts.map(debt => {
                            const amountRemaining = debt.totalAmount - (debt.amountPaid || 0);
                            const progress = debt.totalAmount > 0 ? ((debt.amountPaid || 0) / debt.totalAmount) * 100 : 0;
                            return (
                                <div key={debt.id} className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-lg shadow">
                                    <div className="flex justify-between items-start">
                                        <h3 className="font-bold text-lg text-gray-900 dark:text-white">{debt.description}</h3>
                                        <button onClick={() => onDelete(debt.id)} className="text-gray-400 hover:text-red-500">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                                        </button>
                                    </div>
                                    <p className="text-sm text-gray-600 dark:text-gray-400">Amount Owed: <span className="font-semibold">${amountRemaining.toFixed(2)}</span></p>
                                    <p className="text-sm text-gray-600 dark:text-gray-400">APR: {debt.apr}%</p>
                                    <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2.5 mt-2">
                                        <div className="bg-red-500 h-2.5 rounded-full" style={{ width: `${progress}%` }}></div>
                                    </div>
                                    <p className="text-right text-sm font-semibold mt-1 text-red-600 dark:text-red-400">{progress.toFixed(0)}% Paid Off</p>
                                </div>
                            );
                        })}
                    </div>
                    {debts.length === 0 && <div className="text-center p-8 text-gray-500 dark:text-gray-400">No debts tracked. Add one to get started!</div>}

                    {/* Payoff Calculator */}
                    {debts.length > 0 && (
                        <div className="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
                            <h3 className="text-xl font-bold mb-4 text-gray-900 dark:text-white">Debt Payoff Calculator</h3>
                            <div className="flex items-end space-x-4 mb-4">
                                <div className="flex-grow">
                                    <label className="text-sm font-medium mb-1 block">Extra Monthly Payment</label>
                                    <input type="number" value={extraPayment} onChange={(e) => setExtraPayment(e.target.value)} placeholder="e.g., 200" className="p-2 w-full rounded-md bg-gray-100 dark:bg-gray-700"/>
                                </div>
                                <button onClick={handleCalculateScenarios} className="bg-green-600 text-white font-semibold p-2 rounded-md hover:bg-green-700 h-10">Calculate Scenarios</button>
                            </div>
                            {payoffScenarios && (
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-lg">
                                        <h4 className="font-bold text-lg text-center">Avalanche (Lowest Interest)</h4>
                                        <p className="text-center text-sm text-gray-500 dark:text-gray-400">Pay highest APR first</p>
                                        <p className="mt-2">Debt-Free In: <span className="font-bold">{payoffScenarios.avalanche.months} months</span></p>
                                        <p>Total Interest Paid: <span className="font-bold">${payoffScenarios.avalanche.totalInterestPaid.toFixed(2)}</span></p>
                                    </div>
                                    <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-lg">
                                        <h4 className="font-bold text-lg text-center">Snowball (Lowest Balance)</h4>
                                        <p className="text-center text-sm text-gray-500 dark:text-gray-400">Pay smallest balance first</p>
                                        <p className="mt-2">Debt-Free In: <span className="font-bold">{payoffScenarios.snowball.months} months</span></p>
                                        <p>Total Interest Paid: <span className="font-bold">${payoffScenarios.snowball.totalInterestPaid.toFixed(2)}</span></p>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // Recurring Transactions Component
        const RecurringTransactions = ({ recurring, onAdd, onDelete }) => {
            const [newRecurring, setNewRecurring] = useState({
                description: '',
                amount: '',
                type: 'expense',
                account: 'checking',
                frequency: 'monthly',
                startDate: new Date().toISOString().slice(0, 10)
            });

            const handleInputChange = (e) => {
                const { name, value } = e.target;
                setNewRecurring(prev => ({ ...prev, [name]: value }));
            };

            const handleAdd = (e) => {
                e.preventDefault();
                if (!newRecurring.description || !newRecurring.amount) return;
                onAdd({ ...newRecurring, amount: parseFloat(newRecurring.amount) });
                setNewRecurring({
                    description: '', amount: '', type: 'expense', account: 'checking',
                    frequency: 'monthly', startDate: new Date().toISOString().slice(0, 10)
                });
            };

            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mt-8">
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Recurring Transactions</h2>
                    <form onSubmit={handleAdd} className="grid grid-cols-1 md:grid-cols-6 gap-4 items-end mb-6">
                        <div className="flex flex-col md:col-span-2"><label className="text-sm font-medium mb-1">Description</label><input type="text" name="description" value={newRecurring.description} onChange={handleInputChange} placeholder="e.g., Rent, Paycheck" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                        <div className="flex flex-col"><label className="text-sm font-medium mb-1">Amount</label><input type="number" name="amount" value={newRecurring.amount} onChange={handleInputChange} placeholder="1500" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                        <div className="flex flex-col"><label className="text-sm font-medium mb-1">Type</label><select name="type" value={newRecurring.type} onChange={handleInputChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700 h-[42px]"><option value="expense">Expense</option><option value="income">Income</option></select></div>
                        <div className="flex flex-col"><label className="text-sm font-medium mb-1">Frequency</label><select name="frequency" value={newRecurring.frequency} onChange={handleInputChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700 h-[42px]"><option value="monthly">Monthly</option><option value="weekly">Weekly</option></select></div>
                        <button type="submit" className="bg-purple-600 text-white font-semibold p-2 rounded-md hover:bg-purple-700 h-10">Add Recurring</button>
                    </form>
                    <div className="space-y-2">
                        {recurring.map(item => (
                            <div key={item.id} className="bg-gray-50 dark:bg-gray-700/50 p-3 rounded-lg flex justify-between items-center">
                                <div>
                                    <p className="font-semibold text-gray-900 dark:text-white">{item.description}</p>
                                    <p className="text-sm text-gray-600 dark:text-gray-400">
                                        ${item.amount.toFixed(2)} - {item.type} - every {item.frequency.replace('ly', '')}
                                    </p>
                                </div>
                                <button onClick={() => onDelete(item.id)} className="text-gray-400 hover:text-red-500">
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // Chart Wrapper Component
        const ChartComponent = ({ type, data, options }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);

            useEffect(() => {
                if (chartRef.current) {
                    chartRef.current.destroy();
                }
                const ctx = canvasRef.current.getContext('2d');
                chartRef.current = new Chart(ctx, {
                    type: type,
                    data: data,
                    options: options,
                });

                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [type, data, options]);

            return <canvas ref={canvasRef}></canvas>;
        };
        
        // Analytics Dashboard Component
        const AnalyticsDashboard = ({ rows }) => {
            const categoryData = useMemo(() => {
                const spending = rows
                    .filter(row => row.type === 'expense')
                    .reduce((acc, row) => {
                        const category = row.category || 'Uncategorized';
                        acc[category] = (acc[category] || 0) + parseFloat(row.amount);
                        return acc;
                    }, {});
                
                const labels = Object.keys(spending);
                const data = Object.values(spending);
                
                return {
                    labels,
                    datasets: [{
                        data,
                        backgroundColor: ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef'],
                        hoverOffset: 4
                    }]
                };
            }, [rows]);

            return (
                 <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mt-8">
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Analytics Dashboard</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div className="md:col-span-2 lg:col-span-1 lg:col-start-2 bg-gray-50 dark:bg-gray-700/50 p-4 rounded-lg">
                            <h3 className="font-semibold text-center text-gray-900 dark:text-white">Spending by Category</h3>
                            <ChartComponent type="doughnut" data={categoryData} />
                        </div>
                    </div>
                </div>
            );
        };

        // Savings Goals Component
        const SavingsGoals = ({ goals, onAdd, onDelete, savingsBalance }) => {
            const [newGoal, setNewGoal] = useState({ description: '', targetAmount: '', targetDate: '' });

            const handleInputChange = (e) => {
                const { name, value } = e.target;
                setNewGoal(prev => ({ ...prev, [name]: value }));
            };

            const handleAddGoal = (e) => {
                e.preventDefault();
                if (!newGoal.description || !newGoal.targetAmount || !newGoal.targetDate) return;
                onAdd({ ...newGoal, targetAmount: parseFloat(newGoal.targetAmount) });
                setNewGoal({ description: '', targetAmount: '', targetDate: '' });
            };

            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mt-8">
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Savings Goals</h2>
                    <form onSubmit={handleAddGoal} className="grid grid-cols-1 md:grid-cols-4 gap-4 items-end mb-6">
                        <div className="flex flex-col md:col-span-2">
                            <label className="text-sm font-medium mb-1 text-gray-600 dark:text-gray-400">Goal Description</label>
                            <input type="text" name="description" value={newGoal.description} onChange={handleInputChange} placeholder="e.g., Vacation Fund" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/>
                        </div>
                        <div className="flex flex-col">
                            <label className="text-sm font-medium mb-1 text-gray-600 dark:text-gray-400">Target Amount</label>
                            <input type="number" name="targetAmount" value={newGoal.targetAmount} onChange={handleInputChange} placeholder="1000" step="0.01" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/>
                        </div>
                        <div className="flex flex-col">
                            <label className="text-sm font-medium mb-1 text-gray-600 dark:text-gray-400">Target Date</label>
                            <input type="date" name="targetDate" value={newGoal.targetDate} onChange={handleInputChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/>
                        </div>
                        <button type="submit" className="bg-green-600 text-white font-semibold p-2 rounded-md hover:bg-green-700 h-10 md:col-start-4">Add Goal</button>
                    </form>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {goals.map(goal => {
                            const progress = goal.targetAmount > 0 ? Math.min((savingsBalance / goal.targetAmount) * 100, 100) : 0;
                            return (
                                <div key={goal.id} className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-lg shadow">
                                    <div className="flex justify-between items-start">
                                        <h3 className="font-bold text-lg text-gray-900 dark:text-white">{goal.description}</h3>
                                        <button onClick={() => onDelete(goal.id)} className="text-gray-400 hover:text-red-500">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                                        </button>
                                    </div>
                                    <p className="text-sm text-gray-600 dark:text-gray-400">Target: ${parseFloat(goal.targetAmount).toFixed(2)} by {goal.targetDate}</p>
                                    <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2.5 mt-2">
                                        <div className="bg-green-500 h-2.5 rounded-full" style={{ width: `${progress}%` }}></div>
                                    </div>
                                    <p className="text-right text-sm font-semibold mt-1 text-green-600 dark:text-green-400">{progress.toFixed(0)}% Complete</p>
                                </div>
                            );
                        })}
                    </div>
                    {goals.length === 0 && <div className="text-center p-8 text-gray-500 dark:text-gray-400">You have no savings goals yet. Add one to get started!</div>}
                </div>
            );
        };

        // Account Manager Component
        const AccountManager = ({ accounts, onUpdate }) => {
            const [editing, setEditing] = useState(null);
            const [tempValue, setTempValue] = useState('');
            const handleEdit = (type) => { setEditing(type); setTempValue(accounts[type]); };
            const handleBlur = (type) => {
                const newValue = parseFloat(tempValue);
                if (!isNaN(newValue)) onUpdate(type, newValue);
                setEditing(null);
            };
            const handleKeyDown = (e, type) => { if(e.key === 'Enter') handleBlur(type); };
            const renderAccountField = (type) => {
                const title = type.charAt(0).toUpperCase() + type.slice(1);
                return editing === type ? (
                    <div>
                        <h3 className="text-lg font-semibold text-gray-500 dark:text-gray-400">{title}</h3>
                        <input type="number" value={tempValue} onChange={(e) => setTempValue(e.target.value)} onBlur={() => handleBlur(type)} onKeyDown={(e) => handleKeyDown(e, type)} autoFocus className="mt-2 text-3xl font-bold text-gray-900 dark:text-white bg-gray-200 dark:bg-gray-700 rounded-md p-2 w-full" />
                    </div>
                ) : (
                    <div onClick={() => handleEdit(type)} className="cursor-pointer">
                        <h3 className="text-lg font-semibold text-gray-500 dark:text-gray-400">{title}</h3>
                        <p className="mt-2 text-3xl font-bold text-gray-900 dark:text-white">${accounts[type]?.toFixed(2) || '0.00'}</p>
                    </div>
                );
            };
            return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md">{renderAccountField('checking')}</div>
                    <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md">{renderAccountField('savings')}</div>
                </div>
            );
        };

        // Calendar Component
        const CashFlowCalendar = ({ currentBalance, futureTransactions, recurringTransactions, onAdd, onEdit }) => {
            const [currentDate, setCurrentDate] = useState(new Date());
            
            const allFutureEvents = useMemo(() => {
                const events = [...futureTransactions];
                const projectionEndDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0); // Project 2 months ahead

                recurringTransactions.forEach(item => {
                    let nextDate = new Date(item.startDate + 'T00:00:00'); // Avoid timezone issues
                    
                    while (nextDate <= projectionEndDate) {
                        if (nextDate >= new Date(currentDate.getFullYear(), currentDate.getMonth(), 1)) {
                             events.push({
                                ...item,
                                date: nextDate.toISOString().slice(0, 10),
                                isRecurring: true,
                            });
                        }

                        if (item.frequency === 'monthly') {
                            nextDate.setMonth(nextDate.getMonth() + 1);
                        } else if (item.frequency === 'weekly') {
                            nextDate.setDate(nextDate.getDate() + 7);
                        }
                    }
                });
                return events;
            }, [futureTransactions, recurringTransactions, currentDate]);

            const monthStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            const monthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
            const daysInMonth = monthEnd.getDate();
            const startDay = monthStart.getDay();

            const projectedBalances = useMemo(() => {
                let runningBalance = currentBalance;
                const balances = {};
                const dailyTransactionsMap = {};
                allFutureEvents.forEach(t => {
                    if (!dailyTransactionsMap[t.date]) dailyTransactionsMap[t.date] = [];
                    dailyTransactionsMap[t.date].push(t);
                });
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const todaysTransactions = dailyTransactionsMap[dateStr] || [];
                    todaysTransactions.forEach(t => {
                        const amount = parseFloat(t.amount) || 0;
                        runningBalance += t.type === 'income' ? amount : -amount;
                    });
                    balances[day] = runningBalance;
                }
                return balances;
            }, [currentBalance, allFutureEvents, currentDate, daysInMonth]);
            const changeMonth = (offset) => setCurrentDate(prev => new Date(prev.getFullYear(), prev.getMonth() + offset, 1));
            const calendarDays = Array(startDay).fill(null).map((_, i) => <div key={`empty-${i}`} className="border-r border-b border-gray-200 dark:border-gray-700"></div>);
            for (let day = 1; day <= daysInMonth; day++) {
                const dateStr = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dailyTransactions = allFutureEvents.filter(t => t.date === dateStr);
                calendarDays.push(
                    <div key={day} className="border-r border-b border-gray-200 dark:border-gray-700 p-2 min-h-[120px] flex flex-col hover:bg-gray-50 dark:hover:bg-gray-700/50" onClick={() => onAdd(dateStr)}>
                        <div className="font-bold text-gray-800 dark:text-gray-200">{day}</div>
                        <div className="flex-grow overflow-y-auto text-xs space-y-1 mt-1">
                            {dailyTransactions.map((t, i) => (
                                <div key={t.id + '-' + i} className={`p-1 rounded-md ${t.isRecurring ? 'opacity-70' : ''} ${t.type === 'income' ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`} onClick={(e) => { if(!t.isRecurring) { e.stopPropagation(); onEdit(t); } }}>
                                    <p className="font-semibold truncate">{t.description}</p>
                                    <p className={`${t.type === 'income' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>${parseFloat(t.amount).toFixed(2)}</p>
                                </div>
                            ))}
                        </div>
                        <div className={`text-right font-semibold mt-1 text-sm ${projectedBalances[day] >= 0 ? 'text-blue-600 dark:text-blue-400' : 'text-orange-500'}`}>${projectedBalances[day].toFixed(2)}</div>
                    </div>
                );
            }
            return (
                <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mt-8">
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Future Cash Flow Projection</h2>
                    <div className="flex justify-between items-center mb-4">
                        <button onClick={() => changeMonth(-1)} className="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">&lt; Prev</button>
                        <h3 className="text-xl font-semibold text-gray-900 dark:text-white">{currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}</h3>
                        <button onClick={() => changeMonth(1)} className="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Next &gt;</button>
                    </div>
                    <div className="grid grid-cols-7 text-center font-semibold text-gray-600 dark:text-gray-400">{['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(d => <div key={d} className="py-2 border-b-2 border-gray-200 dark:border-gray-700">{d}</div>)}</div>
                    <div className="grid grid-cols-7 border-l border-t border-gray-200 dark:border-gray-700">{calendarDays}</div>
                </div>
            );
        };

        // Modal Component
        const FutureTransactionModal = ({ isOpen, onClose, transaction, onSave, onDelete }) => {
            const [formData, setFormData] = useState(null);
            useEffect(() => { if (transaction) setFormData({ ...transaction }); else setFormData(null); }, [transaction]);
            if (!isOpen || !formData) return null;
            const handleChange = (e) => setFormData(prev => ({ ...prev, [e.target.name]: e.target.value }));
            const handleSubmit = (e) => { e.preventDefault(); onSave({ ...formData, amount: parseFloat(formData.amount) || 0 }); onClose(); };
            const handleDelete = () => { onDelete(formData.id); onClose(); };
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
                    <div className="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md">
                        <h2 className="text-2xl font-bold mb-6 text-gray-900 dark:text-white">{formData.id ? 'Edit' : 'Add'} Scheduled Transaction</h2>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div><label className="text-sm font-medium">Date</label><input type="date" name="date" value={formData.date} onChange={handleChange} className="w-full p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div><label className="text-sm font-medium">Description</label><input type="text" name="description" value={formData.description} onChange={handleChange} placeholder="e.g., Rent Payment" className="w-full p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div><label className="text-sm font-medium">Type</label><select name="type" value={formData.type} onChange={handleChange} className="w-full p-2 rounded-md bg-gray-100 dark:bg-gray-700"><option value="expense">Expense</option><option value="income">Income</option></select></div>
                            <div><label className="text-sm font-medium">Amount</label><input type="number" name="amount" value={formData.amount} onChange={handleChange} placeholder="0.00" step="0.01" className="w-full p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div className="flex justify-between items-center pt-4">
                                <div>{formData.id && <button type="button" onClick={handleDelete} className="px-4 py-2 bg-red-600 text-white rounded-md">Delete</button>}</div>
                                <div className="space-x-2"><button type="button" onClick={onClose} className="px-4 py-2 bg-gray-200 rounded-md">Cancel</button><button type="submit" className="px-4 py-2 bg-blue-600 text-white rounded-md">Save</button></div>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };

        // Import Confirmation Modal
        const ImportConfirmModal = ({ isOpen, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
                    <div className="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-md">
                        <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Confirm Import</h2>
                        <p className="text-gray-600 dark:text-gray-400 mb-6">
                            Importing a new file will overwrite all of your current data. This action cannot be undone. Are you sure you want to continue?
                        </p>
                        <div className="flex justify-end space-x-4">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 dark:bg-gray-600 font-semibold rounded-md hover:bg-gray-300 dark:hover:bg-gray-500">
                                Cancel
                            </button>
                            <button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700">
                                Yes, Overwrite Data
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Main App Component
        function App() {
            const [rows, setRows] = useState([]);
            const [futureTransactions, setFutureTransactions] = useState([]);
            const [savingsGoals, setSavingsGoals] = useState([]);
            const [debts, setDebts] = useState([]);
            const [recurringTransactions, setRecurringTransactions] = useState([]);
            const [accounts, setAccounts] = useState({ checking: 0, savings: 0 });
            const [newRow, setNewRow] = useState({ date: new Date().toISOString().slice(0, 10), description: '', category: '', type: 'expense', amount: '', account: 'checking', debtId: 'none' });
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [modalTransaction, setModalTransaction] = useState(null);
            const [isImportConfirmOpen, setIsImportConfirmOpen] = useState(false);
            const [dataToImport, setDataToImport] = useState(null);

            // Load initial data from localStorage
            useEffect(() => {
                try {
                    const savedAccounts = JSON.parse(localStorage.getItem('budgetAccounts_v5'));
                    if (savedAccounts) setAccounts(savedAccounts);

                    const savedRows = JSON.parse(localStorage.getItem('budgetRows_v5'));
                    if (savedRows) setRows(savedRows);

                    const savedFuture = JSON.parse(localStorage.getItem('budgetFutureTransactions_v5'));
                    if (savedFuture) setFutureTransactions(savedFuture);

                    const savedGoals = JSON.parse(localStorage.getItem('budgetSavingsGoals_v5'));
                    if (savedGoals) setSavingsGoals(savedGoals);

                    const savedDebts = JSON.parse(localStorage.getItem('budgetDebts_v5'));
                    if (savedDebts) setDebts(savedDebts);

                    const savedRecurring = JSON.parse(localStorage.getItem('budgetRecurring_v5'));
                    if (savedRecurring) setRecurringTransactions(savedRecurring);
                } catch (error) {
                    console.error("Could not load data from localStorage", error);
                }
            }, []);

            // Save data to localStorage whenever it changes
            useEffect(() => { localStorage.setItem('budgetAccounts_v5', JSON.stringify(accounts)); }, [accounts]);
            useEffect(() => { localStorage.setItem('budgetRows_v5', JSON.stringify(rows)); }, [rows]);
            useEffect(() => { localStorage.setItem('budgetFutureTransactions_v5', JSON.stringify(futureTransactions)); }, [futureTransactions]);
            useEffect(() => { localStorage.setItem('budgetSavingsGoals_v5', JSON.stringify(savingsGoals)); }, [savingsGoals]);
            useEffect(() => { localStorage.setItem('budgetDebts_v5', JSON.stringify(debts)); }, [debts]);
            useEffect(() => { localStorage.setItem('budgetRecurring_v5', JSON.stringify(recurringTransactions)); }, [recurringTransactions]);
            
            const transactionTotals = useMemo(() => rows.reduce((acc, row) => {
                const amount = parseFloat(row.amount) || 0;
                acc[row.type === 'income' ? 'income' : 'expense'] += amount;
                return acc;
            }, { income: 0, expense: 0 }), [rows]);
            
            const totalAssets = useMemo(() => (accounts.checking || 0) + (accounts.savings || 0), [accounts]);
            const totalLiabilities = useMemo(() => debts.reduce((acc, debt) => acc + (debt.totalAmount - (debt.amountPaid || 0)), 0), [debts]);
            const netWorth = useMemo(() => totalAssets - totalLiabilities, [totalAssets, totalLiabilities]);
            
            // --- Data Handlers ---
            const handleUpdateAccount = (type, value) => { setAccounts(prev => ({...prev, [type]: value})); };
            const handleAddGoal = (data) => { setSavingsGoals(prev => [...prev, { ...data, id: Date.now() }]); };
            const handleDeleteGoal = (id) => { setSavingsGoals(prev => prev.filter(goal => goal.id !== id)); };
            const handleAddDebt = (data) => { setDebts(prev => [...prev, { ...data, id: Date.now() }]); };
            const handleDeleteDebt = (id) => { setDebts(prev => prev.filter(debt => debt.id !== id)); };
            const handleAddRecurring = (data) => { setRecurringTransactions(prev => [...prev, { ...data, id: Date.now() }]); };
            const handleDeleteRecurring = (id) => { setRecurringTransactions(prev => prev.filter(item => item.id !== id)); };
            
            const handleAddRow = (e) => {
                e.preventDefault();
                if (newRow.description && newRow.amount) {
                    const amount = parseFloat(newRow.amount);
                    const accountToUpdate = newRow.account;
                    const transactionType = newRow.type;

                    setAccounts(prevAccounts => {
                        const currentBalance = prevAccounts[accountToUpdate] || 0;
                        const newBalance = transactionType === 'expense' ? currentBalance - amount : currentBalance + amount;
                        return { ...prevAccounts, [accountToUpdate]: newBalance };
                    });

                    if (transactionType === 'expense' && newRow.debtId !== 'none') {
                        setDebts(prevDebts => prevDebts.map(debt => 
                            debt.id === parseInt(newRow.debtId)
                                ? { ...debt, amountPaid: (debt.amountPaid || 0) + amount }
                                : debt
                        ));
                    }

                    setRows(prev => [{ ...newRow, id: Date.now(), amount: amount }, ...prev].sort((a,b) => new Date(b.date) - new Date(a.date)));
                    setNewRow({ date: new Date().toISOString().slice(0, 10), description: '', category: '', type: 'expense', amount: '', account: 'checking', debtId: 'none' });
                }
            };

            const handleDeleteRow = (id) => {
                const rowToDelete = rows.find(row => row.id === id);
                if (!rowToDelete) return;

                const amount = parseFloat(rowToDelete.amount);
                const accountToUpdate = rowToDelete.account || 'checking';
                const transactionType = rowToDelete.type;

                setAccounts(prevAccounts => {
                    const currentBalance = prevAccounts[accountToUpdate] || 0;
                    const newBalance = transactionType === 'expense' ? currentBalance + amount : currentBalance - amount;
                    return { ...prevAccounts, [accountToUpdate]: newBalance };
                });
                
                if (transactionType === 'expense' && rowToDelete.debtId && rowToDelete.debtId !== 'none') {
                    setDebts(prevDebts => prevDebts.map(debt => 
                        debt.id === parseInt(rowToDelete.debtId)
                            ? { ...debt, amountPaid: (debt.amountPaid || 0) - amount }
                            : debt
                    ));
                }
                
                setRows(prev => prev.filter(row => row.id !== id));
            };

            const handleOpenModal = (data) => { setModalTransaction(data); setIsModalOpen(true); };
            const handleAddFuture = (date) => handleOpenModal({ date, description: '', type: 'expense', amount: '' });
            const handleEditFuture = (t) => handleOpenModal(t);
            const handleSaveFuture = (data) => {
                if (data.id) {
                    setFutureTransactions(prev => prev.map(t => t.id === data.id ? data : t));
                } else {
                    setFutureTransactions(prev => [...prev, { ...data, id: Date.now() }]);
                }
            };
            const handleDeleteFuture = (id) => { setFutureTransactions(prev => prev.filter(t => t.id !== id)); };

            const handleExport = () => {
                const allData = { accounts, rows, futureTransactions, savingsGoals, debts, recurringTransactions };
                const dataStr = JSON.stringify(allData, null, 2);
                const blob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const date = new Date().toISOString().slice(0, 10);
                link.download = `budget-backup-${date}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        if (importedData.accounts && importedData.rows && importedData.futureTransactions && importedData.savingsGoals && importedData.debts) {
                            setDataToImport(importedData);
                            setIsImportConfirmOpen(true);
                        } else {
                            alert("Invalid data file format.");
                        }
                    } catch (error) {
                        alert("Failed to read file. It may be corrupted.");
                    }
                    e.target.value = null;
                };
                reader.readAsText(file);
            };

            const confirmImport = () => {
                if (dataToImport) {
                    setAccounts(dataToImport.accounts);
                    setRows(dataToImport.rows);
                    setFutureTransactions(dataToImport.futureTransactions);
                    setSavingsGoals(dataToImport.savingsGoals);
                    setDebts(dataToImport.debts);
                    setRecurringTransactions(dataToImport.recurringTransactions || []);
                }
                setIsImportConfirmOpen(false);
                setDataToImport(null);
            };

            const cancelImport = () => {
                setIsImportConfirmOpen(false);
                setDataToImport(null);
            };

            const handleNewRowChange = (e) => {
                const { name, value } = e.target;
                setNewRow(prev => ({...prev, [name]: value}));
            };


            return (
                <div className="max-w-7xl mx-auto text-gray-800 dark:text-gray-200 p-4 sm:p-6 lg:p-8">
                    <header className="mb-8 flex flex-col sm:flex-row justify-between sm:items-center">
                        <div>
                            <h1 className="text-4xl font-bold text-gray-900 dark:text-white">Budget Tracker</h1>
                            <p className="text-lg text-gray-600 dark:text-gray-400 mt-1">Your complete financial overview. All data is saved in your browser.</p>
                        </div>
                        <div className="flex space-x-2 mt-4 sm:mt-0">
                            <button onClick={handleExport} className="bg-blue-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">
                                Export Data
                            </button>
                            <label htmlFor="import-file" className="cursor-pointer bg-gray-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-700 transition-colors">
                                Import Data
                            </label>
                            <input id="import-file" type="file" className="hidden" onChange={handleImport} accept=".json"/>
                        </div>
                    </header>
                    
                    <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white mt-8">Account Balances</h2>
                    <AccountManager accounts={accounts} onUpdate={handleUpdateAccount} />
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md"><h3 className="text-lg font-semibold text-green-500">Total Assets</h3><p className="text-3xl font-bold mt-2 text-gray-900 dark:text-white">${totalAssets.toFixed(2)}</p></div>
                        <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md"><h3 className="text-lg font-semibold text-red-500">Total Debts</h3><p className="text-3xl font-bold mt-2 text-gray-900 dark:text-white">${totalLiabilities.toFixed(2)}</p></div>
                        <div className={`p-6 rounded-xl shadow-md ${netWorth >= 0 ? 'bg-blue-500' : 'bg-orange-500'}`}><h3 className="text-lg font-semibold text-white">Net Worth</h3><p className="text-3xl font-bold mt-2 text-white">${netWorth.toFixed(2)}</p></div>
                    </div>
                    <div className="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-md mb-8">
                        <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">Add Completed Transaction</h2>
                         <form onSubmit={handleAddRow} className="grid grid-cols-1 md:grid-cols-8 gap-4 items-end">
                            <div className="flex flex-col"><label className="text-sm">Date</label><input type="date" name="date" value={newRow.date} onChange={handleNewRowChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div className="flex flex-col md:col-span-2"><label className="text-sm">Description</label><input type="text" name="description" value={newRow.description} onChange={handleNewRowChange} placeholder="e.g., Groceries" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div className="flex flex-col"><label className="text-sm">Category</label><input type="text" name="category" value={newRow.category} onChange={handleNewRowChange} placeholder="e.g., Food" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div className="flex flex-col"><label className="text-sm">Type</label>
                                <select name="type" value={newRow.type} onChange={handleNewRowChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700 h-[42px]">
                                    <option value="expense">Expense</option>
                                    <option value="income">Income</option>
                                </select>
                            </div>
                            <div className="flex flex-col"><label className="text-sm">Account</label>
                                <select name="account" value={newRow.account} onChange={handleNewRowChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700 h-[42px]">
                                    <option value="checking">Checking</option>
                                    <option value="savings">Savings</option>
                                </select>
                            </div>
                            <div className="flex flex-col"><label className="text-sm">Amount</label><input type="number" name="amount" value={newRow.amount} onChange={handleNewRowChange} placeholder="0.00" step="0.01" className="p-2 rounded-md bg-gray-100 dark:bg-gray-700"/></div>
                            <div className="flex flex-col">
                                <label className="text-sm">Debt Payment?</label>
                                <select name="debtId" value={newRow.debtId} onChange={handleNewRowChange} className="p-2 rounded-md bg-gray-100 dark:bg-gray-700 h-[42px]" disabled={newRow.type === 'income'}>
                                    <option value="none">N/A</option>
                                    {debts.map(d => <option key={d.id} value={d.id}>{d.description}</option>)}
                                </select>
                            </div>
                            <button type="submit" className="bg-blue-600 text-white font-semibold p-2 rounded-md hover:bg-blue-700 h-10">Add</button>
                        </form>
                    </div>
                    <div className="bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-x-auto">
                         <h2 className="text-2xl font-bold p-6 text-gray-900 dark:text-white">Transaction History</h2>
                        <table className="w-full text-left">
                            <thead className="border-b border-gray-200 dark:border-gray-700"><tr><th className="p-4 text-sm font-semibold">Date</th><th className="p-4 text-sm font-semibold">Description</th><th className="p-4 text-sm font-semibold">Category</th><th className="p-4 text-sm font-semibold">Type</th><th className="p-4 text-sm font-semibold">Account</th><th className="p-4 text-sm font-semibold">Amount</th><th className="p-4 text-sm font-semibold">Actions</th></tr></thead>
                            <tbody>
                                {rows.map(row => (
                                    <tr key={row.id} className="border-b border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50">
                                        <td className="p-4">{row.date}</td>
                                        <td className="p-4">{row.description}</td>
                                        <td className="p-4">{row.category}</td>
                                        <td className="p-4 capitalize">{row.type}</td>
                                        <td className="p-4 capitalize">{row.account}</td>
                                        <td className={`p-4 font-medium ${row.type === 'income' ? 'text-green-500' : 'text-red-500'}`}>${parseFloat(row.amount || 0).toFixed(2)}</td>
                                        <td className="p-4"><button onClick={() => handleDeleteRow(row.id)} className="text-gray-400 hover:text-red-500"><svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg></button></td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                        {rows.length === 0 && <div className="text-center p-8 text-gray-500 dark:text-gray-400">No transaction history.</div>}
                    </div>
                    <MonthlyReport rows={rows} />
                    <RecurringTransactions recurring={recurringTransactions} onAdd={handleAddRecurring} onDelete={handleDeleteRecurring} />
                    <CashFlowCalendar currentBalance={totalAssets} futureTransactions={futureTransactions} recurringTransactions={recurringTransactions} onAdd={handleAddFuture} onEdit={handleEditFuture} />
                    <SavingsGoals goals={savingsGoals} onAdd={handleAddGoal} onDelete={handleDeleteGoal} savingsBalance={accounts.savings || 0} />
                    <DebtTracker debts={debts} onAdd={handleAddDebt} onDelete={handleDeleteDebt} />
                    <AnalyticsDashboard rows={rows} />
                    <FutureTransactionModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} transaction={modalTransaction} onSave={handleSaveFuture} onDelete={handleDeleteFuture} />
                    <ImportConfirmModal isOpen={isImportConfirmOpen} onConfirm={confirmImport} onCancel={cancelImport} />
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
