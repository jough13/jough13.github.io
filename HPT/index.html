<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Inline Styles for the Loader (Must remain in HTML for instant loading) -->
        <style>
            #loader {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background-color: #f1f5f9;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
            }
            .spinner {
            width: 48px;
            height: 48px;
            border: 5px solid #cbd5e1;
            border-bottom-color: #38bdf8;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: spin 1s linear infinite;
            }
            .loading-text {
            margin-top: 20px;
            font-size: 1rem;
            font-weight: 500;
            color: #64748b;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            }
            /* Dark Mode Loader Overrides */
            html.dark #loader { background-color: #0f172a; }
            html.dark .spinner { border: 5px solid #334155; border-bottom-color: #38bdf8; }
            html.dark .loading-text { color: #94a3b8; }
            #loader.hidden { opacity: 0; visibility: hidden; }
            @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        </style>
        <!--Basic HTML Metadata-->
        <meta charset="UTF-8" />
        <meta content="width=device-width, initial-scale=1.0" name="viewport" />
        <script>
            (function() {
            
              // Function to apply the dark theme
            
              const applyTheme = () => {
                document.documentElement.classList.add('dark');
              };
            
              // Check 1: See if a theme is explicitly saved in localStorage
            
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark') {
                applyTheme();
                return;
              }
            
              // Check 2: If no saved theme, check the user's OS/browser preference
            
              if (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                applyTheme();
              }
            
            })();
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.min.js"></script>
        <title>Health Physics Toolbox</title>
        <!--External Libraries & Frameworks-->
        <!--Tailwind CSS for styling-->
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
            // Enables Tailwind's dark mode feature, allowing class-based theme switching (e.g., <body class="dark">)
            
            tailwind.config = {
              darkMode: 'class'
            }
        </script>
        <!--React Libraries for building the user interface-->
        <script
            crossorigin
            src="https://unpkg.com/react@18/umd/react.production.min.js"
            ></script>
        <script
            crossorigin
            src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
            ></script>
        <!--Babel to transpile JSX (React's syntax) into plain JavaScript in the browser-->
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
        <!--Chart.js for creating data visualizations-->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <!--Google Fonts for a clean, modern typeface-->
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
            rel="stylesheet"
            />
        <!--Custom Application Styles-->
        <link
            href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
            rel="stylesheet"
            />
        <script
            defer
            src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
            ></script>
        <script
            defer
            onload="renderMathInElement(document.body);"
            src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
            ></script>
        <link rel="stylesheet" href="css/style.css" />
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            />
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
            />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
        <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet-geosearch@3/dist/geosearch.css"
            />
        <script src="https://unpkg.com/leaflet-geosearch@3/dist/geosearch.umd.js"></script>
        <script>
            // When the document is ready, add the 'visible' class to the #root element
            // to trigger our CSS transition.
            
            window.addEventListener('DOMContentLoaded', () => {
              document.getElementById('root').classList.add('visible');
            });
        </script>
    </head>
    <body class="bg-slate-100 dark:bg-slate-900 transition-colors duration-300">
        <div id="loader">
            <div class="spinner"></div>
            <p class="loading-text">Health Physics Toolbox loading...</p>
        </div>
        <!--The root element where the React application will be mounted.-->
        <div id="root"></div>
        <div id="back-to-top-root"></div>
        <div id="modal-root"></div>
        <div id="toast-root"></div>
        <script src="js/radionuclide-data.js"></script>
        <script src="js/constants.js"></script>
        <script src="js/utils.js"></script>
        <script type="text/babel">
            // --- MASTER LIST of Smart-Sorted Unit Arrays ---
            
            // For Activity
            
            const activityUnits_ordered = ['Bq', 'kBq', 'MBq', 'GBq', 'µCi', 'mCi', 'Ci', 'dps', 'dpm'];
            
            // For Dose & Dose Rate
            
            const doseRateUnits_ordered = ['µrem/hr', 'mrem/hr', 'rem/hr', 'R/hr', 'µSv/hr', 'mSv/hr', 'Sv/hr'];
            const doseUnits_ordered = ['µrem', 'mrem', 'rem', 'R', 'µSv', 'mSv', 'Sv'];
            
            // For Distance & Dimensions
            
            const distanceUnits_ordered = ['mm', 'cm', 'm', 'in', 'ft', 'km'];
            const areaUnits_ordered = ['cm²', 'm²', 'in²', 'ft²', 'barn'];
            
            // For Time
            
            const timeUnits_ordered = ['seconds', 'minutes', 'hours', 'days', 'years'];
            const longTimeUnits_ordered = ['seconds', 'minutes', 'hours', 'days', 'years', 'kiloyears', 'megayears', 'gigayears'];
            
            // For Mass
            
            const massUnits_ordered = ['µg', 'mg', 'g', 'kg'];
            
            // For Shipping (TBq based)
            
            const shippingActivityUnits_ordered = ['Bq', 'kBq', 'MBq', 'GBq', 'TBq', 'µCi', 'mCi', 'Ci'];
            
            // For Radioactive Concentration
            
            const concentrationUnits_ordered = ['Bq/L', 'pCi/L', 'Bq/m³', 'µCi/mL'];
            
            /**
             * A comprehensive list of radionuclides pulled from the initial table.
             */
            
            const radionuclides = RADIONUCLIDE_DATA;
            
            
            //==============================================================================
            // --- REACT COMPONENTS & ICONS
            //==============================================================================
            
            /**
             * A simple SVG icon component.
             * @param {{path: string, className?: string}} props - Component props.
             * @param {string} props.path - The SVG path data for the icon.
             * @param {string} [props.className="w-5 h-5"] - Optional CSS classes.
             * @returns {JSX.Element} A React component rendering an SVG icon.
             */
            
            const Icon = ({ path, className = "w-5 h-5" }) => (
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
                    <path d={path} />
                </svg>
            );
            
            //==============================================================================
            // --- GLOBAL SETTINGS & CONTEXT
            //==============================================================================
            
            const SettingsContext = React.createContext();
            
            const SettingsProvider = ({ children }) => {
            // UPDATED: Added unitSystem to the default settings.
            const defaultSettings = {
               theme: 'system', // 'light', 'dark', or 'system'
               unitSystem: 'conventional', // 'conventional' (Ci, rem) or 'si' (Bq, Sv)
            };
            
            const [settings, setSettings] = React.useState(() => {
               try {
                   const saved = localStorage.getItem('rad_tool_settings');
                   return saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
               } catch (e) {
                   return defaultSettings;
               }
            });
            
            const updateSettings = (newSettings) => {
               setSettings(prev => {
                   const updated = { ...prev, ...newSettings };
                   localStorage.setItem('rad_tool_settings', JSON.stringify(updated));
                   return updated;
               });
            };
            
            React.useEffect(() => {
               const root = window.document.documentElement;
               if (settings.theme === 'dark') {
                   root.classList.add('dark');
               } else if (settings.theme === 'light') {
                   root.classList.remove('dark');
               } else { // System theme
                   const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                   const handleChange = () => {
                       if (mediaQuery.matches) { root.classList.add('dark'); }
                       else { root.classList.remove('dark'); }
                   };
                   mediaQuery.addEventListener('change', handleChange);
                   handleChange(); // Initial check
                   return () => mediaQuery.removeEventListener('change', handleChange);
               }
            }, [settings.theme]);
            
            return (
               <SettingsContext.Provider value={{ settings, updateSettings }}>
                   {children}
               </SettingsContext.Provider>
            );
            };
            
            const CATEGORY_DESCRIPTIONS = {
            'Medical': 'Used for diagnosis, therapy, or medical research.',
            'Industrial': 'Used in manufacturing, gauging, sterilization, or other industrial processes.',
            'Natural': 'Occurs naturally in the environment or as part of a decay series.',
            'Stable/Reference': 'A stable isotope, often used as a reference or target material.',
            };
            
            const CATEGORY_STYLES = {
            'Medical':    {
            border: 'border-l-sky-400 dark:border-l-sky-600',
            hoverBg: 'hover:bg-sky-50 dark:hover:bg-sky-900/50'
            },
            'Industrial': {
            border: 'border-l-amber-400 dark:border-l-amber-600',
            hoverBg: 'hover:bg-amber-50 dark:hover:bg-amber-900/50'
            },
            'Natural':    {
            border: 'border-l-green-400 dark:border-l-green-600',
            hoverBg: 'hover:bg-green-50 dark:hover:bg-green-900/50'
            },
            'Stable/Reference': {
            border: 'border-l-slate-400 dark:border-l-slate-500',
            hoverBg: 'hover:bg-slate-50 dark:hover:bg-slate-800/50'
            },
            
            // A default style for any other categories
            
            'default': {
            border: 'border-l-slate-300 dark:border-l-slate-600',
            hoverBg: 'hover:bg-slate-50 dark:hover:bg-slate-800/50'
            }
            };
            
            //==============================================================================
            // --- TOAST NOTIFICATION SYSTEM
            // Provides pop-up messages for user feedback (e.g., "Copied to clipboard").
            //==============================================================================
            
            /**
             * @description React Context to provide toast notification functions to any component.
             */
            
            const ToastContext = React.createContext();
            
            /**
             * @description Provider component that manages the state of toast notifications.
             * It renders the toasts and provides a function to add new ones.
             * @param {{children: React.ReactNode}} props - The child components that will have access to the context.
             */
            
            const ToastProvider = ({ children }) => {
                const [toasts, setToasts] = React.useState([]);
            
                const addToast = (message) => {
                    // Date.now() is not unique enough for loops. 
                    // Add Math.random() to ensure uniqueness.
                    const id = Date.now() + Math.random(); 
            
                    setToasts(prevToasts => {
                        // Limit to max 5 toasts to prevent screen flooding
                        const updated = [...prevToasts, { id, message }];
                        if (updated.length > 5) {
                            return updated.slice(updated.length - 5);
                        }
                        return updated;
                    });
            
                    setTimeout(() => {
                        removeToast(id);
                    }, 3000);
                };
            
                const removeToast = (id) => {
                    setToasts(prevToasts => prevToasts.filter(toast => toast.id !== id));
                };
            
                // A variable to hold the toast container's JSX
                const toastContainer = (
                    <div className="fixed bottom-4 right-4 z-[9999] space-y-2 pointer-events-none">
                        {toasts.map(toast => (
                            <div 
                                key={toast.id} 
                                className="animate-toast-in bg-slate-800 dark:bg-slate-200 text-white dark:text-slate-800 px-4 py-3 rounded-lg shadow-lg flex items-center pointer-events-auto min-w-[250px]"
                            >
                                <Icon path={ICONS.check} className="w-5 h-5 mr-3 text-green-400" />
                                <span className="text-sm font-medium">{toast.message}</span>
                            </div>
                        ))}
                    </div>
                );
            
                return (
                    <ToastContext.Provider value={{ addToast }}>
                        {children}
                        {ReactDOM.createPortal(toastContainer, document.getElementById('toast-root'))}
                    </ToastContext.Provider>
                );
            };
            
            /**
            * @description Custom hook that delays updating a value until a specified time
            * has passed without that value changing. This is useful for preventing
            * expensive operations (like API calls or history updates) from running on
            * every keystroke.
            * @param {*} value The value to debounce.
            * @param {number} delay The delay in milliseconds.
            * @returns {*} The debounced value.
            */
            const useDebounce = (value, delay) => {
            // State to store the debounced value
            const [debouncedValue, setDebouncedValue] = React.useState(value);
            
            React.useEffect(() => {
            // Set up a timer to update the debounced value after the delay
            const handler = setTimeout(() => {
               setDebouncedValue(value);
            }, delay);
            
            // This is the cleanup function that runs every time the dependency [value] changes.
            // It clears the previous timer, effectively resetting it. The timer will only
            // complete if the user stops changing the value for the duration of the delay.
            return () => {
               clearTimeout(handler);
            };
            }, [value, delay]); // Only re-run the effect if value or delay changes
            
            return debouncedValue;
            };
            
            /**
             * @description Custom hook to easily access the toast context's `addToast` function.
             * @returns {{addToast: (message: string) => void}}
             */
            
            const useToast = () => React.useContext(ToastContext);
            
            /**
            * @description Custom hook to manage a list of recent calculations in localStorage.
            * @returns {{addHistory: (item: object) => void}}
            */
            
            const useCalculationHistory = () => {
            const addHistory = React.useCallback((item) => {
            try {
               const history = JSON.parse(localStorage.getItem('rad_tool_calculation_history') || '[]');
               const newHistory = [item, ...history];
               // Keep only the 5 most recent calculations
               const limitedHistory = newHistory.slice(0, 5);
               localStorage.setItem('rad_tool_calculation_history', JSON.stringify(limitedHistory));
            } catch (e) {
               console.error("Failed to update calculation history:", e);
            }
            }, []); // Empty dependency array makes this function stable
            return { addHistory };
            };
            
            //==============================================================================
            // --- REUSABLE UI COMPONENTS
            //==============================================================================
            
            
            /**
             * @description Displays a compact summary of a nuclide's key properties within a calculator.
             * @param {{nuclide: object}} props - The nuclide object to display context for.
             */
            
            const NuclideContextDisplay = ({ nuclide }) => {
                if (!nuclide) return null;
            
                const properties = [
                    {
                        label: 'Half-life',
                        value: formatHalfLife(nuclide.halfLife, getBestHalfLifeUnit(parseHalfLifeToSeconds(nuclide.halfLife))),
                        condition: nuclide.halfLife && nuclide.halfLife !== 'Stable'
                    },
                    {
                        label: 'β Eₘₐₓ',
                        value: (nuclide.emissionEnergies?.beta || [])[0]?.replace(' (max)', ''),
                        condition: nuclide.emissionEnergies?.beta?.length > 0
                    },
            {
                        label: 'β Eₐᵥ₉',
                        value: `${nuclide.avgBetaEnergy} MeV`,
                        condition: nuclide.avgBetaEnergy
                    },
                    {
                        label: 'Γ Constant',
                        value: nuclide.gammaConstant,
                        condition: nuclide.gammaConstant
                    },
                    {
                        label: 'Emissions',
                        value: (nuclide.emissionType || []).join(', '),
                        condition: nuclide.emissionType?.length > 0
                    },
                    {
                        label: 'Specific Activity',
                        value: nuclide.specificActivity,
                        condition: nuclide.specificActivity
                    },
                ];
            
                const availableProperties = properties.filter(p => p.condition);
            
                if (availableProperties.length === 0) return null;
            
                return (
                    <div className="p-3 my-2 bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-lg animate-fade-in text-xs">
                        <div className={`grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-1`}>
                            {availableProperties.map(prop => (
                                <div key={prop.label} className="truncate">
                                    <span className="font-semibold text-slate-500 dark:text-slate-400">{prop.label}: </span>
                                    <span className="text-slate-700 dark:text-slate-200" title={prop.value}>{prop.value}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };
            
            /**
            * @description Displays a styled note for disclaimers or contextual info.
            * @param {{children: React.ReactNode, type: 'info' | 'warning'}} props
            */
            const ContextualNote = ({ children, type = 'info' }) => {
            const styles = {
            info: {
               container: 'bg-slate-100 dark:bg-slate-800/50 border-slate-300 dark:border-slate-700',
               iconColor: 'text-slate-500 dark:text-slate-400',
            },
            warning: {
               container: 'bg-amber-50 dark:bg-amber-900/30 border-amber-300 dark:border-amber-700',
               iconColor: 'text-amber-600 dark:text-amber-400',
            }
            };
            const selectedStyle = styles[type] || styles.info;
            
            return (
            <div className={`mt-4 p-3 border-l-4 rounded-r-lg text-xs ${selectedStyle.container}`}>
               <div className="flex">
                   <div className="flex-shrink-0">
                       <Icon path={ICONS.help} className={`w-4 h-4 mr-2 ${selectedStyle.iconColor}`} />
                   </div>
                   <div className="flex-grow text-slate-600 dark:text-slate-300">
                       {children}
                   </div>
               </div>
            </div>
            );
            };
            
            const Tooltip = ({ text, children, widthClass = 'w-96' }) => {
            
            // --- Modified state to hold a flexible style object ---
            
            const [tooltipState, setTooltipState] = React.useState({
            show: false,
            style: { opacity: 0, visibility: 'hidden' },
            position: 'bottom'
            });
            const triggerRef = React.useRef(null);
            const timeoutRef = React.useRef(null);
            
            // --- Rewrote handleMouseEnter with responsive logic ---
            
            const handleMouseEnter = () => {
            if (triggerRef.current) {
            const rect = triggerRef.current.getBoundingClientRect();
            const position = rect.top > window.innerHeight / 2 ? 'top' : 'bottom';
            const screenPadding = 8; // 8px padding from the viewport edge
            
            const newStyle = {
            top: position === 'bottom' ? rect.bottom : rect.top,
            visibility: 'visible',
            opacity: 1,
            };
            
            // Check if trigger is in the right half of the screen
            
            if (rect.left + rect.width / 2 > window.innerWidth / 2) {
            
            // Align tooltip's RIGHT edge with trigger's RIGHT edge
            
            newStyle.right = window.innerWidth - rect.right;
            newStyle.transformOrigin = 'right'; // Optional: for smoother animations
            } else {
            
            // Align tooltip's LEFT edge with trigger's LEFT edge
            
            newStyle.left = rect.left;
            newStyle.transformOrigin = 'left'; // Optional: for smoother animations
            }
            
            if (timeoutRef.current) clearTimeout(timeoutRef.current);
            
            setTooltipState({
            show: true,
            style: newStyle,
            position: position
            });
            
            timeoutRef.current = setTimeout(() => {
            setTooltipState(prev => ({ ...prev, show: false }));
            }, 4000);
            }
            };
            
            // --- Updated handleMouseLeave to correctly hide the tooltip ---
            const handleMouseLeave = () => {
            if (timeoutRef.current) clearTimeout(timeoutRef.current);
            
            // Hide by reverting style properties
            
            setTooltipState(prev => ({
            ...prev,
            show: false
            }));
            };
            
            React.useEffect(() => {
            return () => {
            if (timeoutRef.current) clearTimeout(timeoutRef.current);
            };
            }, []);
            
            const positionClasses = tooltipState.position === 'bottom'
            ? 'translate-y-2'
            : '-translate-y-full -translate-y-2';
            
            // --- Modified the rendered element to use the new style object ---
            // Note the removal of "-translate-x-1/2" from the className
            
            const tooltipElement = (
            ReactDOM.createPortal(
            <div
            style={{
            ...tooltipState.style,
            
            // Smoothly transition opacity for the fade effect
            
            transition: 'opacity 0.2s ease-out',
            
            // Conditionally set opacity based on the 'show' state
            
            opacity: tooltipState.show ? 1 : 0,
            }}
            className={`fixed top-0 p-2 text-xs text-white bg-slate-800 dark:bg-slate-900 rounded-md shadow-lg z-50 pointer-events-none ${widthClass} ${positionClasses}`}
            >
            {text}
            </div>,
            document.body
            )
            );
            
            return (
            <>
            {React.cloneElement(children, {
            ref: triggerRef,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            })}
            {tooltipElement}
            </>
            );
            };
            
            const renderInputField = (label, value, setter, isEnabled, unitValue, unitSetter, unitOptions) => (
             <div>
                 <label className={`block text-sm font-medium ${isEnabled ? 'text-slate-700 dark:text-slate-300' : 'text-slate-400 dark:text-slate-500'}`}>{label}</label>
                 <div className="flex gap-2 mt-1">
                     <input type="number" value={value} onChange={e => setter(e.target.value)} disabled={!isEnabled} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 disabled:bg-slate-200 dark:disabled:bg-slate-800 disabled:cursor-not-allowed" />
                     {unitOptions && (
                         <select value={unitValue} onChange={e => unitSetter(e.target.value)} disabled={!isEnabled} className="p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 disabled:bg-slate-200 dark:disabled:bg-slate-800 disabled:cursor-not-allowed">
                             {unitOptions.map(u => <option key={u} value={u}>{u}</option>)}
                         </select>
                     )}
                 </div>
             </div>
            );
            
            /**
            * @description Helper component to parse nuclide strings with multiple daughters and extra text.
            * Handles strings like "Thorium-227 (β) or Francium-223 (α)" by making both isotopes clickable links
            * while preserving the surrounding text and separators.
            */
            const ClickableNuclide = ({ text, radionuclides, onNuclideClick }) => {
            if (!text || text === 'None' || text === 'Stable') {
            return <span className="text-slate-500 dark:text-slate-400 italic">{text || 'None'}</span>;
            }
            
            // 1. Split by common separators but keep them in the array (using capturing parentheses)
            // Separators: " or ", " / ", " -> ", or ","
            const parts = text.split(/(\s+or\s+|\s*\/\s*|\s*->\s*|,\s+)/i);
            
            return (
            <span className="inline-flex flex-wrap items-baseline gap-x-0.5">
            {parts.map((part, index) => {
            // If this part is purely a separator, render it as plain text
            if (/^(\s+or\s+|\s*\/\s*|\s*->\s*|,\s+)$/i.test(part)) {
            return <span key={index} className="text-slate-500 dark:text-slate-400 mx-1">{part}</span>;
            }
            
            // 2. Separate the Nuclide Name from extra info like "(α)" or "(stable)"
            // Example: "Thorium-227 (β)" -> namePart="Thorium-227", extraPart=" (β)"
            const match = part.match(/^([a-zA-Z]+-\d+[mw]?)(.*)$/);
            
            let namePart = part.trim();
            let extraPart = '';
            
            if (match) {
            namePart = match[1]; // e.g., "Thorium-227"
            extraPart = match[2]; // e.g., " (β)"
            }
            
            // 3. Lookup the clean name in the database
            const nuclideMatch = radionuclides?.find(r => 
            r.name.toLowerCase() === namePart.toLowerCase() || 
            r.symbol.toLowerCase() === namePart.toLowerCase()
            );
            
            if (nuclideMatch) {
            return (
                <React.Fragment key={index}>
                    <button
                        onClick={(e) => { e.stopPropagation(); onNuclideClick(nuclideMatch); }}
                        className="text-sky-600 dark:text-sky-400 hover:text-sky-700 dark:hover:text-sky-300 hover:underline font-semibold transition-colors"
                    >
                        {namePart}
                    </button>
                    {extraPart && <span className="text-slate-600 dark:text-slate-300">{extraPart}</span>}
                </React.Fragment>
            );
            }
            
            // Fallback: If it looked like a nuclide but wasn't found (or just plain text), render as text
            return <span key={index} className="text-slate-700 dark:text-slate-300">{part}</span>;
            })}
            </span>
            );
            };
            
            /**
            * @description A reusable modal dialog for confirming user actions.
            * @param {{isOpen: boolean, onClose: () => void, onConfirm: () => void, title: string, children: React.ReactNode}} props
            */
            
            const ConfirmationModal = ({ isOpen, onClose, onConfirm, title, children }) => {
            if (!isOpen) return null;
            
            // The modal's JSX is now wrapped in ReactDOM.createPortal()
            
            return ReactDOM.createPortal(
            
            // Backdrop
            
            <div
               className="fixed inset-0 bg-black/60 z-50 flex justify-center items-center p-4 animate-fade-in"
               onClick={onClose} // Close modal if backdrop is clicked
            >
               {/* Modal Panel */}
            
               <div
                   className="bg-white dark:bg-slate-800 w-full max-w-md rounded-2xl shadow-2xl flex flex-col"
                   onClick={e => e.stopPropagation()} // Prevent click inside from closing modal
               >
                   <div className="p-6">
                       <h3 className="text-lg font-bold text-slate-900 dark:text-slate-100">{title}</h3>
                       <div className="mt-2 text-sm text-slate-600 dark:text-slate-300">
                           {children}
                       </div>
                   </div>
            
                   {/* Action Buttons */}
            
                   <div className="bg-slate-50 dark:bg-slate-900/50 px-6 py-3 flex justify-end items-center gap-3 rounded-b-2xl">
                       <button
                           onClick={onClose}
                           className="px-4 py-2 text-sm font-semibold text-slate-700 dark:text-slate-200 bg-white dark:bg-slate-700 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-50 dark:hover:bg-slate-600 transition-colors"
                       >
                           Cancel
                       </button>
                       <button
                           onClick={onConfirm}
                           className="px-4 py-2 text-sm font-semibold text-white bg-red-600 rounded-md hover:bg-red-700 transition-colors"
                       >
                           Confirm
                       </button>
                   </div>
               </div>
            </div>,
            document.getElementById('modal-root') // This tells React where to render the modal
            );
            };
            
            const ClearButton = ({ onClick }) => (
            <button onClick={onClick} className="text-xs text-sky-600 dark:text-sky-400 hover:underline font-semibold flex items-center gap-1 ml-auto">
            <Icon path={ICONS.clear} className="w-3 h-3"/> Clear Inputs
            </button>
            );
            
            /**
             * @description A button that copies a given text string to the clipboard and shows a confirmation.
             * @param {{textToCopy: string}} props - The text to be copied.
             */
            
            const CopyButton = ({ textToCopy }) => {
                const [copied, setCopied] = React.useState(false);
                const { addToast } = useToast();
            
                const handleCopy = () => {
                    if (textToCopy) {
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            addToast('Copied to clipboard!');
                            setCopied(true);
                            // Revert the icon back to the copy icon after 2 seconds.
                            setTimeout(() => setCopied(false), 2000);
                        });
                    }
                };
            
                return (
                    <button onClick={handleCopy} className="p-2 text-slate-400 hover:text-sky-500 transition-colors" title="Copy to clipboard" aria-label="Copy result to clipboard">
                        <Icon path={copied ? ICONS.check : ICONS.copy} className="w-5 h-5" />
                    </button>
                );
            };
            
            /**
             * @description The main header for the application.
             * @param {{onHelpClick: () => void, theme: string, toggleTheme: () => void}} props - Handlers and state for help and theme toggling.
             */
            
            const Header = ({ onHelpClick, theme, toggleTheme, onNavClick }) => (
            
            <header className="flex items-center p-4 md:p-6 border-b border-slate-200 dark:border-slate-700">
            
            <div className="flex-1 flex justify-start">
                <Tooltip text="Toggle Theme" widthClass="w-auto">
                    <button onClick={toggleTheme} className="p-2 text-slate-500 hover:text-sky-500 dark:text-slate-400 dark:hover:text-sky-400 transition-colors" aria-label="Toggle dark mode">
                        <Icon path={theme === 'dark' ? ICONS.sun : ICONS.moon} className="w-6 h-6" />
                    </button>
                </Tooltip>
            </div>
            
            <div className="flex-1 text-center">
                <h1 className="text-xl md:text-3xl font-bold text-gray-800 dark:text-slate-100">Health Physics Toolbox</h1>
                <p className="text-sm text-slate-500 dark:text-slate-400 mt-2">
                    Version: {VERSION} | Last Updated: {LAST_UPDATED}
                </p>
            </div>
            
            <div className="flex-1 flex justify-end items-center gap-2">
                {/* MODIFIED: Added rel="noopener noreferrer" for security */}
                <a href="https://www.buymeacoffee.com/jough" target="_blank" rel="noopener noreferrer" className="hidden md:block">
                    <img src="https://cdn.buymeacoffee.com/buttons/v2/default-blue.png" alt="Buy Me A Coffee" style={{ height: '36px', width: 'auto' }} />
                </a>
                <div className="flex flex-col">
                  <Tooltip text="Settings" widthClass="w-auto">
            
                      <button onClick={() => onNavClick(VIEWS.SETTINGS)} className="p-1 text-slate-500 hover:text-sky-500 dark:text-slate-400 dark:hover:text-sky-400 transition-colors" aria-label="Open settings panel">
                          <Icon path={ICONS.settings} className="w-5 h-5" />
                      </button>
                  </Tooltip>
                    <Tooltip text="Open User Manual" widthClass="w-auto">
                        <button onClick={onHelpClick} className="p-1 text-slate-500 hover:text-sky-500 dark:text-slate-400 dark:hover:text-sky-400 transition-colors" aria-label="Open User Manual">
                            <Icon path={ICONS.help} className="w-5 h-5" />
                        </button>
                    </Tooltip>
                </div>
            </div>
            </header>
            );
            
            /**
             * @description The primary search input with auto-suggestions.
             * @param {object} props - Contains all state and handlers for the search functionality.
             * @param {string} props.nuclideName - The current value of the search input.
             * @param {React.RefObject} props.inputRef - Ref for the input element.
             * @param {(e: React.ChangeEvent) => void} props.handleNuclideNameChange - Handler for input changes.
             * @param {(e: React.KeyboardEvent) => void} props.handleKeyDown - Handler for keyboard events (arrow keys, Enter).
             * @param {() => void} props.onClear - Handler to clear the search input.
             * @param {Array<object>} props.suggestions - The list of suggestion items.
             * @param {number} props.activeSuggestionIndex - The index of the currently highlighted suggestion.
             * @param {React.RefObject} props.suggestionsRef - Ref for the suggestions list container.
             * @param {(nuclide: object) => void} props.handleNuclideSelection - Handler for when a nuclide is selected.
             */
            
            const SearchBar = ({ nuclideName, inputRef, handleNuclideNameChange, handleKeyDown, onClear, suggestions, activeSuggestionIndex, suggestionsRef, handleNuclideSelection, onNavClick, isFocused, onFocus, onBlur }) => (
            <div className="relative p-4 flex items-center gap-2">
            <div className="relative flex-grow">
               <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                   <Icon path={ICONS.search} className="w-5 h-5 text-slate-400" />
               </div>
               <input
                   ref={inputRef}
                   type="text"
                   value={nuclideName}
                   onChange={handleNuclideNameChange}
                   onKeyDown={handleKeyDown}
                   onFocus={onFocus}
                   onBlur={onBlur}
                   placeholder="Search by name or symbol (e.g., U-238)"
                   className="w-full p-3 pl-10 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 transition"
               />
               {nuclideName && (
                   <button onClick={onClear} className="absolute inset-y-0 right-0 pr-3 flex items-center text-slate-400 hover:text-sky-500 focus:outline-none">
                       <Icon path={ICONS.clear} className="w-5 h-5" />
                   </button>
               )}
            </div>
            
            <button
                onClick={() => onNavClick('home')}
                className="hidden md:flex items-center gap-2 p-3 md:px-4 bg-slate-100 dark:bg-slate-800 rounded-lg text-slate-500 hover:text-sky-500 dark:text-slate-400 dark:hover:text-sky-400 transition-colors border border-slate-300 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500"
                aria-label="Home"
            >
                <Icon path={ICONS.home} className="w-5 h-5" />
                <span className="font-semibold">Home</span>
            </button>
            
            {isFocused && suggestions.length > 0 && (
               <ul ref={suggestionsRef} className="absolute z-20 top-full left-4 right-4 mt-2 bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-700 rounded-lg shadow-lg max-h-72 overflow-y-auto">
                   {suggestions.map((s, i) => {
                       const styles = CATEGORY_STYLES[s.category] || CATEGORY_STYLES['default'];
                       return (
                           <li
                               key={s.symbol}
                               className={`p-3 pl-4 cursor-pointer text-slate-700 dark:text-slate-200 border-l-2 ${styles.border} ${styles.hoverBg} ${i === activeSuggestionIndex ? 'bg-sky-100 dark:bg-sky-900/50' : ''}`}
                               onClick={() => handleNuclideSelection(s)}
                           >
                               {s.name} ({s.symbol}) <span className="text-xs text-slate-500 dark:text-slate-400">{s.commonality}</span>
                           </li>
                       );
                   })}
                   {suggestions.length > 4 && (
                       <div className="sticky bottom-0 bg-slate-50/95 dark:bg-slate-900/95 backdrop-blur-sm p-2 border-t border-slate-200 dark:border-slate-700">
                           <div className="flex flex-wrap justify-center gap-x-3 gap-y-1">
                               {Object.entries(CATEGORY_STYLES).filter(([key]) => key !== 'default').map(([category, styles]) => {
                                   const bgColor = styles.border.replace('border-l-', 'bg-');
                                   return (
                                       <div key={category} className="flex items-center gap-1.5">
                                           <div className={`w-2.5 h-2.5 rounded-full ${bgColor}`}></div>
                                           <span className="text-xs text-slate-500 dark:text-slate-400">{category.replace('/', '/ ')}</span>
                                       </div>
                                   );
                               })}
                           </div>
                       </div>
                   )}
               </ul>
            )}
            </div>
            );
            
            /**
            * @description A button that appears when the user scrolls down, allowing them to quickly return to the top of the page.
            */
            
            const BackToTopButton = () => {
            const [isVisible, setIsVisible] = React.useState(false);
            
            // This function is called whenever the user scrolls
            
            const toggleVisibility = () => {
            if (window.pageYOffset > 300) { // Show button if scrolled more than 300px
                setIsVisible(true);
            } else {
                setIsVisible(false);
            }
            };
            
            // This function scrolls the page to the top smoothly
            
            const scrollToTop = () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
            };
            
            React.useEffect(() => {
            window.addEventListener('scroll', toggleVisibility);
            // Clean up the listener when the component is removed
            return () => {
                window.removeEventListener('scroll', toggleVisibility);
            };
            }, []);
            
            return (
            <div className="fixed bottom-4 right-4 z-50">
                {isVisible && (
                    <button
                        onClick={scrollToTop}
                        className="p-3 bg-sky-600 text-white rounded-full shadow-lg hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 transition-all duration-300 animate-fade-in"
                        aria-label="Go to top"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
                        </svg>
                    </button>
                )}
            </div>
            );
            };
            
            /**
             * @description The main navigation bar, which is responsive for mobile and desktop.
             * @param {{activeView: string, onNavClick: (view: string) => void}} props - The currently active view and the click handler.
             */
            
            const MainNav = ({ activeView, onNavClick }) => {
            
            const navItems = [
            { id: VIEWS.HOME, label: 'Home', icon: ICONS.home },
            { id: VIEWS.DATABASE, label: 'Database', icon: ICONS.database },
            { id: VIEWS.COMPARE, label: 'Compare', icon: ICONS.compare },
            { id: VIEWS.CALCULATOR, label: 'Decay', icon: ICONS.calculator },
            { id: VIEWS.MDA, label: 'MDA', icon: ICONS.search },
            { id: VIEWS.MARSSIM_SAMPLES, label: 'MARSSIM Sample Design', icon: ICONS.calculator },
            { id: VIEWS.MARSSIM_TESTS, label: 'MARSSIM Tests', icon: ICONS.database },
            { id: VIEWS.SERIES_CALCULATOR, label: 'Series Decay', icon: ICONS.series },
            { id: VIEWS.EQUILIBRIUM, label: 'Equilibrium', icon: ICONS.activity },
            { id: VIEWS.RADON, label: 'Radon', icon: ICONS.radon },
            { id: VIEWS.ACTIVITY_MASS, label: 'Activity/Mass', icon: ICONS.mass },
            { id: VIEWS.DOSE_RATE, label: 'Dose & Dose Rate', icon: ICONS.doseRate },
            { id: VIEWS.SHIELDING, label: 'Shielding', icon: ICONS.shield },
            { id: VIEWS.STAY_TIME, label: 'Stay Time', icon: ICONS.stopwatch },
            { id: VIEWS.NEUTRON, label: 'Neutron Tools', icon: ICONS.neutron },
            { id: VIEWS.OPERATIONAL_HP, label: 'Operational HP', icon: ICONS.shield },
            { id: VIEWS.TRANSPORTATION, label: 'Transportation', icon: ICONS.transport },
            { id: VIEWS.CONVERTER, label: 'Converter', icon: ICONS.converter },
            { id: VIEWS.LAB_STATS, label: 'Lab Stats', icon: ICONS.labStats },
            { id: VIEWS.PEAK_ID, label: 'Peak ID', icon: ICONS.gammaSpec },
            { id: VIEWS.MEDICAL, label: 'Medical', icon: ICONS.medical },
            
            { id: VIEWS.SCRATCHPAD, label: 'Scratchpad', icon: ICONS.notepad },
            
            { id: VIEWS.SCIENTIFIC_CALCULATOR, label: 'Sci. Calculator', icon: ICONS.scientificCalculator },
            
            { id: VIEWS.REFERENCES, label: 'References', icon: ICONS.references }
            ];
            
            const NavButton = ({ item }) => (
            <button
               onClick={() => onNavClick(item.id)}
               className="flex-shrink-0 w-full"
            >
               <span
                    className={`mx-auto flex items-center justify-center gap-2 px-2 py-2 text-sm font-semibold rounded-md transition-all duration-200 ${
                       activeView === item.id
                           ? 'bg-white dark:bg-slate-900 text-sky-600 dark:text-sky-400 shadow'
                           : 'text-slate-600 dark:text-slate-300 hover:bg-sky-100 dark:hover:bg-sky-800 hover:text-sky-600 dark:hover:text-sky-400 hover:shadow-md hover:-translate-y-1'
                   }`}
               >
                   <Icon path={item.icon} className="w-4 h-4" />
                   <span className="truncate">{item.label}</span>
               </span>
            </button>
            );
            
            return (
            <div className="px-4 pb-2">
               <div className="md:hidden">
                   <div className="grid grid-cols-2 gap-4">
                       {navItems.map(item => (
                           <button
                               key={item.id}
                               onClick={() => onNavClick(item.id)}
                               // --- MODIFIED LINE: Removed the col-span-2 conditional ---
                               className={`flex flex-col items-center justify-center p-4 rounded-lg text-center transition-all duration-150 ease-in-out ${
                                   activeView === item.id
                                       ? 'bg-sky-100 dark:bg-sky-900/50 text-sky-600 dark:text-sky-400'
                                       : 'bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 hover:bg-sky-100 dark:hover:bg-sky-900/50 active:scale-95'
                               }`}
                           >
                               <Icon path={item.icon} className="w-8 h-8 mb-2" />
                               <span className="text-sm font-semibold">{item.label}</span>
                           </button>
                       ))}
                   </div>
               </div>
               <div className="hidden md:grid grid-cols-4 lg:grid-cols-6 gap-2">
            
            {navItems.map(item => <NavButton key={item.id} item={item} />)}
            
               </div>
            </div>
            );
            };
            
            //==============================================================================
            // --- VIEW COMPONENTS
            // These components represent the main content areas of the application.
            //==============================================================================
            
            const CalculationHistoryPanel = () => {
             // Note: Removed onNavClick prop since we are making this read-only
             const [history, setHistory] = React.useState([]);
             const [isClearModalOpen, setIsClearModalOpen] = React.useState(false);
            
            React.useEffect(() => {
            const savedHistory = localStorage.getItem('rad_tool_calculation_history');
            if (savedHistory) {
                try {
                    // Wrap JSON.parse in try/catch to prevent app crash on corrupted data
                    const parsed = JSON.parse(savedHistory);
                    if (Array.isArray(parsed)) {
                        setHistory(parsed);
                    } else {
                        throw new Error("Invalid history format");
                    }
                } catch (e) {
                    console.error("Corrupted calculation history detected. Resetting.", e);
                    localStorage.removeItem('rad_tool_calculation_history');
                    setHistory([]);
                }
            }
            }, []);
            
             const handleClearHistory = () => {
                 localStorage.removeItem('rad_tool_calculation_history');
                 setHistory([]);
                 setIsClearModalOpen(false);
             };
            
             // Helper to format the timestamp
             const formatTime = (timestamp) => {
                 if (!timestamp) return '';
                 return new Date(timestamp).toLocaleString('en-US', {
                     month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'
                 });
             };
            
             if (history.length === 0) {
                   return (
                       <div className="bg-slate-100 dark:bg-slate-800/50 p-6 rounded-xl text-center border-2 border-dashed border-slate-300 dark:border-slate-700">
                           <p className="text-slate-500 dark:text-slate-400 font-semibold">No Saved Calculations</p>
                           <p className="text-xs text-slate-400 dark:text-slate-500 mt-1">
                               Look for the <span className="inline-block align-middle"><svg className="w-3 h-3 inline" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg></span> icon in calculator results to pin them here.
                           </p>
                       </div>
                   );
               }
            
             return (
                 <>
                     <div className="bg-slate-100 dark:bg-slate-800/50 p-6 rounded-xl animate-fade-in">
                         <div className="flex justify-between items-center mb-4">
                             <h4 className="text-lg font-bold text-slate-700 dark:text-slate-200 text-left">Saved Calculations</h4>
                             {/* FIX: Renamed button to be specific */}
                             <button onClick={() => setIsClearModalOpen(true)} className="text-xs text-sky-600 dark:text-sky-400 hover:underline font-semibold">
                                 Clear Calculations
                             </button>
                         </div>
                         <div className="space-y-3">
                             {history.map(item => (
                                 <div
                                     key={item.id}
                                     className="w-full text-left p-3 bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-slate-200 dark:border-slate-700 relative"
                                 >
                                     {/* Timestamp Badge */}
                                     <span className="absolute top-3 right-3 text-[10px] text-slate-400 font-mono bg-slate-100 dark:bg-slate-700 px-1.5 py-0.5 rounded">
                                         {formatTime(item.id)}
                                     </span>
            
                                     <div className="flex items-start gap-4 pr-16">
                                         {item.icon && <Icon path={item.icon} className="w-8 h-8 text-slate-400 dark:text-slate-500 mt-1 flex-shrink-0" />}
                                         <div className="flex-grow">
                                             <p className="font-bold text-sky-600 dark:text-sky-400">{item.type}</p>
                                             <p className="text-sm text-slate-600 dark:text-slate-300">
                                                 <span className="font-semibold">Inputs:</span> {item.inputs}
                                             </p>
                                             <p className="text-sm text-slate-800 dark:text-slate-100">
                                                 <span className="font-semibold">Result:</span> {item.result}
                                             </p>
                                         </div>
                                     </div>
                                 </div>
                             ))}
                         </div>
                     </div>
            
                     <ConfirmationModal
                         isOpen={isClearModalOpen}
                         onClose={() => setIsClearModalOpen(false)}
                         onConfirm={handleClearHistory}
                         title="Clear Calculation History"
                     >
                         <p>Are you sure you want to clear your recently saved calculations?</p>
                     </ConfirmationModal>
                 </>
             );
            };
            
            /**
            * @description The landing page view, showing suggestions, search history, favorites, or the main search result.
            * @param {object} props - Contains data and handlers for the home page.
            */
            
            const HomePage = ({ errorMessage, randomSuggestions, searchHistory, handleNuclideSelection, handleClearHistory, favorites, radionuclides, handleClearFavorites, onNavClick }) => {
            const [isFavoritesModalOpen, setIsFavoritesModalOpen] = React.useState(false);
            const [isHistoryModalOpen, setIsHistoryModalOpen] = React.useState(false);
            
            // --- NEW: State to track if the welcome banner was manually dismissed ---
            const [isBannerDismissed, setIsBannerDismissed] = React.useState(() => {
            return localStorage.getItem('rad_tool_welcome_dismissed') === 'true';
            });
            
            const handleDismissBanner = () => {
            setIsBannerDismissed(true);
            localStorage.setItem('rad_tool_welcome_dismissed', 'true');
            };
            
            const favoriteNuclides = React.useMemo(() =>
            favorites.map(symbol => radionuclides.find(n => n.symbol === symbol)).filter(Boolean),
            [favorites, radionuclides]
            );
            
            const searchHistoryNuclides = React.useMemo(() =>
            searchHistory.map(symbol => radionuclides.find(n => n.symbol === symbol)).filter(Boolean),
            [searchHistory, radionuclides]
            );
            
            const confirmClearFavorites = () => {
            handleClearFavorites();
            setIsFavoritesModalOpen(false);
            };
            
            const confirmClearHistory = () => {
            handleClearHistory();
            setIsHistoryModalOpen(false);
            };
            
            // --- Hide if user has history OR if they manually dismissed it ---
            const isNewUser = favoriteNuclides.length === 0 && searchHistoryNuclides.length === 0 && !isBannerDismissed;
            
            return (
            <div className="p-4 sm:p-6 space-y-6">
               {errorMessage && (
                   <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md" role="alert">
                       <p className="font-bold">Error</p><p>{errorMessage}</p>
                   </div>
               )}
            
               {/* --- Educational Welcome Banner --- */}
               {isNewUser && (
                   <div className="relative bg-white dark:bg-slate-800 rounded-xl p-6 shadow-lg border border-slate-200 dark:border-slate-700 border-l-8 border-l-sky-500 animate-fade-in group">
                       
                       {/* NEW: Close Button */}
                       <button 
                           onClick={handleDismissBanner}
                           className="absolute top-2 right-2 p-2 text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-full transition-colors"
                           title="Dismiss Welcome Message"
                       >
                           <Icon path={ICONS.clear} className="w-5 h-5" />
                       </button>
            
                       <h2 className="text-2xl font-bold text-slate-800 dark:text-white mb-2 pr-8">Welcome to the Health Physics Toolbox</h2>
                       <p className="text-slate-600 dark:text-slate-300 mb-6 max-w-3xl">
                           This is a unified platform for radiological calculations. Data flows automatically from the database to the tools, saving you time and reducing manual entry errors.
                       </p>
            
                       <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                           {/* Feature 1: Database */}
                           <div className="flex flex-col gap-2">
                               <div className="flex items-center gap-2 text-sky-600 dark:text-sky-400">
                                   <div className="p-2 bg-sky-50 dark:bg-sky-900/30 rounded-lg">
                                       <Icon path={ICONS.database} className="w-6 h-6" />
                                   </div>
                                   <h3 className="font-bold text-lg">Robust Database</h3>
                               </div>
                               <p className="text-sm text-slate-600 dark:text-slate-400">
                                   Access detailed decay properties, gamma constants, and regulatory limits (10 CFR 20, DOT) for over 100 radionuclides. Start by searching above.
                               </p>
                           </div>
            
                           {/* Feature 2: Smart Calculators */}
                           <div className="flex flex-col gap-2">
                               <div className="flex items-center gap-2 text-amber-600 dark:text-amber-400">
                                   <div className="p-2 bg-amber-50 dark:bg-amber-900/30 rounded-lg">
                                       <Icon path={ICONS.calculator} className="w-6 h-6" />
                                   </div>
                                   <h3 className="font-bold text-lg">Integrated Math</h3>
                               </div>
                               <p className="text-sm text-slate-600 dark:text-slate-400">
                                   Select a nuclide to pre-fill standard values into shielding, decay, and dose rate calculators. No more looking up half-lives manually.
                               </p>
                           </div>
            
                           {/* Feature 3: Operational Tools */}
                           <div className="flex flex-col gap-2">
                               <div className="flex items-center gap-2 text-emerald-600 dark:text-emerald-400">
                                   <div className="p-2 bg-emerald-50 dark:bg-emerald-900/30 rounded-lg">
                                       <Icon path={ICONS.shield} className="w-6 h-6" />
                                   </div>
                                   <h3 className="font-bold text-lg">Field Ready</h3>
                               </div>
                               <p className="text-sm text-slate-600 dark:text-slate-400">
                                   Plan MARSSIM surveys, determine shipping labels, or calculate patient release criteria with tools designed for operational health physics.
                               </p>
                           </div>
                       </div>
                   </div>
               )}
            
               {/* --- 1. FAVORITES --- */}
            {favoriteNuclides.length > 0 && (
            <div className="bg-slate-100 dark:bg-slate-800/50 p-6 rounded-xl animate-fade-in">
            <div className="flex justify-between items-center mb-4">
               <h4 className="text-lg font-bold text-slate-700 dark:text-slate-200 text-left">Your Favorites</h4>
               <button onClick={() => setIsFavoritesModalOpen(true)} className="text-xs text-sky-600 dark:text-sky-400 hover:underline focus:outline-none">
                   Clear Favorites
               </button>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
               {favoriteNuclides.map(n => (
                   <NuclideCard
                       key={n.symbol}
                       nuclide={n}
                       isCompact={true}
                       // Pass true to skip adding this to search history again
                       onNuclideClick={(n) => handleNuclideSelection(n, true)}
                   />
               ))}
            </div>
            </div>
            )}
            
            {/* --- 2. RECENT SEARCHES --- */}
            {searchHistoryNuclides.length > 0 && (
            <div className="bg-slate-100 dark:bg-slate-800/50 p-6 rounded-xl animate-fade-in">
            <div className="flex justify-between items-center mb-4">
               <h4 className="text-lg font-bold text-slate-700 dark:text-slate-200 text-left">Recent Searches</h4>
            
               <button onClick={() => setIsHistoryModalOpen(true)} className="text-xs text-sky-600 dark:text-sky-400 hover:underline focus:outline-none">
                   Clear Searches
               </button>
            
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
               {searchHistoryNuclides.map(n => (
                   <NuclideCard
                       key={n.symbol}
                       nuclide={n}
                       isCompact={true}
                       // Pass true here too
                       onNuclideClick={(n) => handleNuclideSelection(n, true)}
                   />
               ))}
            </div>
            </div>
            )}
            
               {/* --- 3. RECENT CALCULATIONS --- */}
               <CalculationHistoryPanel onNavClick={onNavClick} />
            
               {/* --- 4. QUICK SUGGESTIONS --- */}
               <div className="bg-slate-100 dark:bg-slate-800/50 p-6 rounded-xl">
                   <h4 className="text-lg font-bold text-slate-700 dark:text-slate-200 mb-4 text-left">Quick Suggestions</h4>
                   <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                       {randomSuggestions.map(n => (
                           <NuclideCard
                               key={n.symbol}
                               nuclide={n}
                               isCompact={true}
                               onNuclideClick={handleNuclideSelection}
                           />
                       ))}
                   </div>
               </div>
            
               <ConfirmationModal
                   isOpen={isFavoritesModalOpen}
                   onClose={() => setIsFavoritesModalOpen(false)}
                   onConfirm={confirmClearFavorites}
                   title="Clear All Favorites"
               >
                   <p>Are you sure you want to clear your entire list of favorites? This action cannot be undone.</p>
               </ConfirmationModal>
            
               <ConfirmationModal
                   isOpen={isHistoryModalOpen}
                   onClose={() => setIsHistoryModalOpen(false)}
                   onConfirm={confirmClearHistory}
                   title="Clear Search History"
               >
                   <p>Are you sure you want to clear your recent search history?</p>
               </ConfirmationModal>
            
            </div>
            );
            };
            
            /**
            * @description A robust note-taking component with Markdown preview support.
            * * @param {{notes: string, setNotes: (notes: string) => void}} props
            */
            const Scratchpad = ({ notes, setNotes }) => {
            const [isClearModalOpen, setIsClearModalOpen] = React.useState(false);
            const [viewMode, setViewMode] = React.useState('edit'); // 'edit' or 'preview'
            const { addToast } = useToast();
            
            const handleCopyAll = () => {
            if (notes) {
            navigator.clipboard.writeText(notes);
            addToast('Notes copied to clipboard!');
            }
            };
            
            const handleExport = () => {
            // Reference the 'notes' prop/state, not 'filteredList'
            if (!notes || notes.trim() === '') {
            addToast("Nothing to save!");
            return;
            }
            
            const blob = new Blob([notes], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `scratchpad_notes_${new Date().toISOString().slice(0,10)}.txt`; // Add a timestamp to the filename
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url); // Clean up the created URL
            };
            
            const handleInsertTimestamp = () => {
            const timestamp = new Date().toLocaleString();
            setNotes(prev => prev + `\n**[${timestamp}]**\n`);
            addToast('Timestamp inserted!');
            };
            
            const handleConfirmClear = () => {
            setNotes('');
            setIsClearModalOpen(false);
            addToast('Scratchpad cleared.');
            };
            
            // Stats
            const characterCount = notes.replace(/\s/g, '').length; // Count non-whitespace chars
            const wordCount = notes.trim() === '' ? 0 : notes.trim().split(/\s+/).filter(Boolean).length;
            
            // Simple Markdown Parser (for Preview)
            const renderMarkdown = (text) => {
            if (!text) return <p className="text-slate-400 italic">Nothing to preview...</p>;
            
            return text.split('\n').map((line, i) => {
            // Headers
            if (line.startsWith('### ')) return <h3 key={i} className="text-lg font-bold mt-2 mb-1">{line.slice(4)}</h3>;
            if (line.startsWith('## ')) return <h2 key={i} className="text-xl font-bold mt-3 mb-2 border-b border-slate-200 dark:border-slate-700 pb-1">{line.slice(3)}</h2>;
            if (line.startsWith('# ')) return <h1 key={i} className="text-2xl font-extrabold mt-4 mb-2">{line.slice(2)}</h1>;
            
            // Lists
            if (line.startsWith('- ')) return <li key={i} className="ml-4 list-disc">{line.slice(2)}</li>;
            
            // Bold (Simple regex for **text**)
            const parts = line.split(/(\*\*.*?\*\*)/g);
            return (
              <p key={i} className="min-h-[1.2em] mb-1">
                  {parts.map((part, j) => {
                      if (part.startsWith('**') && part.endsWith('**')) {
                          return <strong key={j}>{part.slice(2, -2)}</strong>;
                      }
                      return part;
                  })}
              </p>
            );
            });
            };
            
            return (
            <>
            <div className="flex justify-between items-end mb-2">
              <p className="text-sm text-slate-500 dark:text-slate-400">
                  Auto-saved to local storage. Supports basic Markdown.
              </p>
              {/* View Toggle */}
              <div className="flex bg-slate-200 dark:bg-slate-700 rounded-lg p-1">
                  <button onClick={() => setViewMode('edit')} className={`px-3 py-1 text-xs font-bold rounded-md transition-all ${viewMode === 'edit' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Edit</button>
                  <button onClick={() => setViewMode('preview')} className={`px-3 py-1 text-xs font-bold rounded-md transition-all ${viewMode === 'preview' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Preview</button>
              </div>
            </div>
            
            <div className="bg-slate-100 dark:bg-slate-700/50 rounded-t-md border-b border-slate-200 dark:border-slate-700 p-2 flex flex-wrap items-center gap-2">
              <button onClick={handleInsertTimestamp} className="px-3 py-1.5 text-xs bg-white dark:bg-slate-600 border border-slate-300 dark:border-slate-500 rounded hover:bg-slate-50 dark:hover:bg-slate-500 transition font-medium flex items-center gap-1">
                  <Icon path={ICONS.stopwatch} className="w-3 h-3" /> Timestamp
              </button>
              <button onClick={handleCopyAll} className="px-3 py-1.5 text-xs bg-white dark:bg-slate-600 border border-slate-300 dark:border-slate-500 rounded hover:bg-slate-50 dark:hover:bg-slate-500 transition font-medium flex items-center gap-1">
                  <Icon path={ICONS.copy} className="w-3 h-3" /> Copy
              </button>
              <button onClick={handleExport} className="px-3 py-1.5 text-xs bg-white dark:bg-slate-600 border border-slate-300 dark:border-slate-500 rounded hover:bg-slate-50 dark:hover:bg-slate-500 transition font-medium flex items-center gap-1">
                  <Icon path={ICONS.database} className="w-3 h-3" /> Save .txt
              </button>
              <div className="flex-grow"></div>
              <button onClick={() => setIsClearModalOpen(true)} className="text-xs text-red-500 hover:text-red-700 font-bold flex items-center gap-1 px-2">
                  <Icon path={ICONS.clear} className="w-3 h-3"/> Clear
              </button>
            </div>
            
            {viewMode === 'edit' ? (
              <textarea
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  placeholder="# Project Notes\n- Alpha survey complete\n- Background: 50 cpm"
                  className="w-full h-96 p-4 rounded-b-md bg-white dark:bg-slate-900 font-mono text-sm border-x border-b border-slate-200 dark:border-slate-700 focus:ring-2 focus:ring-sky-500 focus:outline-none resize-none"
              />
            ) : (
              <div className="w-full h-96 p-6 rounded-b-md bg-white dark:bg-slate-900 overflow-y-auto border-x border-b border-slate-200 dark:border-slate-700 prose dark:prose-invert max-w-none text-sm">
                  {renderMarkdown(notes)}
              </div>
            )}
            
            <div className="flex justify-between items-center mt-2 px-1">
              <span className="text-[10px] text-slate-400">Markdown supported: # Header, **Bold**, - List</span>
              <div className="text-right text-xs text-slate-500 dark:text-slate-400 font-mono">
                  <span className="font-bold">{wordCount}</span> words <span className="mx-1 opacity-30">|</span> <span className="font-bold">{characterCount}</span> chars
              </div>
            </div>
            
            <ConfirmationModal
              isOpen={isClearModalOpen}
              onClose={() => setIsClearModalOpen(false)}
              onConfirm={handleConfirmClear}
              title="Clear Scratchpad?"
            >
              <p>Are you sure you want to delete all notes? This cannot be undone.</p>
            </ConfirmationModal>
            </>
            );
            };
            
            /**
            * @description A professional-grade scientific calculator component.
            */
            
            const ScientificCalculator = ({ calcState, setCalcState }) => {
            const { addToast } = useToast();
            const calculatorRef = React.useRef(null);
            
            // --- State ---
            const [customConstants, setCustomConstants] = React.useState(() => {
            try { return JSON.parse(localStorage.getItem('user_calc_constants') || '[]'); }
            catch { return []; }
            });
            const [isAddMode, setIsAddMode] = React.useState(false);
            const [newConstName, setNewConstName] = React.useState('');
            const [newConstVal, setNewConstVal] = React.useState('');
            const [angleMode, setAngleMode] = React.useState('deg'); // Default to DEG (more common for techs)
            const [activeKey, setActiveKey] = React.useState(null);
            
            // Ensure state has new fields
            React.useEffect(() => {
            setCalcState(prev => ({
            ...prev,
            lastAnswer: prev.lastAnswer || 0,
            memory: prev.memory || 0,
            isError: false
            }));
            }, [setCalcState]);
            
            // Save constants
            React.useEffect(() => {
            localStorage.setItem('user_calc_constants', JSON.stringify(customConstants));
            }, [customConstants]);
            
            const { expression, result, history, memory, lastAnswer, isError } = calcState;
            
            // --- Helper: Format Display Number ---
            const formatNumber = (numStr) => {
            if (!numStr) return '';
            if (numStr.includes('e') || isError) return numStr;
            const num = parseFloat(numStr);
            if (isNaN(num)) return numStr;
            // Limit precision to fit screen, but keep decimals
            return num.toLocaleString('en-US', { maximumFractionDigits: 10, maximumSignificantDigits: 12 });
            };
            
            // --- Core Logic ---
            const safeEvaluate = (expr, currentMode, currentAns) => {
            try {
            // Clean up visual operators for mathjs
            let cleanExpr = expr.replace(/×/g, '*').replace(/÷/g, '/');
            
            const scope = {
              Ans: currentAns,
              ...math,
              ln: math.log,
              // Trig overrides for DEG mode: Only convert if input is a NUMBER.
              // If user types 'sin(90 deg)', x is a Unit, so we skip conversion to avoid error.
              sin: (x) => (currentMode === 'deg' && typeof x === 'number') ? math.sin(math.unit(x, 'deg')) : math.sin(x),
              cos: (x) => (currentMode === 'deg' && typeof x === 'number') ? math.cos(math.unit(x, 'deg')) : math.cos(x),
              tan: (x) => (currentMode === 'deg' && typeof x === 'number') ? math.tan(math.unit(x, 'deg')) : math.tan(x),
              
              // Inverse trig returns radians, so we convert TO degrees if in DEG mode
              asin: (x) => currentMode === 'deg' ? math.asin(x) * (180 / Math.PI) : math.asin(x),
              acos: (x) => currentMode === 'deg' ? math.acos(x) * (180 / Math.PI) : math.acos(x),
              atan: (x) => currentMode === 'deg' ? math.atan(x) * (180 / Math.PI) : math.atan(x),
            };
            
            const evalResult = math.evaluate(cleanExpr, scope);
            
            // Math.js returns objects {re, im} for complex results like sqrt(-1) or asin(2)
            if (typeof evalResult === 'object' || isNaN(evalResult)) {
                // If it has a real part and negligible imaginary part, use real.
                // Otherwise, throw error because UI can't handle complex numbers.
                if (evalResult && evalResult.re !== undefined && Math.abs(evalResult.im || 0) < 1e-9) {
                    return evalResult.re;
                }
                throw new Error('Domain Error');
            }
            
            return evalResult;
            } catch (e) {
                // Catch all calculation errors (Syntax, Domain, etc.)
                throw new Error('Error');
            }
            };
            
            const handleCalculate = React.useCallback(() => {
            setCalcState(currentState => {
            if (!currentState.expression) return currentState;
            try {
              const evalResult = safeEvaluate(currentState.expression, angleMode, currentState.lastAnswer);
            
              let resultStr;
              if (Math.abs(evalResult) < 1e-9 || Math.abs(evalResult) > 1e12) {
                  resultStr = evalResult.toExponential(6).replace('e+', 'e');
              } else {
                  resultStr = parseFloat(evalResult.toPrecision(12)).toString(); // Clean trailing zeros
              }
            
              // Add to history (Limit to 50 items)
              const newHistoryItem = { expr: currentState.expression, res: resultStr };
              const newHistory = [newHistoryItem, ...(currentState.history || [])].slice(0, 50);
            
              return {
                  ...currentState,
                  result: resultStr,
                  lastAnswer: evalResult,
                  history: newHistory,
                  expression: '',
                  isError: false
              };
            } catch (e) {
              return { ...currentState, result: 'Error', isError: true };
            }
            });
            }, [setCalcState, angleMode]);
            
            const handleInput = React.useCallback((val) => {
            setCalcState(currentState => {
            if (currentState.isError) {
              const initExpr = val === '.' ? '0.' : val;
              return { ...currentState, expression: initExpr, result: '', isError: false };
            }
            
            let newExpression = currentState.expression;
            const isOperator = ['+', '-', '*', '/', '^', '%', '!', '^', '×', '÷'].includes(val);
            
            // Smart Decimal: Prefix "0." if empty or after operator
            if (val === '.') {
              const segments = newExpression.split(/[\+\-\*\/\^\%\(\)×÷]/);
              const currentSegment = segments[segments.length - 1];
              if (currentSegment.includes('.')) return currentState; // Prevent 1.2.3
              if (newExpression === '' || /[\+\-\*\/\^\%\(×÷]$/.test(newExpression)) {
                   return { ...currentState, expression: newExpression + '0.', result: '' };
              }
            }
            
            // Smart Start: If result exists and typing operator, use Ans
            if (newExpression === '' && currentState.result !== '') {
              if (isOperator) {
                  newExpression = 'Ans';
              } else if (val === 'e') { // EXP shortcut
                  return { ...currentState, expression: 'Ans*10^', result: '' };
              } else if (!isNaN(parseInt(val)) || val === '.') {
                  // Typing number overwrites result (implicit AC)
                  const startVal = val === '.' ? '0.' : val;
                  return { ...currentState, expression: startVal, result: '' };
              }
            }
            
            // Smart EXP key
            if (val === 'e' && newExpression.endsWith('Ans')) {
              return { ...currentState, expression: newExpression + '*10^', result: '' };
            }
            
            return { ...currentState, expression: newExpression + val, result: '' };
            });
            
            if (calculatorRef.current) calculatorRef.current.focus();
            
            }, [setCalcState]);
            
            const handleClear = () => setCalcState(s => ({ ...s, expression: '', result: '', isError: false }));
            const handleBackspace = () => setCalcState(s => ({ ...s, expression: s.expression.slice(0, -1) }));
            
            // Memory
            const memClear = () => { setCalcState(s => ({ ...s, memory: 0 })); addToast("Memory Cleared"); };
            const memRecall = () => { setCalcState(s => ({ ...s, expression: s.expression + s.memory })); };
            const memAdd = () => {
            try {
            const valToStore = calcState.expression ? safeEvaluate(calcState.expression, angleMode, lastAnswer) : (parseFloat(calcState.result) || 0);
            setCalcState(s => ({ ...s, memory: s.memory + valToStore }));
            addToast(`M+ (${(calcState.memory + valToStore).toPrecision(4)})`);
            } catch { addToast("Invalid value"); }
            };
            const memSub = () => {
            try {
            const valToStore = calcState.expression ? safeEvaluate(calcState.expression, angleMode, lastAnswer) : (parseFloat(calcState.result) || 0);
            setCalcState(s => ({ ...s, memory: s.memory - valToStore }));
            addToast(`M- (${(calcState.memory - valToStore).toPrecision(4)})`);
            } catch { addToast("Invalid value"); }
            };
            
            const handleHistoryClick = (histItem) => {
            handleInput(histItem.res); // Insert the result
            addToast("Value inserted from history");
            };
            
            const copyResult = () => {
            const textToCopy = result || expression;
            if (textToCopy) {
            navigator.clipboard.writeText(textToCopy);
            addToast("Copied to clipboard");
            }
            };
            
            const handleKeyDown = React.useCallback((event) => {
            const { key } = event;
            if (event.target.tagName === 'INPUT') return;
            
            let mappedKey = key;
            if (key === 'Enter') mappedKey = '=';
            if (key === 'Escape') mappedKey = 'AC';
            if (key === 'Backspace' || key === 'Delete') mappedKey = 'DEL';
            
            setActiveKey(mappedKey);
            setTimeout(() => setActiveKey(null), 150);
            
            if (/[0-9+\-*/.^()%!]/.test(key)) { event.preventDefault(); handleInput(key); }
            else if (key === 'Enter' || key === '=') { event.preventDefault(); handleCalculate(); }
            else if (key === 'Backspace' || key === 'Delete') { event.preventDefault(); handleBackspace(); }
            else if (key === 'Escape') { event.preventDefault(); handleClear(); }
            else if (key === 'e' || key === 'E') { event.preventDefault(); handleInput('e'); }
            }, [handleInput, handleCalculate, handleBackspace, handleClear]);
            
            const insertConstant = (constVal, name) => {
            handleInput(constVal);
            addToast(`${name} inserted`);
            };
            
            const handleAddConstant = () => {
            if (!newConstName || !newConstVal) { addToast("Name and Value required"); return; }
            if (isNaN(parseFloat(newConstVal))) { addToast("Value must be a number"); return; }
            setCustomConstants(prev => [...prev, { name: newConstName, value: newConstVal }]);
            setNewConstName(''); setNewConstVal(''); setIsAddMode(false);
            addToast("Constant Saved");
            };
            
            const handleDeleteConstant = (index, name) => {
            setCustomConstants(prev => prev.filter((_, i) => i !== index));
            addToast(`Deleted ${name}`);
            };
            
            const btnClass = "p-3 text-sm font-bold rounded-lg transition-all shadow-sm border-b-2 active:border-b-0 active:translate-y-[2px] active:brightness-90 duration-75 select-none";
            const getBtnStyle = (baseStyle, keyVal) => {
            const isActive = activeKey === keyVal;
            return `${baseStyle} ${isActive ? 'brightness-90 border-b-0 translate-y-[2px]' : ''}`;
            };
            
            const styles = {
            num: `${btnClass} bg-slate-100 dark:bg-slate-800 text-slate-800 dark:text-slate-200 border-slate-300 dark:border-slate-900 hover:bg-slate-200 dark:hover:bg-slate-700`,
            op: `${btnClass} bg-slate-300 dark:bg-slate-600 text-slate-800 dark:text-slate-100 border-slate-400 dark:border-slate-900 hover:bg-slate-400 dark:hover:bg-slate-500`,
            func: `${btnClass} bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 text-xs border-slate-300 dark:border-slate-900 hover:bg-slate-300 dark:hover:bg-slate-600`,
            mem: `${btnClass} bg-amber-200 dark:bg-amber-700 text-amber-900 dark:text-amber-100 text-xs border-amber-300 dark:border-amber-900 hover:bg-amber-300 dark:hover:bg-amber-600`,
            action: `${btnClass} bg-sky-600 text-white border-sky-800 hover:bg-sky-500`,
            danger: `${btnClass} bg-red-500 text-white border-red-700 hover:bg-red-600`,
            del: `${btnClass} bg-red-200 dark:bg-red-900/50 text-red-800 dark:text-red-200 border-red-300 dark:border-red-900 hover:bg-red-300 dark:hover:bg-red-800`
            };
            
            return (
            <div
            ref={calculatorRef}
            onKeyDown={handleKeyDown}
            tabIndex="0"
            className="focus:outline-none rounded-2xl p-6 shadow-xl bg-sky-50 dark:bg-slate-900 border-2 border-sky-600 dark:border-sky-700 transition-colors"
            >
            {/* LCD Screen */}
            <div className="bg-slate-100 dark:bg-black rounded-xl p-4 mb-4 border-4 border-slate-300 dark:border-slate-700 shadow-inner relative">
            
              {/* Header Row */}
              <div className="flex justify-between items-start mb-2 h-6">
                  <div className="flex gap-2">
                      <button
                          onClick={() => setAngleMode(prev => prev === 'rad' ? 'deg' : 'rad')}
                          className="text-[10px] font-bold bg-slate-200 dark:bg-slate-800 text-slate-600 dark:text-slate-300 px-1.5 py-0.5 rounded shadow-sm hover:bg-slate-300 transition"
                      >
                          {angleMode.toUpperCase()}
                      </button>
                      {memory !== 0 && (
                          <span className="text-[10px] font-bold bg-amber-200 dark:bg-amber-700 text-amber-900 dark:text-amber-100 px-1.5 py-0.5 rounded shadow-sm animate-pulse">M</span>
                      )}
                  </div>
                  <div className="flex gap-2">
                      {(result || expression) && (
                          <Tooltip text="Copy Result">
                              <button onClick={copyResult} className="text-slate-400 hover:text-sky-600 transition">
                                  <Icon path={ICONS.copy} className="w-3.5 h-3.5" />
                              </button>
                          </Tooltip>
                      )}
                      <Tooltip text="Shortcuts: 'e'=EXP, Backspace=DEL" position="left">
                          <span className="text-slate-400 cursor-help"><Icon path={ICONS.help} className="w-3.5 h-3.5" /></span>
                      </Tooltip>
                  </div>
              </div>
            
              {/* History (Paper Tape Style) */}
              <div className="h-24 overflow-y-auto flex flex-col-reverse pr-1 custom-scrollbar gap-1">
                  {history.map((h, i) => (
                      <div
                          key={i}
                          onClick={() => handleHistoryClick(h)}
                          className="flex justify-between items-center text-[10px] font-mono cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-800 px-1 rounded transition-colors group"
                          title="Click to insert value"
                      >
                          <span className="text-slate-400 dark:text-slate-500 truncate max-w-[60%]">{h.expr}</span>
                          <span className="text-slate-600 dark:text-slate-300 font-bold group-hover:text-sky-600 dark:group-hover:text-sky-400">= {h.res}</span>
                      </div>
                  ))}
              </div>
            
              {/* Current Expression */}
              <div className="text-right h-8 overflow-hidden flex items-end justify-end mt-1">
                  <span className="text-sm font-mono text-slate-500 dark:text-slate-400 whitespace-pre">
                      {expression || (result ? 'Ans' : '')}
                  </span>
              </div>
            
              {/* Main Result */}
              <div className="text-right">
                  <span className={`text-3xl font-mono font-bold tracking-tight break-all ${isError ? 'text-red-500' : 'text-slate-800 dark:text-slate-100'}`}>
                      {result ? formatNumber(result) : (expression || '0')}
                  </span>
              </div>
            </div>
            
            {/* Keypad */}
            <div className="grid grid-cols-5 gap-2">
              <button onClick={memClear} className={styles.mem}>MC</button>
              <button onClick={memRecall} className={styles.mem}>MR</button>
              <button onClick={memAdd} className={styles.mem}>M+</button>
              <button onClick={memSub} className={styles.mem}>M-</button>
              <button onClick={handleClear} className={getBtnStyle(styles.danger, 'AC')}>AC</button>
            
              <button onClick={() => handleInput('sin(')} className={styles.func}>sin</button>
              <button onClick={() => handleInput('cos(')} className={styles.func}>cos</button>
              <button onClick={() => handleInput('tan(')} className={styles.func}>tan</button>
              <button onClick={() => handleInput('log10(')} className={styles.func}>log</button>
              <button onClick={() => handleInput('ln(')} className={styles.func}>ln</button>
            
              <button onClick={() => handleInput('^2')} className={styles.func}>x²</button>
              <button onClick={() => handleInput('^')} className={styles.func}>xʸ</button>
              <button onClick={() => handleInput('sqrt(')} className={styles.func}>√</button>
              <button onClick={() => handleInput('1/')} className={styles.func}>1/x</button>
              <button onClick={() => handleInput('!')} className={styles.func}>n!</button>
            
              <button onClick={() => handleInput('(')} className={styles.func}>(</button>
              <button onClick={() => handleInput(')')} className={styles.func}>)</button>
              <button onClick={() => handleInput('7')} className={getBtnStyle(styles.num, '7')}>7</button>
              <button onClick={() => handleInput('8')} className={getBtnStyle(styles.num, '8')}>8</button>
              <button onClick={() => handleInput('9')} className={getBtnStyle(styles.num, '9')}>9</button>
            
              <button onClick={handleBackspace} className={getBtnStyle(styles.del, 'DEL')}>DEL</button>
              <button onClick={() => handleInput('/')} className={getBtnStyle(styles.op, '/')}>÷</button>
              <button onClick={() => handleInput('4')} className={getBtnStyle(styles.num, '4')}>4</button>
              <button onClick={() => handleInput('5')} className={getBtnStyle(styles.num, '5')}>5</button>
              <button onClick={() => handleInput('6')} className={getBtnStyle(styles.num, '6')}>6</button>
            
              <button onClick={() => handleInput('*')} className={getBtnStyle(styles.op, '*')}>×</button>
              <button onClick={() => handleInput('-')} className={getBtnStyle(styles.op, '-')}>-</button>
              <button onClick={() => handleInput('1')} className={getBtnStyle(styles.num, '1')}>1</button>
              <button onClick={() => handleInput('2')} className={getBtnStyle(styles.num, '2')}>2</button>
              <button onClick={() => handleInput('3')} className={getBtnStyle(styles.num, '3')}>3</button>
            
              <button onClick={() => handleInput('+')} className={getBtnStyle(styles.op, '+')}>+</button>
              <Tooltip text="Scientific Notation (e.g., 5e6)">
                  <button onClick={() => handleInput('e')} className={getBtnStyle(styles.func, 'e')}>EXP</button>
              </Tooltip>
              <button onClick={() => handleInput('0')} className={getBtnStyle(styles.num, '0')}>0</button>
              <button onClick={() => handleInput('.')} className={getBtnStyle(styles.num, '.')}>.</button>
              <Tooltip text="Insert previous answer">
                  <button onClick={() => handleInput('Ans')} className={`${styles.func} font-bold text-sky-700`}>Ans</button>
              </Tooltip>
            </div>
            
            <button onClick={handleCalculate} className={`${getBtnStyle(styles.action, '=')} w-full mt-2 text-xl shadow-lg`}>=</button>
            
            {/* Quick Constants */}
            <div className="mt-4 pt-4 border-t border-slate-300 dark:border-slate-600">
              <div className="flex justify-between items-center mb-2">
                  <p className="text-xs font-bold text-slate-500 dark:text-slate-400 uppercase tracking-wider">Physics Constants</p>
                  <button
                      onClick={() => setIsAddMode(!isAddMode)}
                      className="text-xs font-bold text-sky-600 hover:underline flex items-center gap-1"
                  >
                      {isAddMode ? 'Cancel' : '+ Add Custom'}
                  </button>
              </div>
            
              {isAddMode && (
                  <div className="mb-3 p-2 bg-white dark:bg-slate-800 rounded border border-sky-200 dark:border-sky-800 animate-fade-in flex gap-2 items-center">
                      <input type="text" placeholder="Name" className="w-1/3 p-1 text-sm border rounded dark:bg-slate-700 dark:border-slate-600" value={newConstName} onChange={(e) => setNewConstName(e.target.value)} />
                      <input type="text" placeholder="Value" className="w-1/3 p-1 text-sm border rounded dark:bg-slate-700 dark:border-slate-600" value={newConstVal} onChange={(e) => setNewConstVal(e.target.value)} />
                      <button onClick={handleAddConstant} className="flex-1 p-1 bg-sky-600 text-white text-xs font-bold rounded hover:bg-sky-700">Save</button>
                  </div>
              )}
            
              <div className="flex flex-wrap gap-2 justify-center">
                  <Tooltip text="Pi (approx. 3.14159)"><button onClick={() => insertConstant('3.14159265', 'π')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">π</button></Tooltip>
                  <Tooltip text="Euler's Number (approx. 2.71828)"><button onClick={() => insertConstant('2.71828182', 'e')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">e</button></Tooltip>
                  <Tooltip text="Curie (3.7e10 Bq)"><button onClick={() => insertConstant('3.7e10', 'Ci')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">Ci</button></Tooltip>
                  <Tooltip text="Avogadro's Number (6.022e23)"><button onClick={() => insertConstant('6.022e23', 'Na')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">Nₐ</button></Tooltip>
                  <Tooltip text="Elementary Charge (1.602e-19 C)"><button onClick={() => insertConstant('1.60217663e-19', 'e (charge)')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">qₑ</button></Tooltip>
                  <Tooltip text="Planck's Constant (6.626e-34 J⋅s)"><button onClick={() => insertConstant('6.62607015e-34', 'h')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">h</button></Tooltip>
                  <Tooltip text="Atomic Mass Unit (1.66e-27 kg)"><button onClick={() => insertConstant('1.66053906e-27', 'u')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">u</button></Tooltip>
                  <Tooltip text="Roentgen to C/kg (2.58e-4)"><button onClick={() => insertConstant('2.58e-4', 'R -> C/kg')} className="px-3 py-1.5 text-xs bg-slate-200 dark:bg-slate-700 font-mono rounded hover:bg-slate-300 dark:hover:bg-slate-600 transition">R</button></Tooltip>
            
                  {customConstants.map((c, idx) => (
                      <Tooltip key={idx} text={`Value: ${c.value} (Right-click to delete)`}>
                          <button
                              onClick={() => insertConstant(c.value, c.name)}
                              onContextMenu={(e) => { e.preventDefault(); handleDeleteConstant(idx, c.name); }}
                              className="px-3 py-1.5 text-xs bg-sky-100 dark:bg-sky-900 font-mono font-bold text-sky-800 dark:text-sky-200 border border-sky-300 dark:border-sky-700 rounded hover:bg-sky-200 dark:hover:bg-sky-800 transition"
                          >
                              {c.name}
                          </button>
                      </Tooltip>
                  ))}
              </div>
            </div>
            </div>
            );
            };
            
            /**
            * @description React component that serves as a static page for external links and references.
            * This component provides a curated list of authoritative resources relevant to the application's
            * domain, such as health physics, radiation safety, and nuclear data.
            *
            * It is a pure presentation component that renders a pre-defined array of links,
            * categorized for easy navigation. The links are grouped into sections for:
            * 1.  **Regulatory & Guidance:** Official documents from government agencies like the NRC and DOT.
            * 2.  **Data & Tools:** Databases and software from sources like NNDC and EPA.
            * 3.  **Professional Organizations:** Websites for key professional societies and international bodies.
            *
            * This component is intended to provide users with quick access to the foundational
            * knowledge and external data sources that underpin the calculations and information in the app.
            */
            
            const ReferencesPage = ({ onNavClick, previousView }) => {
            const referenceLinks = [
            {
            category: 'Regulatory & Guidance',
            items: [
              { title: '10 CFR Part 20', url: 'https://www.nrc.gov/reading-rm/doc-collections/cfr/part020/', description: 'Standards for Protection Against Radiation (US NRC).' },
              { title: '49 CFR Part 173', url: 'https://www.ecfr.gov/current/title-49/subtitle-B/chapter-I/subchapter-C/part-173', description: 'DOT Regulations for shipping hazardous materials (Class 7).' },
              { title: 'NUREG-1556 Series', url: 'https://www.nrc.gov/reading-rm/doc-collections/nuregs/staff/sr1556/index.html', description: 'Consolidated Guidance About Materials Licenses.' },
              { title: 'MARSSIM', url: 'https://www.nrc.gov/reading-rm/doc-collections/nuregs/staff/sr1575/index.html', description: 'Multi-Agency Radiation Survey and Site Investigation Manual.' },
            ]
            },
            {
            category: 'Data & Tools',
            items: [
              { title: 'NNDC NuDat 3', url: 'https://www.nndc.bnl.gov/nudat3/', description: 'Authoritative nuclear structure and decay data.' },
              { title: 'NIST XCOM', url: 'https://physics.nist.gov/PhysRefData/Xcom/html/xcom1.html', description: 'Photon Cross Sections Database (Attenuation Coefficients).' },
              { title: 'Rad Pro Calculator', url: 'http://www.radprocalculator.com/', description: 'Comprehensive online health physics calculations.' },
              { title: 'EPA Radiation', url: 'https://www.epa.gov/radiation', description: 'US EPA radiation protection information and resources.' },
              { title: 'Plexus-NSD', url: 'http://www.iem-inc.com/information/tools/gamma-ray-dose-constants', description: 'Source for Specific Gamma Ray Constants.' },
              { title: 'REMM', url: 'https://remm.hhs.gov/', description: 'Radiation Emergency Medical Management (HHS).' },
            ]
            },
            {
            category: 'Professional Organizations',
            items: [
              { title: 'Health Physics Society (HPS)', url: 'https://hps.org/', description: 'Scientific organization of radiation safety professionals.' },
              { title: 'AAPM', url: 'https://www.aapm.org/', description: 'American Association of Physicists in Medicine.' },
              { title: 'IAEA', url: 'https://www.iaea.org/', description: 'International Atomic Energy Agency.' },
            ]
            }
            ];
            
            // Helper to determine button text
            // If previousView is null, undefined, or 'home', label it "Back Home". Otherwise just "Back".
            const backLabel = (!previousView || previousView === 'home') ? 'Back Home' : 'Back';
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-4xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
            
              <div className="flex justify-between items-center mb-6 pb-4 border-b border-slate-200 dark:border-slate-700">
                  <h2 className="text-xl font-bold text-slate-800 dark:text-white">Links & References</h2>
                  <button
                      onClick={() => onNavClick(previousView || 'home')}
                      className="px-4 py-2 bg-slate-100 dark:bg-slate-700 text-slate-600 dark:text-slate-300 rounded-lg hover:bg-slate-200 dark:hover:bg-slate-600 transition flex items-center gap-2 text-sm font-semibold"
                  >
                      <Icon path={ICONS.home} className="w-4 h-4" />
                      {backLabel}
                  </button>
              </div>
              <div className="space-y-6">
                  {referenceLinks.map(section => (
                      <div key={section.category}>
                          <h3 className="text-lg font-semibold text-sky-600 dark:text-sky-400 border-b border-slate-300 dark:border-slate-600 pb-2 mb-3">{section.category}</h3>
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                              {section.items.map(item => (
                                  <a href={item.url} target="_blank" rel="noopener noreferrer" key={item.title} className="block p-4 bg-slate-50 dark:bg-slate-900/50 rounded-lg border border-slate-200 dark:border-slate-700 hover:border-sky-400 dark:hover:border-sky-500 hover:shadow-md transition-all group">
                                      <div className="flex justify-between items-start">
                                          <p className="font-bold text-slate-800 dark:text-slate-100 group-hover:text-sky-600 dark:group-hover:text-sky-400 transition-colors">{item.title}</p>
                                          <span className="text-slate-300 group-hover:text-sky-400">↗</span>
                                      </div>
                                      <p className="text-sm text-slate-500 dark:text-slate-400 mt-1">{item.description}</p>
                                  </a>
                              ))}
                          </div>
                      </div>
                  ))}
              </div>
            </div>
            </div>
            );
            };
            
            /**
            * @description Displays information about a single radionuclide.
            */
            const NuclideCard = ({ nuclide, radionuclides, isCompact = false, onNuclideClick, onDecaySeriesClick, displayHalfLifeUnit, favorites, toggleFavorite, onSendToCalculator, onAddToCompare, showBackButton, onBackClick }) => {
            
            // ADDED: Get the global settings context
            const { settings } = React.useContext(SettingsContext);
            
            const getSourceLink = (sourceKey) => {
            const source = sources[sourceKey];
            return source ? <a href={source.url} target="_blank" rel="noopener noreferrer" className="text-sky-500 hover:underline" title={source.name}>[{Object.keys(sources).indexOf(sourceKey) + 1}]</a> : '';
            };
            
            // UPDATED: This component is now aware of the unit system
            const DataPoint = ({ label, value, unit, sourceKey, iconPath, iconSymbol, conversionType }) => {
            let displayValue = value;
            let displayUnit = unit;
            
            if (conversionType && !isNaN(parseFloat(value))) {
            const formatted = formatWithUnitSystem(parseFloat(value), conversionType, settings);
            displayValue = formatted.value;
            displayUnit = formatted.unit;
            } else if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
            displayValue = 'N/A';
            }
            
            const shouldAppendUnit = displayUnit && typeof displayValue === 'string' && displayValue !== 'N/A' && displayValue.toLowerCase() !== 'none' && !displayValue.toLowerCase().includes(displayUnit.toLowerCase());
            
            return (
            <div className="flex items-start py-2">
              {iconPath && <Icon path={iconPath} className="w-5 h-5 text-sky-500 mr-3 flex-shrink-0 mt-1" />}
              {iconSymbol && <span className="text-2xl font-serif text-sky-500 mr-3 -mt-1 w-5 text-center">{iconSymbol}</span>}
              {!iconPath && !iconSymbol && <div className="w-5 mr-3 flex-shrink-0"></div>}
              <div>
                  <p className="text-sm font-medium text-slate-500 dark:text-slate-400">{label}</p>
                  <p className="text-base font-semibold text-slate-800 dark:text-slate-100 flex items-center flex-wrap">
                      {displayValue}
                      {shouldAppendUnit ? <span className="ml-1">{displayUnit}</span> : <span className="ml-1">{displayUnit && React.isValidElement(displayValue) === false ? displayUnit.replace(value, '') : displayUnit}</span>}
                      {sourceKey && <sup className="ml-1"> {getSourceLink(sourceKey)}</sup>}
                  </p>
              </div>
            </div>
            );
            };
            
            // Helper to ensure safe emission type display
            const getEmissionTypes = () => {
            if (Array.isArray(nuclide.emissionType)) return nuclide.emissionType;
            if (typeof nuclide.emissionType === 'string') return [nuclide.emissionType];
            return [];
            };
            
            if (isCompact) {
            const styles = CATEGORY_STYLES[nuclide.category] || CATEGORY_STYLES['default'];
            const hlSeconds = parseHalfLifeToSeconds(nuclide.halfLife);
            const hlCategory = getHalfLifeCategory(hlSeconds);
            // FIX: Ensure best unit is used if not provided
            const hlUnit = displayHalfLifeUnit || getBestHalfLifeUnit(hlSeconds);
            
            return (
            <div
              onClick={() => onNuclideClick(nuclide)}
              className={`flex flex-col justify-between p-4 h-full bg-white dark:bg-slate-800 rounded-lg shadow-md hover:shadow-lg hover:ring-2 hover:ring-sky-500 cursor-pointer transition-all duration-200 border-l-4 ${styles.border} ${styles.hoverBg}`}
            >
              <div>
                  <div className="flex justify-between items-start">
                      <h3 className="font-bold text-lg text-slate-800 dark:text-white">{nuclide.name} <span className="text-slate-500 font-normal">({nuclide.symbol})</span></h3>
                      <span className={`text-xs font-bold px-2 py-0.5 rounded-full ${hlCategory.color} bg-opacity-10`}>{hlCategory.label}</span>
                  </div>
                  <div className="flex items-baseline text-sm mt-2"><Icon path={ICONS.hourglass} className="w-4 h-4 text-slate-400 mr-2"/><span className="font-medium text-slate-600 dark:text-slate-300">{formatHalfLife(nuclide.halfLife, hlUnit)}</span></div>
                  <div className="flex items-baseline text-sm mt-1"><Icon path={ICONS.radioactive} className="w-4 h-4 text-slate-400 mr-2"/><span className="text-slate-500 dark:text-slate-400">{getEmissionTypes().slice(0, 2).join(', ')}</span></div>
            
                  {nuclide.gammaConstant && (
                      <div className="flex items-baseline text-sm mt-1">
                          <span className="w-4 mr-2 text-center text-slate-400 font-serif">Γ</span>
                          <span className="font-mono text-slate-600 dark:text-slate-300">
                              {parseFloat(nuclide.gammaConstant).toFixed(2)}
                          </span>
                      </div>
                  )}
              </div>
              <div className="flex items-center gap-1 text-xs font-semibold text-slate-600 dark:text-slate-400 mt-3 pt-2 border-t border-slate-200 dark:border-slate-700">
                  <span>{nuclide.category} - {nuclide.commonality}</span>
              </div>
            </div>
            );
            }
            
            const isFavorite = favorites?.includes(nuclide.symbol);
            const hlSeconds = parseHalfLifeToSeconds(nuclide.halfLife);
            const hlCategory = getHalfLifeCategory(hlSeconds);
            const hlUnit = displayHalfLifeUnit || getBestHalfLifeUnit(hlSeconds);
            
            return (
            <div className="bg-white dark:bg-slate-800 p-6 rounded-2xl shadow-lg border border-slate-200 dark:border-slate-700 animate-fade-in">
            <div className="flex justify-between items-start">
              <div className="flex items-center gap-2">
                  <h2 className="text-2xl font-bold text-slate-800 dark:text-white">
                      <a href={`https://en.wikipedia.org/wiki/${nuclide.name.replace(/ /g, '_')}`} target="_blank" rel="noopener noreferrer" className="hover:text-sky-500 hover:underline transition-colors">
                          {nuclide.name}
                      </a> ({nuclide.symbol})
                  </h2>
                  {nuclide.commonalityReason ? (
                      <Tooltip text={nuclide.commonalityReason} widthClass="w-72">
                          <span className="flex items-center gap-1.5 text-sm font-medium text-sky-600 dark:text-sky-400 bg-sky-100 dark:bg-sky-900/50 px-3 py-1 rounded-full whitespace-nowrap cursor-help">
                              {nuclide.category} - {nuclide.commonality}
                              <Icon path={ICONS.help} className="w-4 h-4 opacity-75" />
                          </span>
                      </Tooltip>
                  ) : (
                      <span className="text-sm font-medium text-sky-600 dark:text-sky-400 bg-sky-100 dark:bg-sky-900/50 px-3 py-1 rounded-full whitespace-nowrap">
                          {nuclide.category} - {nuclide.commonality}
                      </span>
                  )}
              </div>
              <div className="flex items-center gap-2 mt-1">
                  {toggleFavorite && (
                      <button onClick={() => toggleFavorite(nuclide.symbol)} className={`p-2 rounded-full transition-colors ${isFavorite ? 'text-yellow-400 hover:text-yellow-500' : 'text-slate-300 dark:text-slate-600 hover:text-yellow-400'}`} title={isFavorite ? 'Remove from Favorites' : 'Add to Favorites'}>
                          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-8 h-8"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                      </button>
                  )}
              </div>
            </div>
            
            <div className="mt-4 grid md:grid-cols-2 lg:grid-cols-3 gap-x-6">
              <div className="divide-y divide-slate-200 dark:divide-slate-700">
                  <h3 className="text-sm font-bold uppercase text-slate-400 dark:text-slate-500 tracking-wider pb-1">Decay Properties</h3>
                  <DataPoint
                      label="Half-life"
                      value={<>{formatHalfLife(nuclide.halfLife, hlUnit)} <span className={`ml-2 text-xs font-bold px-2 py-0.5 rounded-full ${hlCategory.color} bg-opacity-10`}>{hlCategory.label}</span></>}
                      sourceKey={nuclide.sourceRef?.halfLife}
                      iconPath={ICONS.hourglass}
                  />
                  <DataPoint label="Decay Constant (λ)" value={standardizeScientificDisplay(nuclide.decayConstant)} sourceKey={nuclide.sourceRef?.decayConstant} iconSymbol="λ" />
              </div>
              <div className="divide-y divide-slate-200 dark:divide-slate-700">
                  <h3 className="text-sm font-bold uppercase text-slate-400 dark:text-slate-500 tracking-wider pb-1">Physical Properties</h3>
                  <DataPoint label="Specific Activity" value={parseSpecificActivity(nuclide.specificActivity)} sourceKey={nuclide.sourceRef?.specificActivity} iconPath={ICONS.activity} conversionType="activity" />
            {nuclide.specificActivity && (
            <div className="flex items-start py-2">
            <div className="w-5 mr-3 flex-shrink-0"></div> {/* Spacer for alignment */}
            <div>
            <p className="text-sm font-medium text-slate-500 dark:text-slate-400">Mass Equivalence</p>
            <p className="text-base font-semibold text-slate-800 dark:text-slate-100">
            {(() => {
            const sa = parseSpecificActivity(nuclide.specificActivity); // Bq/g
            if (!sa) return 'N/A';
            
            // Calculate grams per Curie (g/Ci)
            // 1 Ci = 3.7e10 Bq
            // g/Ci = 3.7e10 / SA(Bq/g)
            const gPerCi = 3.7e10 / sa;
            
            if (gPerCi < 1e-6) return `${(gPerCi * 1e9).toPrecision(3)} ng/Ci`;
            if (gPerCi < 1e-3) return `${(gPerCi * 1e6).toPrecision(3)} µg/Ci`;
            if (gPerCi < 1) return `${(gPerCi * 1000).toPrecision(3)} mg/Ci`;
            return `${gPerCi.toPrecision(3)} g/Ci`;
            })()}
            </p>
            </div>
            </div>
            )}
                  <DataPoint label="Emission Type(s)" value={getEmissionTypes().join(', ')} sourceKey={nuclide.sourceRef?.emissionType} iconPath={ICONS.radioactive} />
                  {nuclide.gammaConstant && (
                      <DataPoint label="Gamma Constant" value={parseFloat(nuclide.gammaConstant)} sourceKey={nuclide.sourceRef?.gammaConstant} conversionType="gammaConstant" />
                  )}
              </div>
              <div className="divide-y divide-slate-200 dark:divide-slate-700">
                  <h3 className="text-sm font-bold uppercase text-slate-400 dark:text-slate-500 tracking-wider pb-1">Genealogy</h3>
                  <DataPoint label="Parent" value={<ClickableNuclide text={nuclide.parent} radionuclides={radionuclides} onNuclideClick={onNuclideClick} />} sourceKey={nuclide.sourceRef?.parent} />
                  <DataPoint label="Daughter" value={<ClickableNuclide text={nuclide.daughter} radionuclides={radionuclides} onNuclideClick={onNuclideClick} />} sourceKey={nuclide.sourceRef?.daughter} />
              </div>
              {(nuclide.shipping || nuclide.dValue) && (
                  <div className="divide-y divide-slate-200 dark:divide-slate-700">
                      <h3 className="text-sm font-bold uppercase text-slate-400 dark:text-slate-500 tracking-wider pb-1">Transportation & Security</h3>
                      {nuclide.shipping && <DataPoint label="A₁ Limit" value={`${nuclide.shipping.A1 || 'N/A'}`} unit="TBq" iconPath={ICONS.transport} />}
                      {nuclide.shipping && <DataPoint label="A₂ Limit" value={`${nuclide.shipping.A2 || 'N/A'}`} unit="TBq" iconPath={ICONS.transport} />}
            
                      {nuclide.dValue && (
                          <DataPoint
                              label={
                                  <Tooltip text="Dangerous Quantity threshold (IAEA RS-G-1.9). Category 1/2 sources are >1000x and >10x D-Value respectively." widthClass="w-64">
                                      <span className="cursor-help border-b border-dotted border-slate-400 hover:border-sky-500 transition-colors">D-Value</span>
                                  </Tooltip>
                              }
                              value={`${nuclide.dValue}`}
                              unit="TBq"
                              iconPath={ICONS.transport}
                          />
                      )}
                  </div>
              )}
            </div>
            
            {nuclide.dosimetry && (
              <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
                  <h3 className="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-2">Internal Dosimetry <sup className="ml-1">{getSourceLink('10CFR20')}</sup></h3>
                  <div className="grid md:grid-cols-2 gap-x-6">
                      <div className="flex items-start py-2">
                           <Icon path={ICONS.internalDose} className="w-5 h-5 text-sky-500 mr-3 flex-shrink-0 mt-1" />
                          <div>
                              <p className="text-sm font-medium text-slate-500 dark:text-slate-400">Annual Limit on Intake (ALI)</p>
                              <ul className="text-base font-semibold text-slate-800 dark:text-slate-100 list-disc list-inside mt-1 space-y-1">
                                  {Object.entries(nuclide.dosimetry.ALI || {}).map(([key, value]) => {
                                      const formatted = formatWithUnitSystem(value, 'ali', settings);
                                      const keyDisplay = key.replace('inhalation_', 'Inh. ').replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                                      return <li key={key}>{`${keyDisplay}: ${formatted.value} ${formatted.unit}`}</li>;
                                  })}
                              </ul>
                          </div>
                      </div>
                      <div className="flex items-start py-2">
                          <div className="w-5 mr-3 flex-shrink-0"></div>
                          <div>
                               <p className="text-sm font-medium text-slate-500 dark:text-slate-400">Derived Air Concentration (DAC)</p>
                               <ul className="text-base font-semibold text-slate-800 dark:text-slate-100 list-disc list-inside mt-1 space-y-1">
                                  {Object.entries(nuclide.dosimetry.DAC || {}).map(([key, value]) => {
                                      const formatted = formatWithUnitSystem(value, 'dac', settings);
                                      const keyDisplay = key.replace('inhalation_', 'Inh. ').replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                                      return <li key={key}>{`${keyDisplay}: ${formatted.value} ${formatted.unit}`}</li>;
                                  })}
                              </ul>
                          </div>
                      </div>
                  </div>
              </div>
            )}
            
            <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
              <h3 className="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3">Principal Emissions</h3>
              <div className="space-y-4">
                  <div>
                      <p className="text-sm font-medium text-slate-500 dark:text-slate-400">From Parent ({nuclide.symbol})</p>
                      <div className="grid md:grid-cols-3 gap-4 mt-1">
                         <DataPoint label="Alpha" value={(nuclide.emissionEnergies?.alpha || []).join(', ') || 'None'} iconSymbol="α"/>
                         <DataPoint label="Beta" value={`${(nuclide.emissionEnergies?.beta || []).join(', ') || 'None'}${nuclide.avgBetaEnergy ? ` | ${nuclide.avgBetaEnergy} (avg)` : ''}`} iconSymbol="β"/>
                         <DataPoint label="Gamma" value={(nuclide.emissionEnergies?.gamma || []).join(', ') || 'None'} iconSymbol="γ"/>
                      </div>
                  </div>
                  {nuclide.daughterEmissions && (
                       <div className="animate-fade-in">
                          <p className="text-sm font-medium text-slate-500 dark:text-slate-400">
                              From Daughter (<ClickableNuclide text={nuclide.daughterEmissions.from} radionuclides={radionuclides} onNuclideClick={onNuclideClick} />)
                          </p>
                          <div className="grid md:grid-cols-3 gap-4 mt-1">
                              <DataPoint label="Alpha" value={(nuclide.daughterEmissions.alpha || []).join(', ') || 'None'} iconSymbol="α"/>
                              <DataPoint label="Beta" value={(nuclide.daughterEmissions.beta || []).join(', ') || 'None'} iconSymbol="β"/>
                              <DataPoint label="Gamma" value={(nuclide.daughterEmissions.gamma || []).join(', ') || 'None'} iconSymbol="γ"/>
                          </div>
                      </div>
                  )}
              </div>
            </div>
            
            {/* UPDATED: Quick Actions (Visual Hierarchy) */}
            <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
              <h3 className="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-3">Calculators & Tools</h3>
            
              {/* 1. Calculator Buttons */}
              <div className="flex flex-wrap gap-2 mb-4">
                  <Tooltip text="Calculate radioactive decay" widthClass="w-auto">
                      <button onClick={() => onSendToCalculator('calculator', nuclide.symbol)} className="px-3 py-2 text-sm bg-sky-50 dark:bg-sky-900/20 text-sky-700 dark:text-sky-300 border border-sky-200 dark:border-sky-800 rounded-md hover:bg-sky-100 dark:hover:bg-sky-800 transition flex items-center gap-2">
                          <Icon path={ICONS.calculator} className="w-4 h-4" /> Decay Calc
                      </button>
                  </Tooltip>
                  {nuclide.gammaConstant && (
                      <Tooltip text="Calculate dose rate at distance" widthClass="w-auto">
                           <button onClick={() => onSendToCalculator('doseRate', nuclide.symbol)} className="px-3 py-2 text-sm bg-sky-50 dark:bg-sky-900/20 text-sky-700 dark:text-sky-300 border border-sky-200 dark:border-sky-800 rounded-md hover:bg-sky-100 dark:hover:bg-sky-800 transition flex items-center gap-2">
                              <Icon path={ICONS.doseRate} className="w-4 h-4" /> Dose Rate
                          </button>
                      </Tooltip>
                  )}
                  {nuclide.gammaConstant && (
                      <Tooltip text="Calculate shielding requirements" widthClass="w-auto">
                           <button onClick={() => onSendToCalculator('shielding', nuclide.symbol)} className="px-3 py-2 text-sm bg-sky-50 dark:bg-sky-900/20 text-sky-700 dark:text-sky-300 border border-sky-200 dark:border-sky-800 rounded-md hover:bg-sky-100 dark:hover:bg-sky-800 transition flex items-center gap-2">
                              <Icon path={ICONS.shield} className="w-4 h-4" /> Shielding
                          </button>
                      </Tooltip>
                  )}
                  {nuclide.shipping && (
                      <Tooltip text="Calculate shipping labels" widthClass="w-auto">
                           <button onClick={() => onSendToCalculator('transportation', nuclide.symbol)} className="px-3 py-2 text-sm bg-sky-50 dark:bg-sky-900/20 text-sky-700 dark:text-sky-300 border border-sky-200 dark:border-sky-800 rounded-md hover:bg-sky-100 dark:hover:bg-sky-800 transition flex items-center gap-2">
                              <Icon path={ICONS.transport} className="w-4 h-4" /> Shipping
                          </button>
                      </Tooltip>
                  )}
              </div>
            
              {/* 2. Navigation Buttons */}
              <div className="flex flex-wrap gap-2 pt-2 border-t border-slate-100 dark:border-slate-800">
                  {showBackButton && (
                      <button onClick={onBackClick} className="px-3 py-2 text-sm bg-slate-100 dark:bg-slate-700 rounded-md hover:bg-slate-200 dark:hover:bg-slate-600 transition flex items-center gap-2 text-slate-600 dark:text-slate-300">
                          <Icon path={ICONS.database} className="w-4 h-4" /> Back to List
                      </button>
                  )}
                  <button onClick={() => onAddToCompare(nuclide.symbol)} className="px-3 py-2 text-sm bg-slate-100 dark:bg-slate-700 rounded-md hover:bg-slate-200 dark:hover:bg-slate-600 transition flex items-center gap-2 text-slate-600 dark:text-slate-300">
                      <Icon path={ICONS.compare} className="w-4 h-4" /> Compare
                  </button>
                  {nuclide.decaySeriesId && (
                      <button onClick={() => onDecaySeriesClick(nuclide.decaySeriesId)} className="px-3 py-2 text-sm bg-slate-100 dark:bg-slate-700 rounded-md hover:bg-slate-200 dark:hover:bg-slate-600 transition flex items-center gap-2 text-slate-600 dark:text-slate-300">
                          <Icon path={ICONS.atom} className="w-4 h-4" /> Decay Chain
                      </button>
                  )}
              </div>
            </div>
            </div>
            );
            };
            
            /**
             * @description Displays a full decay series chain.
             * @param {{seriesId: string, onBack: () => void, onNuclideClick: (nuclide: object) => void}} props - The series ID and navigation handlers.
             */
            
            const DecaySeriesViewer = ({ seriesId, onBack, onNuclideClick }) => {
                const series = decaySeriesData.find(s => s.id === seriesId);
                if (!series) return <p>Decay series not found.</p>;
            
                // --- INTERNAL COMPONENTS FOR THE DIAGRAM ---
            
                // A single nuclide in the chain
                   const NuclideNode = ({ step }) => (
                       <div className="p-3 my-2 rounded-lg bg-slate-100 dark:bg-slate-700 text-center shadow flex-shrink-0 border border-slate-200 dark:border-slate-600">
                           <span
                               className="font-bold text-lg text-sky-600 dark:text-sky-400 cursor-pointer hover:underline"
                               onClick={() => {
                                   // Check BOTH name and symbol to ensure a match
                                   const target = normalizeString(step.nuclide);
                                   const found = radionuclides.find(n => 
                                       normalizeString(n.name) === target || 
                                       normalizeString(n.symbol) === target
                                   );
                                   if (found) onNuclideClick(found);
                               }}
                           >
                               {step.nuclide}
                           </span>
                           <div className="text-xs text-slate-500 dark:text-slate-400 mt-1">{step.halfLife}</div>
                       </div>
                   );
            
                // An arrow representing a decay step
            
            const DecayArrow = ({ decayType }) => (
                    <div className="flex-shrink-0 flex items-center justify-center relative mx-2 min-w-[10rem] w-auto px-2 text-center">
            
            {/* The horizontal line of the arrow */}
            
            <div className="absolute left-0 w-full h-0.5 bg-slate-300 dark:bg-slate-600"></div>
            
            {/* Arrowhead */}
            
            <div className="absolute right-0 w-0 h-0 border-t-[5px] border-t-transparent border-b-[5px] border-b-transparent border-l-[8px] border-l-slate-400 dark:border-l-slate-500"></div>
            
            {/* Text label floating above the line */}
            
                        <div className="relative bg-white dark:bg-slate-800 px-2">
                            <span className="text-xs font-semibold text-slate-600 dark:text-slate-300 whitespace-nowrap">{decayType}</span>
                        </div>
                    </div>
                );
            
                // Recursive component that renders a chain or a sub-chain horizontally
            
                const RenderChain = ({ chain }) => (
                    <div className="flex items-center">
                        {chain.map((step, index) => (
                            <div key={step.nuclide + index} className="flex items-center">
                                <NuclideNode step={step} />
            
                                {/* If the step has branches, render them vertically stacked */}
            
                                {step.branches && (
                                    <>
                                        <DecayArrow decayType="" />
                                        <div className="flex flex-col">
                                            {step.branches.map((branch, branchIndex) => (
                                                <div key={branchIndex} className="flex items-center p-2">
                                                    <DecayArrow decayType={step.decayType.split('/')[branchIndex]?.trim() || ''} />
                                                    <RenderChain chain={branch} />
                                                </div>
                                            ))}
                                        </div>
                                    </>
                                )}
            
                                {/* If it's a linear step, render the arrow to the next step */}
            
                                {!step.branches && index < chain.length - 1 && chain[index+1].nuclide !== step.nuclide && (
                                    <DecayArrow decayType={step.decayType} />
                                )}
                            </div>
                        ))}
                    </div>
                );
            
                // --- MAIN COMPONENT RENDER ---
            
                return (
                    <div className="p-4 animate-fade-in">
                        <button onClick={onBack} className="mb-4 px-4 py-2 bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-100 rounded-lg font-semibold hover:bg-slate-300 dark:hover:bg-slate-600 transition">&larr; Back to Result</button>
                        <div className="bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                            <h2 className="text-xl font-bold text-slate-800 dark:text-white mb-4">{series.name}</h2>
                            {/* Container that allows horizontal scrolling for long chains */}
                            <div className="overflow-x-auto pb-4">
                               <div className="inline-block min-w-full p-2">
                                    <RenderChain chain={series.chain} />
                               </div>
                            </div>
                        </div>
                    </div>
                );
            };
            
            /**
            * @description A sidebar for filtering and sorting the nuclide database. It is responsive.
            * @param {{filterProps: object, isFiltersVisible: boolean, setIsFiltersVisible: (isVisible: boolean) => void, handleClearFilters: () => void}} props
            */
            
            const FilterSidebar = ({ filterProps, isFiltersVisible, setIsFiltersVisible, scrollPositionRef, handleClearFilters }) => {
            
            const {
            sortBy, setSortBy, sortOrder, setSortOrder,
            selectedCategory, setSelectedCategory, allCategories,
            selectedEmissionType, setSelectedEmissionType, allEmissionTypes,
            selectedCommonality, setSelectedCommonality, allCommonalityCategories,
            minAlphaEnergy, setMinAlphaEnergy, maxAlphaEnergy, setMaxAlphaEnergy,
            minBetaEnergy, setMinBetaEnergy, maxBetaEnergy, setMaxBetaEnergy,
            minGammaEnergy, setMinGammaEnergy, maxGammaEnergy, setMaxGammaEnergy,
            minHalfLife, setMinHalfLife, maxHalfLife, setMaxHalfLife, halfLifeFilterUnit, setHalfLifeFilterUnit
            } = filterProps;
            
            const handleClose = () => {
            setIsFiltersVisible(false);
            setTimeout(() => {
                window.scrollTo({
                    top: scrollPositionRef.current,
                    behavior: 'smooth'
                });
            }, 300);
            };
            
            return (
            <>
                <div
                    className={`fixed inset-0 bg-black/50 z-40 lg:hidden transition-opacity ${isFiltersVisible ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
                    onClick={handleClose}
                    aria-hidden="true">
                </div>
            
                <aside
                    className={`fixed top-0 left-0 w-80 h-full bg-slate-50 dark:bg-slate-900 z-50 transform transition-transform duration-300 ease-in-out lg:relative lg:w-auto lg:h-auto lg:transform-none lg:col-span-1 ${
                        isFiltersVisible ? 'translate-x-0' : '-translate-x-full'
                    }`}
                >
                    <div className="p-4 space-y-4 h-full overflow-y-auto">
                        <div className="flex justify-between items-center border-b border-slate-300 dark:border-slate-600 pb-2">
                            <h3 className="text-lg font-bold text-slate-800 dark:text-white">Filters & Sorting</h3>
                            <div className="flex items-center gap-2">
            
                                <button
                                    onClick={handleClearFilters}
                                    className="flex items-center gap-2 px-3 py-1 text-sm font-semibold text-sky-700 dark:text-sky-300 bg-slate-200 dark:bg-slate-700 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors"
                                >
                                    <Icon path={ICONS.clear} className="w-4 h-4" />
                                    Clear All
                                </button>
                                <button onClick={handleClose} className="lg:hidden p-1 rounded-full text-slate-500 hover:bg-slate-200 dark:hover:bg-slate-700">
                                    <Icon path={ICONS.clear} className="w-6 h-6" />
                                </button>
                            </div>
                        </div>
            
                        {/* Sorting controls */}
            
                        <div>
                            <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Sort by</label>
                            <select value={sortBy} onChange={e => setSortBy(e.target.value)} className="mt-1 w-full p-2 bg-white dark:bg-slate-700 border-slate-300 dark:border-slate-600 rounded-md">
                                <option value="name">Name</option>
                                <option value="halfLife">Half-life</option>
                                <option value="alphaEnergy">Alpha Energy</option>
                                <option value="betaEnergy">Beta Energy</option>
                                <option value="gammaEnergy">Gamma Energy</option>
                            </select>
                            <select value={sortOrder} onChange={e => setSortOrder(e.target.value)} className="mt-1 w-full p-2 bg-white dark:bg-slate-700 border-slate-300 dark:border-slate-600 rounded-md">
                                <option value="asc">Ascending</option>
                                <option value="desc">Descending</option>
                            </select>
                        </div>
            
                        {/* Filtering controls */}
            
                        <div><label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Category</label><select value={selectedCategory} onChange={e => setSelectedCategory(e.target.value)} className="mt-1 w-full p-2 bg-white dark:bg-slate-700 border-slate-300 dark:border-slate-600 rounded-md">{allCategories.map(c => <option key={c} value={c}>{c}</option>)}</select></div>
                        <div><label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Emission Type</label><select value={selectedEmissionType} onChange={e => setSelectedEmissionType(e.target.value)} className="mt-1 w-full p-2 bg-white dark:bg-slate-700 border-slate-300 dark:border-slate-600 rounded-md">{allEmissionTypes.map(c => <option key={c} value={c}>{c}</option>)}</select></div>
                        <div><label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Commonality</label><select value={selectedCommonality} onChange={e => setSelectedCommonality(e.target.value)} className="mt-1 w-full p-2 bg-white dark:bg-slate-700 border-slate-300 dark:border-slate-600 rounded-md">{allCommonalityCategories.map(c => <option key={c} value={c}>{c}</option>)}</select></div>
            
                        {/* Half-life range filter */}
            
                        <div>
                            <h4 className="text-md font-semibold text-slate-700 dark:text-slate-300 mt-4">Half-life</h4>
                            <div className="flex gap-2 mt-2">
                                <input type="number" placeholder="Min" value={minHalfLife} onChange={e => setMinHalfLife(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" />
                                <input type="number" placeholder="Max" value={maxHalfLife} onChange={e => setMaxHalfLife(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" />
                            </div>
                            <select value={halfLifeFilterUnit} onChange={e => setHalfLifeFilterUnit(e.target.value)} className="mt-1 w-full p-2 bg-white dark:bg-slate-700 border-slate-300 dark:border-slate-600 rounded-md">
                                <option value="seconds">Seconds</option>
                                <option value="minutes">Minutes</option>
                                <option value="hours">Hours</option>
                                <option value="days">Days</option>
                                <option value="years">Years</option>
                            </select>
                        </div>
            
                        {/* Energy range filters */}
            
                        <div>
                            <h4 className="text-md font-semibold text-slate-700 dark:text-slate-300 mt-4">Energy (MeV)</h4>
                            <div className="space-y-2 mt-2">
                                <label className="text-sm">Alpha</label><div className="flex gap-2"><input type="number" placeholder="Min" value={minAlphaEnergy} onChange={e => setMinAlphaEnergy(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" /><input type="number" placeholder="Max" value={maxAlphaEnergy} onChange={e => setMaxAlphaEnergy(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" /></div>
                                <label className="text-sm">Beta</label><div className="flex gap-2"><input type="number" placeholder="Min" value={minBetaEnergy} onChange={e => setMinBetaEnergy(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" /><input type="number" placeholder="Max" value={maxBetaEnergy} onChange={e => setMaxBetaEnergy(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" /></div>
                                <label className="text-sm">Gamma</label><div className="flex gap-2"><input type="number" placeholder="Min" value={minGammaEnergy} onChange={e => setMinGammaEnergy(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" /><input type="number" placeholder="Max" value={maxGammaEnergy} onChange={e => setMaxGammaEnergy(e.target.value)} className="w-full p-1 rounded-md text-sm bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600" /></div>
                            </div>
                        </div>
                    </div>
                </aside>
            </>
            );
            };
            
            /**
            * @description The main view for Browse the entire database with filters.
            * @param {object} props - Component props.
            */
            
            const DatabaseView = ({ filteredList, filterProps, onNuclideClick, isFiltersVisible, setIsFiltersVisible, scrollPositionRef, handleClearFilters }) => {
            const { selectedCategory, setSelectedCategory } = filterProps;
            
            // Export Function
            const handleExport = () => {
            if (!filteredList || filteredList.length === 0) return;
            
            const headers = ['Name', 'Symbol', 'Category', 'Half-Life', 'Decay Constant', 'Specific Activity', 'Gamma Constant', 'Emissions'];
            const csvRows = [headers.join(',')];
            
            filteredList.forEach(n => {
            // sanitize text to prevent CSV breakages
            const name = `"${n.name}"`;
            const emissions = `"${(n.emissionType || []).join('; ')}"`;
            const row = [
              name,
              n.symbol,
              n.category,
              n.halfLife,
              n.decayConstant,
              n.specificActivity || 'N/A',
              n.gammaConstant || 'N/A',
              emissions
            ];
            csvRows.push(row.join(','));
            });
            
            const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'nuclide_database_export.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            };
            
            return (
            <div className="relative">
            <div className="px-4 pt-4 lg:hidden">
               <button
                   onClick={() => {
                       scrollPositionRef.current = window.scrollY;
                       window.scrollTo({ top: 0, behavior: 'smooth' });
                       setIsFiltersVisible(true);
                   }}
                   className="w-full flex items-center justify-center gap-2 p-3 text-sm font-semibold bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 rounded-lg text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-700"
               >
                   <Icon path={ICONS.filter} className="w-5 h-5" /> Filters & Sorting
               </button>
            </div>
            
            <div className="grid lg:grid-cols-4 gap-4 p-4">
            
               <FilterSidebar
                   filterProps={filterProps}
                   isFiltersVisible={isFiltersVisible}
                   setIsFiltersVisible={setIsFiltersVisible}
                   scrollPositionRef={scrollPositionRef}
                   handleClearFilters={handleClearFilters}
               />
            
               <div className="col-span-4 lg:col-span-3 bg-slate-100 dark:bg-slate-800/50 rounded-lg p-4 h-[calc(100vh-350px)] md:h-[calc(100vh-320px)] lg:h-auto overflow-y-auto">
            
                   <div className="flex flex-wrap justify-between items-center gap-4 mb-4">
                       <div className="flex items-center gap-3">
                           <p className="text-sm font-bold text-slate-700 dark:text-slate-300 flex-shrink-0">
                               {filteredList.length} Results
                           </p>
                           {filteredList.length > 0 && (
                               <button onClick={handleExport} className="text-xs text-sky-600 dark:text-sky-400 hover:underline flex items-center gap-1">
                                   <Icon path={ICONS.database} className="w-3 h-3" /> Export CSV
                               </button>
                           )}
                       </div>
            
                       <div className="flex flex-wrap items-center gap-x-3 gap-y-2 text-xs">
                           {Object.entries(CATEGORY_STYLES).filter(([key]) => key !== 'default').map(([category, styles]) => {
                               const bgColor = styles.border.replace('border-l-', 'bg-');
                               const isActive = selectedCategory === category;
                               return (
                                    <Tooltip key={category} text={CATEGORY_DESCRIPTIONS[category] || ''} widthClass="w-64">
                                       <button
                                           onClick={() => setSelectedCategory(prev => prev === category ? 'All' : category)}
                                           className={`flex items-center gap-1.5 px-2 py-1 rounded-full transition-all duration-200 ${isActive ? 'ring-2 ring-offset-2 ring-offset-slate-100 dark:ring-offset-slate-800 ring-sky-500 bg-white dark:bg-slate-700' : 'bg-white/50 dark:bg-slate-800/50 hover:bg-white dark:hover:bg-slate-700'}`}
                                       >
                                           <div className={`w-3 h-3 rounded-full ${bgColor}`}></div>
                                           <span className="text-slate-600 dark:text-slate-300">{category.replace('/', '/ ')}</span>
                                       </button>
                                    </Tooltip>
                               );
                           })}
            
                           <button
                               onClick={() => setSelectedCategory('All')}
                               className={`px-2 py-1 rounded-full transition-all duration-200 text-slate-600 dark:text-slate-300 ${selectedCategory === 'All' ? 'ring-2 ring-offset-2 ring-offset-slate-100 dark:ring-offset-slate-800 ring-slate-500 bg-white dark:bg-slate-700' : 'bg-white/50 dark:bg-slate-800/50 hover:bg-white dark:hover:bg-slate-700'}`}
                           >
                               Show All
                           </button>
                       </div>
                   </div>
            
                   <div className="grid sm:grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-4">
                       {filteredList.length > 0 ? (
                           filteredList.map(n => <NuclideCard key={n.symbol} nuclide={n} isCompact={true} onNuclideClick={onNuclideClick} />)
                       ) : (
                           <div className="col-span-full text-center py-16 px-4">
                               <Icon path={ICONS.search} className="w-12 h-12 text-slate-400 dark:text-slate-500 mx-auto" />
                               <h3 className="mt-4 text-lg font-semibold text-slate-600 dark:text-slate-300">No Results Found</h3>
                               <p className="mt-1 text-sm text-slate-500 dark:text-slate-400">Try adjusting your filter criteria.</p>
                               <button
                                   onClick={handleClearFilters}
                                   className="mt-4 px-4 py-2 bg-sky-600 text-white text-sm font-semibold rounded-lg hover:bg-sky-700 transition"
                               >
                                   Clear All Filters
                               </button>
                           </div>
                       )}
                   </div>
               </div>
            </div>
            </div>
            );
            };
            
            /**
             * @description A component that provides a user interface for converting between
             * various radiological and physical units, such as activity, dose, and energy.
             */
            
            const UnitConverter = () => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            // --- 1. DEFINITIONS (Unchanged) ---
            const CATEGORIES = {
            'Activity': { base: 'Bq', units: { 'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'TBq': 1e12, 'Ci': 3.7e10, 'mCi': 3.7e7, 'µCi': 37000, 'nCi': 37, 'pCi': 0.037, 'dpm': 1/60, 'dps': 1 } },
            'Dose Equivalent': { base: 'Sv', units: { 'Sv': 1, 'mSv': 1e-3, 'µSv': 1e-6, 'rem': 0.01, 'mrem': 1e-5, 'µrem': 1e-8 } },
            'Absorbed Dose': { base: 'Gy', units: { 'Gy': 1, 'mGy': 1e-3, 'µGy': 1e-6, 'rad': 0.01, 'mrad': 1e-5 } },
            'Exposure': { base: 'C/kg', units: { 'C/kg': 1, 'R': 2.58e-4, 'mR': 2.58e-7, 'µR': 2.58e-10 } },
            'Contamination': { base: 'Bq/cm²', units: { 'Bq/cm²': 1, 'kBq/m²': 0.1, 'dpm/100cm²': 1/6000, 'µCi/cm²': 37000, 'µCi/m²': 3.7, 'pCi/100cm²': 0.037/100 } },
            'Length': { base: 'm', units: { 'm': 1, 'cm': 0.01, 'mm': 0.001, 'µm': 1e-6, 'in': 0.0254, 'ft': 0.3048, 'yd': 0.9144, 'mi': 1609.34 } },
            'Mass': { base: 'g', units: { 'g': 1, 'kg': 1000, 'mg': 1e-3, 'µg': 1e-6, 'lb': 453.592, 'oz': 28.3495 } },
            'Time': { base: 's', units: { 's': 1, 'min': 60, 'hr': 3600, 'day': 86400, 'yr': 31557600 } }
            };
            
            // --- 2. STATE ---
            const [category, setCategory] = React.useState('Activity');
            const [fromVal, setFromVal] = React.useState('1');
            const [fromUnit, setFromUnit] = React.useState('Ci');
            const [toUnit, setToUnit] = React.useState('GBq');
            
            // Auto-update units when category changes
            React.useEffect(() => {
            const units = Object.keys(CATEGORIES[category].units);
            if (category === 'Activity') { setFromUnit('Ci'); setToUnit('GBq'); }
            else if (category === 'Dose Equivalent') { setFromUnit('mrem'); setToUnit('µSv'); }
            else if (category === 'Contamination') { setFromUnit('dpm/100cm²'); setToUnit('Bq/cm²'); }
            else { setFromUnit(units[0]); setToUnit(units[1] || units[0]); }
            }, [category]);
            
            // --- 3. CALCULATION ---
            const result = React.useMemo(() => {
            const val = parseFloat(fromVal);
            if (isNaN(val)) return '---';
            const catData = CATEGORIES[category];
            const baseFactorFrom = catData.units[fromUnit];
            const baseFactorTo = catData.units[toUnit];
            if (!baseFactorFrom || !baseFactorTo) return '---';
            const inBase = val * baseFactorFrom;
            const final = inBase / baseFactorTo;
            if (final === 0) return '0';
            if (Math.abs(final) < 1e-3 || Math.abs(final) > 1e6) return final.toExponential(4);
            return parseFloat(final.toPrecision(6)).toString();
            }, [category, fromVal, fromUnit, toUnit]);
            
            const factorDisplay = React.useMemo(() => {
            const catData = CATEGORIES[category];
            const baseFactorFrom = catData.units[fromUnit];
            const baseFactorTo = catData.units[toUnit];
            if (!baseFactorFrom || !baseFactorTo) return null;
            const factor = baseFactorFrom / baseFactorTo;
            return `1 ${fromUnit} ≈ ${factor < 1e-3 || factor > 1e4 ? factor.toExponential(3) : parseFloat(factor.toPrecision(4))} ${toUnit}`;
            }, [category, fromUnit, toUnit]);
            
            // --- 4. HANDLERS ---
            const handleSwap = () => {
            setFromUnit(toUnit);
            setToUnit(fromUnit);
            };
            
            const handleSave = () => {
            if (result !== '---') {
            addHistory({ id: Date.now(), type: 'Conversion', icon: ICONS.refresh, inputs: `${fromVal} ${fromUnit}`, result: `${result} ${toUnit}`, view: VIEWS.CONVERTER });
            addToast("Saved to history!");
            }
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
              <div className="flex justify-between items-center mb-6">
                  <h2 className="text-xl font-bold text-slate-800 dark:text-white">Unit Converter</h2>
                  <button onClick={() => { setFromVal('1'); }} className="text-xs text-sky-600 dark:text-sky-400 hover:underline font-semibold flex items-center gap-1">
                      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-3 h-3"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                      Clear
                  </button>
              </div>
            
              {/* Category Grid (No Scrollbar) */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-2 mb-8">
                  {Object.keys(CATEGORIES).map(cat => (
                      <button
                          key={cat}
                          onClick={() => setCategory(cat)}
                          className={`px-2 py-2 rounded-lg text-xs font-bold transition-all duration-200 border
                              ${category === cat
                                  ? 'bg-sky-50 dark:bg-sky-900/30 border-sky-500 text-sky-700 dark:text-sky-300 shadow-sm ring-1 ring-sky-500'
                                  : 'bg-slate-50 dark:bg-slate-700/50 border-transparent text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-700'
                              }`}
                      >
                          {cat}
                      </button>
                  ))}
              </div>
            
              {/* Converter Core */}
              <div className="space-y-2">
            
                  {/* FROM Input Box */}
                       <div className="relative group bg-slate-50 dark:bg-slate-900/50 rounded-xl border border-slate-200 dark:border-slate-700 transition-all focus-within:ring-2 focus-within:ring-sky-500 focus-within:border-transparent">
                           <div className="px-4 pt-3 pb-1">
                               <label className="text-[10px] font-bold text-slate-400 uppercase tracking-wider block">From</label>
                               <div className="flex items-center">
                                   <input
                                       type="number"
                                       value={fromVal}
                                       onChange={e => setFromVal(e.target.value)}
                                       className="flex-1 w-0 bg-transparent text-2xl font-bold text-slate-800 dark:text-white focus:outline-none placeholder-slate-300 min-w-0" // FIX: w-0 and min-w-0 allows flex shrink
                                       placeholder="0"
                                   />
                                   <div className="ml-2 pl-2 border-l border-slate-200 dark:border-slate-600 max-w-[40%] flex-shrink-0"> {/* FIX: Constrain width */}
                                       <select
                                           value={fromUnit}
                                           onChange={e => setFromUnit(e.target.value)}
                                           className="w-full bg-transparent font-bold text-sm text-slate-600 dark:text-slate-300 focus:outline-none cursor-pointer hover:text-sky-600 truncate" // FIX: Truncate text if too long
                                       >
                                           {Object.keys(CATEGORIES[category].units).map(u => <option key={u} value={u}>{u}</option>)}
                                       </select>
                                   </div>
                               </div>
                           </div>
                       </div>
            
                  {/* Swap Button (Floating Overlay) */}
                  <div className="h-4 relative z-10 flex justify-center">
                      <button
                          onClick={handleSwap}
                          className="absolute -top-4 bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 text-sky-600 rounded-full p-1.5 shadow-sm hover:scale-110 hover:shadow-md transition-all duration-200"
                          title="Swap Units"
                      >
                          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2.5} stroke="currentColor" className="w-4 h-4">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M3 7.5L7.5 3m0 0L12 7.5M7.5 3v13.5m13.5 0L16.5 21m0 0L12 16.5m4.5 4.5V7.5" />
                          </svg>
                      </button>
                  </div>
            
                  {/* TO Input Box (Read Only Style) */}
                       <div className="relative group bg-sky-50 dark:bg-sky-900/10 rounded-xl border border-sky-100 dark:border-sky-800/50 transition-all">
                           <div className="px-4 pt-3 pb-1">
                               <div className="flex justify-between items-center">
                                   <label className="text-[10px] font-bold text-sky-600/70 dark:text-sky-400/70 uppercase tracking-wider block">To</label>
                                   <button onClick={handleSave} className="text-sky-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-4 h-4"/></button>
                               </div>
                               <div className="flex items-center">
                                   <div className="flex-1 w-0 text-2xl font-bold text-sky-700 dark:text-sky-400 truncate py-1 min-w-0"> {/* FIX: Added w-0, min-w-0 */}
                                       {result}
                                   </div>
                                   <div className="ml-2 pl-2 border-l border-sky-200 dark:border-sky-800 max-w-[40%] flex-shrink-0"> {/* FIX: Constrain width */}
                                       <select
                                           value={toUnit}
                                           onChange={e => setToUnit(e.target.value)}
                                           className="w-full bg-transparent font-bold text-sm text-sky-700 dark:text-sky-300 focus:outline-none cursor-pointer hover:text-sky-900 truncate"
                                       >
                                           {Object.keys(CATEGORIES[category].units).map(u => <option key={u} value={u}>{u}</option>)}
                                       </select>
                                   </div>
                               </div>
                           </div>
                       </div>
            
                  {/* Factor Display */}
                  <div className="px-2 flex justify-between text-[10px] text-slate-400 font-medium">
                      <span>{factorDisplay}</span>
                      <CopyButton textToCopy={result} label="Copy Result" />
                  </div>
            
              </div>
            </div>
            </div>
            );
            };
            /**
            * @description A component that displays a prominent header for the selected nuclide
            * along with the detailed context display for use in calculators. It includes a clear button.
            * @param {{nuclide: object, onClear: () => void}} props - The nuclide object and the function to clear it.
            */
            
            const CalculatorNuclideInfo = ({ nuclide, onClear }) => {
            if (!nuclide) return null; // Don't render anything if no nuclide is selected
            
            return (
            <div className="my-2 animate-fade-in">
            
                <div className="relative text-center p-3 bg-slate-50 dark:bg-slate-800/50 border-y border-slate-200 dark:border-slate-700">
                    <h3 className="text-2xl font-bold text-sky-600 dark:text-sky-400">{nuclide.name}</h3>
                    <p className="text-sm font-semibold text-slate-500 dark:text-slate-400">({nuclide.symbol})</p>
            
                    {/* The "Clear Nuclide" button */}
            
                    <button
            onClick={onClear}
            className="absolute top-1 right-1 p-2 rounded-full text-slate-400 hover:text-sky-500 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
            title="Change nuclide"
            aria-label="Clear selected nuclide"
            >
                        <Icon path={ICONS.clear} className="w-5 h-5" />
                    </button>
                </div>
            
                {/* The existing context display is now included here */}
            
                <NuclideContextDisplay nuclide={nuclide} />
            </div>
            );
            };
            
            /**
             * @description A comprehensive calculator for various radioactive decay scenarios,
             * including finding remaining/initial activity, time elapsed, and daughter product activity.
             * It also generates data for a visual decay chart.
             * @param {{radionuclides: Array<object>}} props - The full list of radionuclide data.
             */
            
            const DecayToLimitCalculator = ({ radionuclides, selectedNuclide, setSelectedNuclide, initialActivity, setInitialActivity, initialUnit, setInitialUnit, finalActivity, setFinalActivity, finalUnit, setFinalUnit, result, setResult, error, setError, activityUnits, theme }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            // Added state for chart data
            const [chartData, setChartData] = React.useState(null);
            const [useLogScale, setUseLogScale] = React.useState(false);
            
            const nuclidesWithHalfLife = React.useMemo(() => radionuclides.filter(r => r.halfLife !== 'Stable').sort((a,b) => a.name.localeCompare(b.name)), [radionuclides]);
            const activityFactorsBq = { 'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'TBq': 1e12, 'µCi': 3.7e4, 'mCi': 3.7e7, 'Ci': 3.7e10, 'dps': 1, 'dpm': 1/60 };
            
            React.useEffect(() => {
            try {
            setError('');
            setChartData(null); // Reset chart on input change
            
            if (!selectedNuclide) { setResult(null); return; }
            
            const A0 = parseFloat(initialActivity);
            const Af = parseFloat(finalActivity);
            
            if (isNaN(A0) || isNaN(Af) || A0 <= 0 || Af <= 0) {
            if (initialActivity && finalActivity) setError("Activities must be positive numbers (Target cannot be 0).");
            setResult(null); return;
            }
            
            const A0_Bq = A0 * activityFactorsBq[initialUnit];
            const Af_Bq = Af * activityFactorsBq[finalUnit];
            
            if (Af_Bq >= A0_Bq) {
              setError("Final activity must be less than initial activity.");
              setResult(null); return;
            }
            
            const T_half_seconds = parseHalfLifeToSeconds(selectedNuclide.halfLife);
            const lambda = Math.log(2) / T_half_seconds;
            
            // Prevent division by zero for stable nuclides
            if (lambda === 0 || T_half_seconds === Infinity) {
                setError("Selected nuclide is stable; it will not decay.");
                setResult(null);
                return;
            }
            
            const time_seconds = (-1 / lambda) * Math.log(Af_Bq / A0_Bq);
            
            // Prevent infinite chart rendering if math fails
            if (!isFinite(time_seconds)) {
                setError("Calculation resulted in an invalid time (possibly infinite). Check inputs.");
                setResult(null);
                return;
            }
            
            const num_half_lives = time_seconds / T_half_seconds;
            
            const bestUnit = getBestHalfLifeUnit(time_seconds);
            const unitConversions = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600 };
            const time_in_best_unit = time_seconds / unitConversions[bestUnit];
            
            setResult({
              time: time_in_best_unit.toPrecision(4),
              unit: bestUnit,
              halfLives: num_half_lives.toFixed(2)
            });
            
            // --- GENERATE CHART DATA ---
            const labels = [];
            const parentData = [];
            
            // Plot slightly past the target time (e.g., 1.2x) to show the limit crossing
            const totalTimePlot = time_in_best_unit * 1.2;
            const steps = 100;
            
            for (let i = 0; i <= steps; i++) {
              const t_plot = (totalTimePlot / steps) * i;
              const t_plot_seconds = t_plot * unitConversions[bestUnit];
            
              // Calculate activity in the User's Initial Unit for consistency
              const currentAct_Bq = A0_Bq * Math.exp(-lambda * t_plot_seconds);
              const currentAct_UserUnit = currentAct_Bq / activityFactorsBq[initialUnit];
            
              labels.push(t_plot.toFixed(2));
              parentData.push(currentAct_UserUnit);
            }
            
            if (A0_Bq / Af_Bq > 100) {
                     setUseLogScale(true);
                 } else {
                     setUseLogScale(false);
                 }
            
                 setChartData({
                     labels,
                     parentData,
                     daughterData: null,
                     timeUnit: bestUnit,
                     parentName: selectedNuclide.name
                 });
            
            } catch (e) {
            setError(e.message || "Calculation failed.");
            setResult(null);
            }
            }, [selectedNuclide, initialActivity, initialUnit, finalActivity, finalUnit]);
            
            const handleSaveToHistory = () => {
            if (result && selectedNuclide) {
            addHistory({
              id: Date.now(),
              type: 'Decay to Limit',
              icon: ICONS.stopwatch,
              inputs: `${initialActivity} ${initialUnit} ${selectedNuclide.symbol} to ${finalActivity} ${finalUnit}`,
              result: `${result.time} ${result.unit}`,
              view: VIEWS.CALCULATOR
            });
            addToast('Calculation saved to history!');
            }
            };
            
            return (
            <div className="space-y-4">
            <p className="text-sm text-slate-600 dark:text-slate-400">Calculates time required to decay to a specified activity level.</p>
            <div>
              <label className="text-sm font-medium">Radionuclide</label>
              <div className="mt-1 min-h-[42px]">
                  {selectedNuclide ?
                      <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setSelectedNuclide(null)} /> :
                      <SearchableSelect options={nuclidesWithHalfLife} onSelect={(symbol) => setSelectedNuclide(radionuclides.find(n => n.symbol === symbol))} placeholder="Search for a radionuclide..." />
                  }
              </div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                  <label className="block text-sm font-medium">Initial Activity</label>
                  <div className="flex">
                      <input type="number" value={initialActivity} onChange={e => setInitialActivity(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                      <select value={initialUnit} onChange={e => setInitialUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                  </div>
              </div>
              <div>
                  <label className="block text-sm font-medium">Final (Target) Activity</label>
                  <div className="flex">
                      <input type="number" value={finalActivity} onChange={e => setFinalActivity(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                      <select value={finalUnit} onChange={e => setFinalUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                  </div>
              </div>
            </div>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (
              <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in">
                  <div className="flex justify-between items-center">
                      <div></div>
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Time to Decay</p>
                      <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                         <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                             <Icon path={ICONS.notepad} className="w-5 h-5" />
                         </button>
                      </Tooltip>
                  </div>
                  <div className="flex items-center justify-center">
                      <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{result.time}</p>
                      <CopyButton textToCopy={result.time} />
                  </div>
                  <p className="text-md font-medium text-slate-600 dark:text-slate-300">{result.unit}</p>
                  <p className="text-xs text-slate-500 dark:text-slate-400 mt-2">({result.halfLives} half-lives)</p>
              </div>
            )}
            
            {/* NEW: Render Chart */}
            {chartData && (
              <>
                  <div className="flex justify-end mt-4">
                      <label className="flex items-center gap-2 text-sm cursor-pointer">
                          <input type="checkbox" checked={useLogScale} onChange={() => setUseLogScale(!useLogScale)} className="form-checkbox h-4 w-4 rounded text-sky-600" /> Use Logarithmic Scale
                      </label>
                  </div>
                  <DecayChart chartData={chartData} useLogScale={useLogScale} theme={theme} />
              </>
            )}
            </div>
            );
            };
            
            const getNowString = () => {
            const now = new Date();
            // Adjust to local timezone ISO string (YYYY-MM-DDTHH:mm)
            const offset = now.getTimezoneOffset() * 60000;
            const localIso = new Date(now - offset).toISOString().slice(0, 16);
            return localIso;
            };
            const DecayTools = ({ radionuclides, preselectedNuclide, theme }) => {
            const { settings } = React.useContext(SettingsContext);
            const [activeCalculator, setActiveCalculator] = React.useState(() => localStorage.getItem('decayTools_activeTab') || 'standard');
            
            const activityUnits = React.useMemo(() =>
            settings.unitSystem === 'si'
            ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq', 'dps', 'dpm']
            : ['µCi', 'mCi', 'Ci', 'dps', 'dpm'],
            [settings.unitSystem]
            );
            
            const [std_selectedNuclide, setStd_selectedNuclide] = React.useState(() => { const savedSymbol = localStorage.getItem('decayCalc_nuclideSymbol'); if (!savedSymbol) return null; return radionuclides.find(n => n.symbol === savedSymbol) || null; });
            const [std_calculationMode, setStd_calculationMode] = React.useState(() => localStorage.getItem('decayCalc_mode') || 'findRemaining');
            const [std_initialActivity, setStd_initialActivity] = React.useState(() => localStorage.getItem('decayCalc_initialActivity') || '100');
            // NEW: Unit State
            const [std_initialUnit, setStd_initialUnit] = React.useState(() => localStorage.getItem('decayCalc_initialUnit') || activityUnits[1]);
            
            const [std_initialDaughterActivity, setStd_initialDaughterActivity] = React.useState(() => localStorage.getItem('decayCalc_initialDaughterActivity') || '0');
            const [std_branchingFraction, setStd_branchingFraction] = React.useState(() => localStorage.getItem('decayCalc_branchingFraction') || '1.0');
            
            const [std_remainingActivity, setStd_remainingActivity] = React.useState(() => localStorage.getItem('decayCalc_remainingActivity') || '');
            // NEW: Unit State
            const [std_remainingUnit, setStd_remainingUnit] = React.useState(() => localStorage.getItem('decayCalc_remainingUnit') || activityUnits[1]);
            
            const [std_timeElapsed, setStd_timeElapsed] = React.useState(() => localStorage.getItem('decayCalc_timeElapsed') || '1');
            const [std_timeUnit, setStd_timeUnit] = React.useState(() => localStorage.getItem('decayCalc_timeUnit') || 'days');
            const [std_useLogScale, setStd_useLogScale] = React.useState(() => JSON.parse(localStorage.getItem('decayCalc_useLogScale')) || false);
            
            const [corr_nuclideSymbol, setCorr_nuclideSymbol] = React.useState(() => localStorage.getItem('corr_nuclideSymbol') || '');
            const [corr_originalActivity, setCorr_originalActivity] = React.useState(() => localStorage.getItem('corr_originalActivity') || '10');
            const [corr_originalActivityUnit, setCorr_originalActivityUnit] = React.useState(() => localStorage.getItem('corr_originalActivityUnit') || activityUnits[1]);
            const [corr_originalDate, setCorr_originalDate] = React.useState(() => localStorage.getItem('corr_originalDate') || getNowString());
            const [corr_targetDate, setCorr_targetDate] = React.useState(() => localStorage.getItem('corr_targetDate') || getNowString());
            
            const [dtl_selectedNuclide, setDtl_selectedNuclide] = React.useState(() => { const saved = localStorage.getItem('dtl_nuclideSymbol'); return saved ? radionuclides.find(n => n.symbol === saved) : null; });
            const [dtl_initialActivity, setDtl_initialActivity] = React.useState(() => localStorage.getItem('dtl_initialActivity') || '10');
            const [dtl_initialUnit, setDtl_initialUnit] = React.useState(() => localStorage.getItem('dtl_initialUnit') || activityUnits[1]);
            const [dtl_finalActivity, setDtl_finalActivity] = React.useState(() => localStorage.getItem('dtl_finalActivity') || '0.001');
            const [dtl_finalUnit, setDtl_finalUnit] = React.useState(() => localStorage.getItem('dtl_finalUnit') || activityUnits[1]);
            const [dtl_result, setDtl_result] = React.useState(null);
            const [dtl_error, setDtl_error] = React.useState('');
            
            // Unit safety checks
            React.useEffect(() => { if (!activityUnits.includes(std_initialUnit)) setStd_initialUnit(activityUnits[1]); }, [activityUnits, std_initialUnit]);
            React.useEffect(() => { if (!activityUnits.includes(std_remainingUnit)) setStd_remainingUnit(activityUnits[1]); }, [activityUnits, std_remainingUnit]);
            React.useEffect(() => { if (!activityUnits.includes(corr_originalActivityUnit)) setCorr_originalActivityUnit(activityUnits[1]); }, [activityUnits, corr_originalActivityUnit]);
            React.useEffect(() => { if (!activityUnits.includes(dtl_initialUnit)) setDtl_initialUnit(activityUnits[1]); }, [activityUnits, dtl_initialUnit]);
            React.useEffect(() => { if (!activityUnits.includes(dtl_finalUnit)) setDtl_finalUnit(activityUnits[1]); }, [activityUnits, dtl_finalUnit]);
            
            React.useEffect(() => { localStorage.setItem('decayTools_activeTab', activeCalculator); }, [activeCalculator]);
            React.useEffect(() => { localStorage.setItem('corr_nuclideSymbol', corr_nuclideSymbol); localStorage.setItem('corr_originalActivity', corr_originalActivity); localStorage.setItem('corr_originalActivityUnit', corr_originalActivityUnit); localStorage.setItem('corr_originalDate', corr_originalDate); localStorage.setItem('corr_targetDate', corr_targetDate); }, [corr_nuclideSymbol, corr_originalActivity, corr_originalActivityUnit, corr_originalDate, corr_targetDate]);
            React.useEffect(() => { localStorage.setItem('dtl_nuclideSymbol', dtl_selectedNuclide ? dtl_selectedNuclide.symbol : ''); localStorage.setItem('dtl_initialActivity', dtl_initialActivity); localStorage.setItem('dtl_initialUnit', dtl_initialUnit); localStorage.setItem('dtl_finalActivity', dtl_finalActivity); localStorage.setItem('dtl_finalUnit', dtl_finalUnit); }, [dtl_selectedNuclide, dtl_initialActivity, dtl_initialUnit, dtl_finalActivity, dtl_finalUnit]);
            
            // Updated Persistence for Standard Calculator
            React.useEffect(() => {
            localStorage.setItem('decayCalc_nuclideSymbol', std_selectedNuclide ? std_selectedNuclide.symbol : '');
            localStorage.setItem('decayCalc_mode', std_calculationMode);
            localStorage.setItem('decayCalc_initialActivity', std_initialActivity);
            localStorage.setItem('decayCalc_initialUnit', std_initialUnit); // Save
            localStorage.setItem('decayCalc_initialDaughterActivity', std_initialDaughterActivity);
            localStorage.setItem('decayCalc_branchingFraction', std_branchingFraction);
            localStorage.setItem('decayCalc_remainingActivity', std_remainingActivity);
            localStorage.setItem('decayCalc_remainingUnit', std_remainingUnit); // Save
            localStorage.setItem('decayCalc_timeElapsed', std_timeElapsed);
            localStorage.setItem('decayCalc_timeUnit', std_timeUnit);
            localStorage.setItem('decayCalc_useLogScale', JSON.stringify(std_useLogScale));
            }, [std_selectedNuclide, std_calculationMode, std_initialActivity, std_initialUnit, std_initialDaughterActivity, std_branchingFraction, std_remainingActivity, std_remainingUnit, std_timeElapsed, std_timeUnit, std_useLogScale]);
            
            const handleStandardClear = () => {
            setStd_selectedNuclide(null);
            setStd_calculationMode('findRemaining');
            setStd_initialActivity('100');
            setStd_initialUnit(activityUnits[1]); // Reset unit
            setStd_initialDaughterActivity('0');
            setStd_branchingFraction('1.0');
            setStd_remainingActivity('');
            setStd_remainingUnit(activityUnits[1]); // Reset unit
            setStd_timeElapsed('1');
            setStd_timeUnit('days');
            setStd_useLogScale(false);
            Object.keys(localStorage).forEach(key => {
               if (key.startsWith('decayCalc_')) {
                   localStorage.removeItem(key);
               }
            });
            };
            
            const handleCorrectionClear = () => {
            setCorr_nuclideSymbol('');
            setCorr_originalActivity('10');
            setCorr_originalActivityUnit(activityUnits[1]);
            setCorr_originalDate('2020-01-01');
            setCorr_targetDate(getNowString());
            Object.keys(localStorage).forEach(key => {
               if (key.startsWith('corr_')) {
                   localStorage.removeItem(key);
               }
            });
            };
            
            const handleDecayToLimitClear = () => {
            setDtl_selectedNuclide(null);
            setDtl_initialActivity('10');
            setDtl_initialUnit(activityUnits[1]);
            setDtl_finalActivity('0.001');
            setDtl_finalUnit(activityUnits[1]);
            setDtl_result(null);
            setDtl_error('');
            Object.keys(localStorage).forEach(key => {
               if (key.startsWith('dtl_')) {
                   localStorage.removeItem(key);
               }
            });
            };
            
            const handleClearActiveCalculator = () => {
            if (activeCalculator === 'standard') handleStandardClear();
            else if (activeCalculator === 'correction') handleCorrectionClear();
            else handleDecayToLimitClear();
            };
            
            return (
            <div className="p-4 animate-fade-in">
               <div className="max-w-lg mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                   <div className="flex justify-between items-center mb-4">
                       <h2 className="text-xl font-bold text-slate-800 dark:text-white">Decay Tools</h2>
                       <ClearButton onClick={handleClearActiveCalculator} />
                   </div>
                   <div className="grid grid-cols-3 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-6">
                       <button onClick={() => setActiveCalculator('standard')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeCalculator === 'standard' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Standard</button>
                       <button onClick={() => setActiveCalculator('correction')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeCalculator === 'correction' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Correction</button>
                       <button onClick={() => setActiveCalculator('toLimit')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeCalculator === 'toLimit' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>To Limit</button>
                   </div>
            
                   {activeCalculator === 'standard' &&
                       <StandardDecayCalculator
                           radionuclides={radionuclides}
                           preselectedNuclide={preselectedNuclide}
                           selectedNuclide={std_selectedNuclide}
                           setSelectedNuclide={setStd_selectedNuclide}
                           calculationMode={std_calculationMode}
                           setCalculationMode={setStd_calculationMode}
                           initialActivity={std_initialActivity}
                           setInitialActivity={setStd_initialActivity}
                           initialUnit={std_initialUnit}         // Pass
                           setInitialUnit={setStd_initialUnit}   // Pass
                           initialDaughterActivity={std_initialDaughterActivity}
                           setInitialDaughterActivity={setStd_initialDaughterActivity}
                           branchingFraction={std_branchingFraction}
                           setBranchingFraction={setStd_branchingFraction}
                           remainingActivity={std_remainingActivity}
                           setRemainingActivity={setStd_remainingActivity}
                           remainingUnit={std_remainingUnit}     // Pass
                           setRemainingUnit={setStd_remainingUnit} // Pass
                           timeElapsed={std_timeElapsed}
                           setTimeElapsed={setStd_timeElapsed}
                           timeUnit={std_timeUnit}
                           setTimeUnit={setStd_timeUnit}
                           useLogScale={std_useLogScale}
                           setUseLogScale={setStd_useLogScale}
                           theme={theme}
                           activityUnits={activityUnits}         // Pass
                       />
                   }
                   {activeCalculator === 'correction' && <SourceCorrectionCalculator radionuclides={radionuclides} nuclideSymbol={corr_nuclideSymbol} setNuclideSymbol={setCorr_nuclideSymbol} originalActivity={corr_originalActivity} setOriginalActivity={setCorr_originalActivity} originalActivityUnit={corr_originalActivityUnit} setOriginalActivityUnit={setCorr_originalActivityUnit} originalDate={corr_originalDate} setOriginalDate={setCorr_originalDate} targetDate={corr_targetDate} setTargetDate={setCorr_targetDate} activityUnits={activityUnits} />}
                   {activeCalculator === 'toLimit' && <DecayToLimitCalculator radionuclides={radionuclides} selectedNuclide={dtl_selectedNuclide} setSelectedNuclide={setDtl_selectedNuclide} initialActivity={dtl_initialActivity} setInitialActivity={setDtl_initialActivity} initialUnit={dtl_initialUnit} setInitialUnit={setDtl_initialUnit} finalActivity={dtl_finalActivity} setFinalActivity={setDtl_finalActivity} finalUnit={dtl_finalUnit} setFinalUnit={setDtl_finalUnit} result={dtl_result} setResult={setDtl_result} error={dtl_error} setError={setDtl_error} activityUnits={activityUnits} theme={theme} />}
               </div>
            </div>
            );
            };
            
            // This component is a source correction calculator that computes the activity of a radioactive source on a future date by applying the principle of radioactive decay. It requires the original activity, the calibration date, and the radionuclide's half-life to perform the calculation.
            
            const SourceCorrectionCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, originalActivity, setOriginalActivity, originalActivityUnit, setOriginalActivityUnit, originalDate, setOriginalDate, targetDate, setTargetDate, activityUnits }) => {
            const [result, setResult] = React.useState(null);
            const [error, setError] = React.useState('');
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const activityFactorsBq = { 'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'TBq': 1e12, 'µCi': 3.7e4, 'mCi': 3.7e7, 'Ci': 3.7e10, 'dps': 1, 'dpm': 1/60 };
            const nuclidesWithHalfLife = React.useMemo(() => radionuclides.filter(r => r.halfLife !== 'Stable').sort((a,b) => a.name.localeCompare(b.name)), [radionuclides]);
            const selectedNuclide = React.useMemo(() => radionuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, radionuclides]);
            
            React.useEffect(() => {
            if (!selectedNuclide) { setResult(null); return; }
            try {
            setError('');
            const A0 = parseFloat(originalActivity);
            if (isNaN(A0) || A0 < 0) throw new Error("Original activity must be a positive number.");
            
            const start = new Date(originalDate);
            const end = new Date(targetDate);
            
            if (isNaN(start.getTime()) || isNaN(end.getTime())) throw new Error("Please enter valid dates and times.");
            if (end < start) throw new Error("Target time cannot be before the original time.");
            
            const timeElapsed_ms = end - start;
            // Allow calculation even for 0 time elapsed
            const timeElapsed_s = timeElapsed_ms / 1000;
            
            const T_half_s = parseHalfLifeToSeconds(selectedNuclide.halfLife);
            if (T_half_s === Infinity) throw new Error("Cannot calculate decay for a stable nuclide.");
            
            const activity_Bq_0 = A0 * activityFactorsBq[originalActivityUnit];
            const activity_Bq_t = activity_Bq_0 * Math.pow(0.5, timeElapsed_s / T_half_s);
            const finalActivity = activity_Bq_t / activityFactorsBq[originalActivityUnit];
            
            // Smart formatting for time elapsed label
            let timeLabel = `${(timeElapsed_s / 86400).toFixed(2)} days`;
            if (timeElapsed_s < 86400) {
              timeLabel = `${(timeElapsed_s / 3600).toFixed(2)} hours`;
            }
            
            setResult({ currentActivity: finalActivity.toPrecision(4), timeLabel: timeLabel });
            } catch(e) {
            setError(e.message);
            setResult(null);
            }
            }, [selectedNuclide, originalActivity, originalActivityUnit, originalDate, targetDate]);
            
            const handleSaveToHistory = () => {
            if (result && selectedNuclide) {
            // Format dates for display
            const dateStr = new Date(targetDate).toLocaleString();
            addHistory({
              id: Date.now(),
              type: 'Source Correction',
              icon: ICONS.calculator,
              inputs: `${originalActivity} ${originalActivityUnit} ${selectedNuclide.symbol}`,
              result: `${result.currentActivity} ${originalActivityUnit} (${dateStr})`,
              view: VIEWS.CALCULATOR
            });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="space-y-4">
            <p className="text-sm text-slate-600 dark:text-slate-400">Calculates a source's activity at a specific date and time.</p>
            <div>
              <label className="text-sm font-medium">Radionuclide</label>
              <div className="mt-1 min-h-[42px]">
                  {selectedNuclide ? (
                      <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} />
                  ) : (
                      <SearchableSelect options={nuclidesWithHalfLife} onSelect={setNuclideSymbol} placeholder="Search for a radionuclide..."/>
                  )}
              </div>
            </div>
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                      <label className="block text-sm font-medium">Original Activity</label>
                      <div className="flex">
                          <input type="number" value={originalActivity} onChange={e => setOriginalActivity(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                          <select value={originalActivityUnit} onChange={e => setOriginalActivityUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                      </div>
                  </div>
                  <div>
                      <label className="block text-sm font-medium">Original Date & Time</label>
                      {/* CHANGED: type="datetime-local" */}
                      <input type="datetime-local" value={originalDate} onChange={e => setOriginalDate(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/>
                  </div>
              </div>
              <div>
                  <label className="block text-sm font-medium">Target Date & Time</label>
                  {/* CHANGED: type="datetime-local" */}
                  <input type="datetime-local" value={targetDate} onChange={e => setTargetDate(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/>
              </div>
            </div>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (
              <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in">
                  <div className="flex justify-between items-center">
                      <div></div>
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Corrected Activity</p>
                      <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                         <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                             <Icon path={ICONS.notepad} className="w-5 h-5" />
                         </button>
                      </Tooltip>
                  </div>
                  <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{result.currentActivity}</p>
                  <p className="text-md font-medium text-slate-600 dark:text-slate-300">{originalActivityUnit}</p>
                  <p className="text-xs text-slate-500 dark:text-slate-400 mt-2">({result.timeLabel} elapsed)</p>
              </div>
            )}
            </div>
            );
            };
            
            // This component is a versatile radioactive decay calculator that supports four different modes: calculating remaining activity, finding the time elapsed, determining the initial activity, or calculating the activity of a radioactive daughter product. It visualizes the decay curve and handles various time units and logarithmic scales.
            
            const StandardDecayCalculator = ({
                radionuclides,
                selectedNuclide,
                setSelectedNuclide,
                calculationMode,
                setCalculationMode,
                initialActivity,
                setInitialActivity,
                initialUnit,
                setInitialUnit,
                initialDaughterActivity,
                setInitialDaughterActivity,
                branchingFraction,
                setBranchingFraction,
                remainingActivity,
                setRemainingActivity,
                remainingUnit,
                setRemainingUnit,
                timeElapsed,
                setTimeElapsed,
                timeUnit,
                setTimeUnit,
                useLogScale,
                setUseLogScale,
                theme,
                activityUnits
            }) => {
                const [result, setResult] = React.useState(null);
                const [chartData, setChartData] = React.useState(null);
                const [error, setError] = React.useState('');
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();

                // --- Branching Path State ---
                const [decayPaths, setDecayPaths] = React.useState([]);
                const [selectedPathIndex, setSelectedPathIndex] = React.useState(0);

                // --- Time Mode State ---
                const [timeMode, setTimeMode] = React.useState('duration');
                const [useUTC, setUseUTC] = React.useState(false);

                // Default Dates
                const [referenceDate, setReferenceDate] = React.useState(() => {
                    const now = new Date();
                    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                    return now.toISOString().slice(0, 16);
                });

                const [targetDate, setTargetDate] = React.useState(() => {
                    const now = new Date();
                    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
                    return now.toISOString().slice(0, 16);
                });

                const MODE_REMAINING = 'findRemaining';
                const MODE_TIME = 'findTime';
                const MODE_INITIAL = 'findInitial';
                const MODE_DAUGHTER = 'findDaughterActivity';

                const unitConversions = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600 };
                const activityFactors = React.useMemo(() => ({
                    'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'TBq': 1e12,
                    'µCi': 3.7e4, 'mCi': 3.7e7, 'Ci': 3.7e10, 'dps': 1, 'dpm': 1 / 60
                }), []);

                const sortedRadionuclides = React.useMemo(() => {
                    const commonalityOrder = { 'Common': 3, 'Moderate': 2, 'Rare': 1 };
                    return [...radionuclides].filter(r => r.halfLife !== 'Stable').sort((a, b) => {
                        const orderA = commonalityOrder[a.commonality] || 0;
                        const orderB = commonalityOrder[b.commonality] || 0;
                        if (orderA !== orderB) { return orderB - orderA; }
                        return a.name.localeCompare(b.name);
                    });
                }, [radionuclides]);

                // --- Branching Path Detection ---
                React.useEffect(() => {
                    if (selectedNuclide) {
                        const dStr = selectedNuclide.daughter || '';
                        const rawFraction = selectedNuclide.branchingFraction || 1.0;
                        let newPaths = [];

                        if (dStr.includes(' or ')) {
                            const parts = dStr.split(' or ');
                            const path1Name = parts[0].split('(')[0].trim();
                            const path2Name = parts[1].split('(')[0].trim();

                            newPaths.push({ name: path1Name, fraction: rawFraction, label: parts[0].trim() });
                            
                            const remainder = rawFraction < 1.0 ? (1.0 - rawFraction) : 0;
                            newPaths.push({ name: path2Name, fraction: parseFloat(remainder.toFixed(4)), label: parts[1].trim() });
                            
                            setDecayPaths(newPaths);
                            setSelectedPathIndex(0);
                            if (calculationMode === MODE_DAUGHTER) setBranchingFraction(newPaths[0].fraction.toString());
                        } 
                        else {
                            const cleanName = dStr.split('(')[0].trim();
                            newPaths.push({ name: cleanName, fraction: rawFraction, label: dStr });
                            setDecayPaths(newPaths);
                            setSelectedPathIndex(0);
                            
                            if (calculationMode === MODE_DAUGHTER) {
                                if (selectedNuclide.symbol === 'Mo-99' && !selectedNuclide.branchingFraction) {
                                    setBranchingFraction('0.875');
                                } else {
                                    setBranchingFraction(rawFraction.toString());
                                }
                            }
                        }
                    } else {
                        setDecayPaths([]);
                    }
                }, [selectedNuclide, calculationMode, setBranchingFraction]);

                const handlePathChange = (e) => {
                    const idx = parseInt(e.target.value);
                    setSelectedPathIndex(idx);
                    if (decayPaths[idx]) {
                        setBranchingFraction(decayPaths[idx].fraction.toString());
                    }
                };

                const renderUnitField = (label, value, setter, unitVal, unitSetter, isValueEnabled) => (
                    <div>
                        <label className={`block text-sm font-medium ${isValueEnabled ? 'text-slate-700 dark:text-slate-300' : 'text-slate-400 dark:text-slate-500'}`}>
                            {label}
                        </label>
                        <div className="flex gap-2 mt-1">
                            <input
                                type="number"
                                value={value}
                                onChange={e => setter(e.target.value)}
                                disabled={!isValueEnabled}
                                className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 disabled:bg-slate-200 dark:disabled:bg-slate-800 disabled:cursor-not-allowed"
                            />
                            <select
                                value={unitVal}
                                onChange={e => unitSetter(e.target.value)}
                                className="p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-600"
                            >
                                {activityUnits.map(u => <option key={u} value={u}>{u}</option>)}
                            </select>
                        </div>
                    </div>
                );

                const handleCalculate = React.useCallback(() => {
                    if (!selectedNuclide) return;

                    try {
                        setError('');
                        const T_half_seconds = parseHalfLifeToSeconds(selectedNuclide.halfLife);
                        const lambda = Math.log(2) / T_half_seconds;

                        const A0_Bq = parseFloat(initialActivity) * activityFactors[initialUnit];
                        const At_Bq = parseFloat(remainingActivity) * activityFactors[remainingUnit];
                        const br = parseFloat(branchingFraction) || 1.0;

                        let t_seconds = 0;

                        if (calculationMode === MODE_TIME) {
                            // Calculating time...
                        } else if (timeMode === 'date') {
                            const startStr = useUTC ? referenceDate + 'Z' : referenceDate;
                            const endStr = useUTC ? targetDate + 'Z' : targetDate;
                            const start = new Date(startStr);
                            const end = new Date(endStr);

                            if (isNaN(start.getTime()) || isNaN(end.getTime())) { setError("Please enter valid dates."); setResult(null); return; }
                            if (end < start) { setError("Target Date cannot be before Reference Date."); setResult(null); return; }

                            t_seconds = (end - start) / 1000;
                        } else {
                            const t_input = parseFloat(timeElapsed);
                            if (isNaN(t_input)) return; 
                            t_seconds = t_input * unitConversions[timeUnit];
                        }

                        let timeForChart_seconds = t_seconds;
                        let displayLambda = lambda;
                        let lambdaUnit = 's⁻¹';
                        let plotA0_Bq = A0_Bq;

                        if (lambda < 1e-6) { displayLambda = lambda * 31557600; lambdaUnit = 'yr⁻¹'; }
                        else if (lambda < 1e-4) { displayLambda = lambda * 86400; lambdaUnit = 'd⁻¹'; }
                        else if (lambda < 0.1) { displayLambda = lambda * 3600; lambdaUnit = 'hr⁻¹'; }

                        if (calculationMode === MODE_REMAINING) {
                            if (isNaN(A0_Bq)) throw new Error('Initial activity must be a valid number.');
                            const finalActivity_Bq = A0_Bq * Math.exp(-lambda * t_seconds);
                            setResult({
                                label: 'Remaining Activity',
                                value: (finalActivity_Bq / activityFactors[remainingUnit]).toPrecision(4),
                                unit: remainingUnit,
                                lambdaVal: displayLambda.toPrecision(4),
                                lambdaUnit: lambdaUnit
                            });
                        } else if (calculationMode === MODE_TIME) {
                            if (isNaN(A0_Bq) || isNaN(At_Bq) || A0_Bq <= 0 || At_Bq < 0 || At_Bq > A0_Bq) throw new Error('Activities must be valid, with Remaining < Initial.');
                            const timeInSeconds = (-1 / lambda) * Math.log(At_Bq / A0_Bq);
                            const bestUnit = getBestHalfLifeUnit(timeInSeconds);
                            setResult({
                                label: 'Time Elapsed',
                                value: (timeInSeconds / unitConversions[bestUnit]).toPrecision(4),
                                unit: bestUnit,
                                lambdaVal: displayLambda.toPrecision(4),
                                lambdaUnit: lambdaUnit
                            });
                            timeForChart_seconds = timeInSeconds;
                        } else if (calculationMode === MODE_INITIAL) {
                            if (isNaN(At_Bq)) throw new Error('Remaining activity must be a valid number.');
                            const initial_Bq = At_Bq / Math.exp(-lambda * t_seconds);
                            plotA0_Bq = initial_Bq;
                            setResult({
                                label: 'Initial Activity',
                                value: (initial_Bq / activityFactors[initialUnit]).toPrecision(4),
                                unit: initialUnit,
                                lambdaVal: displayLambda.toPrecision(4),
                                lambdaUnit: lambdaUnit
                            });
                        } else if (calculationMode === MODE_DAUGHTER) {
                            if (selectedNuclide.daughter.includes('/') && decayPaths.length < 2) throw new Error('Complex branching detected. Use Series Decay calculator.');
                            
                            const activePath = decayPaths[selectedPathIndex];
                            const daughterName = activePath ? activePath.name : selectedNuclide.daughter.split('(')[0].trim();
                            const daughter = radionuclides.find(n => normalizeString(n.name) === normalizeString(daughterName));
                            if (!daughter) throw new Error('Daughter nuclide data not found.');

                            const T_half_daughter_seconds = parseHalfLifeToSeconds(daughter.halfLife);
                            const lambda2 = T_half_daughter_seconds === Infinity ? 0 : Math.log(2) / T_half_daughter_seconds;
                            const A0_daughter_Bq = parseFloat(initialDaughterActivity) * activityFactors[initialUnit];

                            if (isNaN(A0_Bq)) throw new Error("Invalid activity inputs.");

                            const finalParentActivity_Bq = A0_Bq * Math.exp(-lambda * t_seconds);
                            let finalDaughterActivity_Bq;

                            if (Math.abs(lambda - lambda2) < 1e-12 * lambda) {
                                finalDaughterActivity_Bq = (A0_daughter_Bq * Math.exp(-lambda2 * t_seconds)) + (br * A0_Bq * lambda2 * t_seconds * Math.exp(-lambda2 * t_seconds));
                            } else {
                                finalDaughterActivity_Bq = (A0_daughter_Bq * Math.exp(-lambda2 * t_seconds)) + (br * (lambda2 / (lambda2 - lambda)) * A0_Bq * (Math.exp(-lambda * t_seconds) - Math.exp(-lambda2 * t_seconds)));
                            }

                            setResult({
                                parent: { name: selectedNuclide.name, value: (finalParentActivity_Bq / activityFactors[initialUnit]).toPrecision(4) },
                                daughter: { name: daughter.name, value: (finalDaughterActivity_Bq / activityFactors[initialUnit]).toPrecision(4), isStable: T_half_daughter_seconds === Infinity },
                                lambdaVal: displayLambda.toPrecision(4),
                                lambdaUnit: lambdaUnit,
                                unit: initialUnit
                            });
                        }

                        // Chart Logic
                        const plotTimeAbs = Math.abs(timeForChart_seconds);
                        const bestChartUnit = getBestHalfLifeUnit(plotTimeAbs);
                        const plotTimeConverted = plotTimeAbs / unitConversions[bestChartUnit];
                        const labels = [], parentData = [], daughterData = [];
                        const steps = 100;
                        const plotFactor = activityFactors[initialUnit];
                        const CUTOFF = plotA0_Bq * 1e-10;
                        let labelDecimals = plotTimeConverted >= 100 ? 0 : 1;

                        for (let i = 0; i <= steps; i++) {
                            const timePoint = (plotTimeConverted / steps) * i;
                            const timePoint_seconds = timePoint * unitConversions[bestChartUnit];
                            labels.push(parseFloat(timePoint.toFixed(labelDecimals)).toString());

                            let p_val_bq = (plotA0_Bq * Math.exp(-lambda * timePoint_seconds));
                            p_val_bq = Math.max(0, p_val_bq);
                            if (useLogScale && p_val_bq < CUTOFF) p_val_bq = CUTOFF;
                            parentData.push(p_val_bq / plotFactor);

                            if (calculationMode === MODE_DAUGHTER) {
                                const activePath = decayPaths[selectedPathIndex];
                                const daughterName = activePath ? activePath.name : selectedNuclide.daughter.split('(')[0].trim();
                                const daughter = radionuclides.find(n => normalizeString(n.name) === normalizeString(daughterName));
                                
                                if (daughter) {
                                    const T_half_daughter_seconds = parseHalfLifeToSeconds(daughter.halfLife);
                                    const lambda2 = T_half_daughter_seconds === Infinity ? 0 : Math.log(2) / T_half_daughter_seconds;
                                    const A0_daughter_Bq_Chart = (parseFloat(initialDaughterActivity) || 0) * plotFactor;
                                    let d_val_bq;

                                    if (Math.abs(lambda - lambda2) < 1e-12 * lambda) {
                                        d_val_bq = (A0_daughter_Bq_Chart * Math.exp(-lambda2 * timePoint_seconds)) + (br * plotA0_Bq * lambda2 * timePoint_seconds * Math.exp(-lambda2 * timePoint_seconds));
                                    } else {
                                        d_val_bq = (A0_daughter_Bq_Chart * Math.exp(-lambda2 * timePoint_seconds)) + (br * (lambda2 / (lambda2 - lambda)) * plotA0_Bq * (Math.exp(-lambda * timePoint_seconds) - Math.exp(-lambda2 * timePoint_seconds)));
                                    }
                                    d_val_bq = Math.max(0, d_val_bq);
                                    if (useLogScale && d_val_bq < CUTOFF) d_val_bq = CUTOFF;
                                    daughterData.push(d_val_bq / plotFactor);
                                }
                            }
                        }

                        setChartData({
                            labels, parentData, daughterData: daughterData.length > 0 ? daughterData : null,
                            timeUnit: bestChartUnit, parentName: selectedNuclide.name,
                            daughterName: calculationMode === MODE_DAUGHTER ? (decayPaths[selectedPathIndex]?.name || selectedNuclide.daughter.split('(')[0].trim()) : null
                        });

                    } catch (e) { setError(e.message); setResult(null); setChartData(null); }
                }, [selectedNuclide, calculationMode, initialActivity, initialUnit, remainingActivity, remainingUnit, timeElapsed, timeUnit, initialDaughterActivity, branchingFraction, timeMode, targetDate, referenceDate, useUTC, radionuclides, activityFactors, useLogScale, decayPaths, selectedPathIndex]);

                React.useEffect(() => {
                    if (timeMode === 'date' && initialActivity && referenceDate && targetDate) { handleCalculate(); }
                }, [referenceDate, targetDate, timeMode, useUTC]);

                React.useEffect(() => {
                    if (selectedNuclide) { handleCalculate(); } 
                    else { setResult(null); setChartData(null); setError(''); }
                }, [handleCalculate, selectedNuclide]);

                const handleSaveToHistory = () => {
                    if (result && selectedNuclide) {
                        let inputStr = '';
                        let resultStr = '';
                        const getTimeStr = () => timeMode === 'date' ? `at ${new Date(targetDate).toLocaleDateString()}` : `${timeElapsed} ${timeUnit}`;

                        if (calculationMode === MODE_REMAINING) {
                            inputStr = `${initialActivity} ${initialUnit} ${selectedNuclide.symbol} (${getTimeStr()})`;
                            resultStr = `${result.value} ${result.unit}`;
                        } else if (calculationMode === MODE_TIME) {
                            inputStr = `${initialActivity} ${initialUnit} → ${remainingActivity} ${remainingUnit}`;
                            resultStr = `${result.value} ${result.unit}`;
                        } else if (calculationMode === MODE_INITIAL) {
                            inputStr = `${remainingActivity} ${remainingUnit} remaining (${getTimeStr()} ago)`;
                            resultStr = `${result.value} ${result.unit}`;
                        } else if (calculationMode === MODE_DAUGHTER) {
                            inputStr = `${initialActivity} ${initialUnit} ${selectedNuclide.symbol} → ${result.daughter.name}`;
                            resultStr = `D: ${result.daughter.value} ${result.unit}`;
                        }
                        addHistory({ id: Date.now(), type: 'Decay Calc', icon: ICONS.calculator, inputs: inputStr, result: resultStr, view: VIEWS.CALCULATOR });
                        addToast('Saved to history!');
                    }
                };

                const handleKeyDown = (e) => { if (e.key === 'Enter') handleCalculate(); };

                return (
                    <div className="space-y-4">
                        <p className="text-sm text-slate-600 dark:text-slate-400">Calculates remaining activity, time, or daughter products.</p>
                        
                        {/* 1. Nuclide Selection */}
                        <div>
                            <label className="text-sm font-medium text-slate-700 dark:text-slate-300">Radionuclide</label>
                            <div className="mt-1 min-h-[42px]">
                                {selectedNuclide ? (
                                    <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => { setSelectedNuclide(null); }} />
                                ) : (
                                    <SearchableSelect options={sortedRadionuclides} onSelect={(symbol) => { const n = sortedRadionuclides.find(r => r.symbol === symbol); setSelectedNuclide(n); }} placeholder="Search for a radionuclide..." />
                                )}
                            </div>
                        </div>

                        {/* Mode Selection */}
                        <div>
                            <label className="text-sm font-medium text-slate-700 dark:text-slate-300">Calculate</label>
                            <div className="grid grid-cols-2 gap-x-4 gap-y-2 mt-2">
                                {[MODE_REMAINING, MODE_TIME, MODE_INITIAL, MODE_DAUGHTER].map(mode => (
                                    <label key={mode} className="flex items-center gap-2 cursor-pointer">
                                        <input type="radio" name="calcMode" value={mode} checked={calculationMode === mode} onChange={() => setCalculationMode(mode)} className="form-radio h-4 w-4 text-sky-600" />
                                        <span className="text-sm">{{ [MODE_REMAINING]: 'Remaining Activity', [MODE_TIME]: 'Time Elapsed', [MODE_INITIAL]: 'Initial Activity', [MODE_DAUGHTER]: 'Daughter Activity' }[mode]}</span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4 border border-slate-200 dark:border-slate-700 rounded-lg">
                            
                            {renderUnitField("Initial Activity", initialActivity, setInitialActivity, initialUnit, setInitialUnit, calculationMode !== MODE_INITIAL)}

                            {calculationMode !== MODE_DAUGHTER &&
                                renderUnitField("Remaining Activity", remainingActivity, setRemainingActivity, remainingUnit, setRemainingUnit, calculationMode === MODE_TIME || calculationMode === MODE_INITIAL)
                            }

                            {calculationMode === MODE_DAUGHTER && renderUnitField("Initial Daughter Activity", initialDaughterActivity, setInitialDaughterActivity, initialUnit, setInitialUnit, true)}

                            {/* --- Branching Path Selector (NEW) --- */}
                            {calculationMode === MODE_DAUGHTER && decayPaths.length > 1 && (
                                <div className="col-span-1 md:col-span-2 p-2 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-lg">
                                    <label className="block text-xs font-bold text-amber-800 dark:text-amber-200 mb-1">Select Decay Path</label>
                                    <select value={selectedPathIndex} onChange={handlePathChange} className="w-full p-2 text-sm rounded border-amber-300 bg-white dark:bg-slate-800 focus:ring-amber-500">
                                        {decayPaths.map((path, idx) => (
                                            <option key={idx} value={idx}>{path.label} ({(path.fraction * 100).toFixed(2)}%)</option>
                                        ))}
                                    </select>
                                </div>
                            )}

                            {calculationMode === MODE_DAUGHTER && (
                                <div>
                                    <Tooltip text="The fraction of parent decays that turn into this daughter.">
                                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300 cursor-help underline decoration-dotted">Branching Fraction</label>
                                    </Tooltip>
                                    <div className="flex gap-2 mt-1">
                                        <input type="number" value={branchingFraction} onChange={e => setBranchingFraction(e.target.value)} step="0.01" min="0" max="1" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                    </div>
                                </div>
                            )}

                            {/* Time Input Section */}
                            {calculationMode !== MODE_TIME && (
                                <div className="md:col-span-2">
                                    <div className="flex justify-between items-center mb-1">
                                        <label className="text-sm font-medium text-slate-700 dark:text-slate-300">Time Elapsed</label>
                                        <div className="flex bg-slate-200 dark:bg-slate-700 rounded p-0.5">
                                            <button onClick={() => setTimeMode('duration')} className={`px-2 py-0.5 text-xs rounded ${timeMode === 'duration' ? 'bg-white dark:bg-slate-600 shadow' : ''}`}>Duration</button>
                                            <button onClick={() => setTimeMode('date')} className={`px-2 py-0.5 text-xs rounded ${timeMode === 'date' ? 'bg-white dark:bg-slate-600 shadow' : ''}`}>Date</button>
                                        </div>
                                    </div>

                                    {timeMode === 'duration' ? (
                                        <div className="flex gap-2">
                                            <input type="number" value={timeElapsed} onChange={e => setTimeElapsed(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                            <select value={timeUnit} onChange={e => setTimeUnit(e.target.value)} className="p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600">
                                                {['minutes', 'hours', 'days', 'years'].map(u => <option key={u} value={u}>{u}</option>)}
                                            </select>
                                        </div>
                                    ) : (
                                        <div className="flex flex-col gap-2">
                                            <div className="flex justify-end">
                                                <label className="flex items-center gap-2 text-xs font-medium text-slate-600 dark:text-slate-400 cursor-pointer">
                                                    <input type="checkbox" checked={useUTC} onChange={e => setUseUTC(e.target.checked)} className="form-checkbox h-3 w-3 rounded text-sky-600" />
                                                    Calculate in UTC (Ignore DST)
                                                </label>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <div>
                                                    <label className="text-[10px] uppercase font-bold text-slate-500">Reference (Start) {useUTC ? '(UTC)' : '(Local)'}</label>
                                                    <input type="datetime-local" value={referenceDate} onChange={e => setReferenceDate(e.target.value)} onKeyDown={handleKeyDown} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                                </div>
                                                <div>
                                                    <label className="text-[10px] uppercase font-bold text-slate-500">Target (End) {useUTC ? '(UTC)' : '(Local)'}</label>
                                                    <input type="datetime-local" value={targetDate} onChange={e => setTargetDate(e.target.value)} onKeyDown={handleKeyDown} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>

                        {error && <p className="text-red-500 text-sm text-center">{error}</p>}

                        {result && (
                            <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in">
                                <div className="flex justify-between text-xs text-slate-500 dark:text-slate-400 mb-2 border-b border-slate-200 dark:border-slate-600 pb-1">
                                    <span>Decay Constant (λ): {result.lambdaVal} {result.lambdaUnit}</span>
                                </div>
                                {result.label ? (
                                    <div className="flex items-center justify-center">
                                        <div className="text-lg font-bold text-center flex-grow">
                                            <span className="font-semibold block text-sm text-slate-500 dark:text-slate-400">{result.label}</span>
                                            <span>{result.value} {result.unit}</span>
                                        </div>
                                        <CopyButton textToCopy={result.value} />
                                    </div>
                                ) : (
                                    <div className="space-y-2">
                                        <div className="flex items-center justify-between">
                                            <div className="text-lg font-bold text-left">
                                                <span className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Remaining {result.parent.name}</span>
                                                <span>{result.parent.value} {result.unit}</span>
                                            </div>
                                        </div>
                                        <div className="flex items-center justify-between border-t border-slate-200 dark:border-slate-600 pt-2">
                                            <div className="text-lg font-bold text-left">
                                                <span className="font-semibold block text-sm text-slate-500 dark:text-slate-400">{result.daughter.name} {result.daughter.isStable ? "(Stable)" : ""}</span>
                                                <span>{result.daughter.value} {result.unit}</span>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                <div className="text-right mt-2">
                                    <button onClick={handleSaveToHistory} className="text-xs text-sky-600 dark:text-sky-400 hover:underline">Save Result</button>
                                </div>
                            </div>
                        )}

                        {chartData && (
                            <>
                                <div className="flex justify-end mt-4">
                                    <label className="flex items-center gap-2 text-sm cursor-pointer">
                                        <input type="checkbox" checked={useLogScale} onChange={() => setUseLogScale(!useLogScale)} className="form-checkbox h-4 w-4 rounded text-sky-600" /> Use Logarithmic Scale
                                    </label>
                                </div>
                                <DecayChart chartData={chartData} useLogScale={useLogScale} theme={theme} />
                            </>
                        )}
                    </div>
                );
            };
            
            /**
            * @description React component for a static surface contamination survey calculator.
            * This tool allows health physics professionals to quickly analyze a set of static
            * survey data points against regulatory or self-imposed limits.
            *
            * It is commonly used for a **2-part check**, verifying both:
            * 1.  The **average** contamination level is below the acceptable limit.
            * 2.  The **maximum** single reading is below a separate, often more conservative, limit.
            *
            * The component can automatically populate standard limits based on a selected radionuclide
            * and provides real-time feedback on whether the survey "passes" or "fails" both checks.
            *
            * @prop {array} radionuclides - Array of available radionuclides with their properties.
            * @prop {string} nuclideSymbol - The symbol of the currently selected nuclide.
            * @prop {function} setNuclideSymbol - State setter for the nuclide symbol.
            * @prop {string} surveyData - The raw, unparsed string of survey data points.
            * @prop {function} setSurveyData - State setter for the survey data string.
            * @prop {string} avgLimit - The average contamination limit.
            * @prop {function} setAvgLimit - State setter for the average limit.
            * @prop {string} maxLimit - The maximum contamination limit.
            * @prop {function} setMaxLimit - State setter for the maximum limit.
            * @prop {string} unit - The unit of measurement for the data (e.g., dpm/100cm²).
            * @prop {function} setUnit - State setter for the units.
            * @prop {object} result - Object containing the analysis results (average, max, pass/fail status).
            * @prop {function} setResult - State setter for the result object.
            * @prop {string} error - Any error message to display.
            * @prop {function} setError - State setter for error messages.
            */
            
            const StaticSurveyCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, surveyData, setSurveyData, avgLimit, setAvgLimit, maxLimit, setMaxLimit, unit, setUnit, result, setResult, error, setError }) => {
            const surveyNuclides = React.useMemo(() => radionuclides.filter(n => n.regGuideCategory).sort((a,b) => a.name.localeCompare(b.name)), [radionuclides] );
            const selectedNuclide = React.useMemo(() => surveyNuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, surveyNuclides]);
            
            React.useEffect(() => {
            if (selectedNuclide) {
               const limits = REG_GUIDE_1_86_LIMITS[selectedNuclide.regGuideCategory];
               if (limits) {
                   setAvgLimit(limits.total);
                   setMaxLimit(limits.total * 3);
                   setUnit('dpm/100cm²');
               }
            }
            }, [selectedNuclide, setAvgLimit, setMaxLimit, setUnit]);
            
            React.useEffect(() => {
            try {
               setError('');
               if (!surveyData.trim()) { setResult(null); return; }
               const dataPoints = surveyData.split(/[\s,;\n]+/).filter(d => d.trim() !== '' && !isNaN(d)).map(Number);
               if (dataPoints.length === 0) throw new Error("No valid numeric data found.");
               const avg = dataPoints.reduce((sum, val) => sum + val, 0) / dataPoints.length;
               const max = Math.max(...dataPoints);
               const avgL = parseFloat(avgLimit);
               const maxL = parseFloat(maxLimit);
               if (isNaN(avgL) || isNaN(maxL)) { if (avgLimit && maxLimit) { throw new Error("Limits must be valid numbers."); } else { return; } }
               setResult({ count: dataPoints.length, average: avg, max: max, avgPass: avg <= avgL, maxPass: max <= maxL });
            } catch (e) { setError(e.message); setResult(null); }
            }, [surveyData, avgLimit, maxLimit, setResult, setError]);
            
            return (
            <div className="space-y-4 max-w-md mx-auto">
              <div><label className="text-sm font-medium">Survey Nuclide</label><div className="mt-1">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')}/> : <SearchableSelect options={surveyNuclides} onSelect={setNuclideSymbol} placeholder="Select nuclide to auto-fill limits..."/>}</div></div>
              <div>
                  <label className="block text-sm font-medium">Survey Data <span className="text-xs font-normal text-slate-500">(Must be same units as Limit, e.g. DPM)</span></label>
                  <textarea value={surveyData} onChange={e => setSurveyData(e.target.value)} rows="6" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-mono text-sm" placeholder="Paste comma, space, or newline separated values..."></textarea>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div><label className="block text-sm font-medium">Average Limit</label><input type="number" value={avgLimit} onChange={e => setAvgLimit(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  <div>
                       <Tooltip text="This is a common rule of thumb for routine surveys where an occasional higher-than-average reading is acceptable. Always refer to your specific license conditions or survey procedures.">
                           <label className="block text-sm font-medium">Max Limit</label>
                       </Tooltip>
                       <input type="number" value={maxLimit} onChange={e => setMaxLimit(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/>
                   </div>
              </div>
              <div><label className="block text-sm font-medium">Units</label><input type="text" value={unit} onChange={e => setUnit(e.target.value)} placeholder="e.g., mrem/hr, dpm/100cm²" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
              {error && <p className="text-red-500 text-sm text-center">{error}</p>}
              {result && (
                  <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in">
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Survey Analysis Results ({result.count} points)</p>
                      <div className="mt-4 pt-4 border-t border-slate-300 dark:border-slate-600 grid grid-cols-2 gap-4">
                          <div className={`p-2 rounded ${result.avgPass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                            <p className="text-xs font-bold">Average</p>
                            <p className={`font-bold text-lg ${result.avgPass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>{result.avgPass ? 'PASS' : 'FAIL'}</p>
                            <div className="flex items-center justify-center">
                               <p className="text-sm">{result.average.toPrecision(3)}</p>
                               <CopyButton textToCopy={result.average.toPrecision(3)} />
                            </div>
                          </div>
                          <div className={`p-2 rounded ${result.maxPass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                            <p className="text-xs font-bold">Maximum</p>
                            <p className={`font-bold text-lg ${result.maxPass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>{result.maxPass ? 'PASS' : 'FAIL'}</p>
                            <div className="flex items-center justify-center">
                               <p className="text-sm">{result.max.toPrecision(3)}</p>
                               <CopyButton textToCopy={result.max.toPrecision(3)} />
                            </div>
                          </div>
                      </div>
                  </div>
              )}
               {!result && !error && (
                   <div className="text-center p-8 border-2 border-dashed border-slate-300 dark:border-slate-700 rounded-lg mt-4">
                       <p className="text-slate-500 dark:text-slate-400">Enter survey data and limits to analyze the results.</p>
                   </div>
               )}
            </div>
            );
            };
            
            // This component calculates the level of removable surface contamination in dpm/100cm² from gross count rate, background, and instrument efficiencies, then compares the result against regulatory limits from NRC Regulatory Guide 1.86 and ANSI N13.12.
            
            const ContaminationSurveyCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, grossCpm, setGrossCpm, backgroundCpm, setBackgroundCpm, instrumentEff, setInstrumentEff, removableFraction, setRemovableFraction, result, setResult, error, setError }) => {
            const surveyNuclides = React.useMemo(() => radionuclides.filter(n => n.regGuideCategory && n.ansiCategory).sort((a,b) => a.name.localeCompare(b.name)), [radionuclides] );
            const selectedNuclide = React.useMemo(() => surveyNuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, surveyNuclides]);
            
            React.useEffect(() => {
            try {
               setError('');
               if (!selectedNuclide) { setResult(null); return; }
               const gross = parseFloat(grossCpm); const bkg = parseFloat(backgroundCpm);
               const eff = parseFloat(instrumentEff) / 100; const frac = parseFloat(removableFraction);
               if ([gross, bkg, eff, frac].some(isNaN) || eff <= 0 || frac <= 0) throw new Error("All inputs must be valid, positive numbers.");
               if (gross < bkg) throw new Error("Gross CPM cannot be less than background.");
               const netCpm = gross - bkg;
               const dpm = netCpm / eff;
               const contamination = dpm / frac;
               const rgLimit = REG_GUIDE_1_86_LIMITS[selectedNuclide.regGuideCategory].removable;
               const ansiLimit = ANSI_13_12_LIMITS[selectedNuclide.ansiCategory].removable;
               setResult({ contamination: contamination.toFixed(0), rgPass: contamination <= rgLimit, ansiPass: contamination <= ansiLimit, rgLimit, ansiLimit });
            } catch (e) { setError(e.message); setResult(null); }
            }, [selectedNuclide, grossCpm, backgroundCpm, instrumentEff, removableFraction, setResult, setError]);
            
            return (
            <div className="space-y-4 max-w-md mx-auto">
              <div><label className="text-sm font-medium">Contaminant of Concern</label><div className="mt-1">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')}/> : <SearchableSelect options={surveyNuclides} onSelect={setNuclideSymbol} placeholder="Select a nuclide to find limits..."/>}</div></div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div><label className="block text-sm font-medium">Gross CPM</label><input type="number" value={grossCpm} onChange={e => setGrossCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  <div><label className="block text-sm font-medium">Background CPM</label><input type="number" value={backgroundCpm} onChange={e => setBackgroundCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  <div><label className="block text-sm font-medium">Instrument Eff. (%)</label><input type="number" value={instrumentEff} onChange={e => setInstrumentEff(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  <div><Tooltip text="The fraction of removable contamination collected by the wipe, typically assumed to be 10% (0.1)."><label className="block text-sm font-medium">Smear Eff. (0.0-1.0)</label></Tooltip><input type="number" step="0.01" value={removableFraction} onChange={e => setRemovableFraction(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
              </div>
              {error && <p className="text-red-500 text-sm text-center">{error}</p>}
              {result && (
                  <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in">
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Calculated Removable Contamination</p>
                       <div className="flex items-center justify-center">
                           <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{result.contamination} <span className="text-2xl opacity-75">dpm/100cm²</span></p>
                           <CopyButton textToCopy={result.contamination} />
                       </div>
                      <div className="mt-4 pt-4 border-t border-slate-300 dark:border-slate-600 grid grid-cols-2 gap-4">
                          <div className={`p-2 rounded ${result.rgPass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                            <p className="text-xs font-bold">Reg. Guide 1.86</p>
                            <p className={`font-bold text-lg ${result.rgPass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>{result.rgPass ? 'PASS' : 'FAIL'}</p>
                            <p className="text-xs">(Limit: {result.rgLimit})</p>
                          </div>
                          <div className={`p-2 rounded ${result.ansiPass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                            <p className="text-xs font-bold">ANSI N13.12</p>
                            <p className={`font-bold text-lg ${result.ansiPass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>{result.ansiPass ? 'PASS' : 'FAIL'}</p>
                            <p className="text-xs">(Limit: {result.ansiLimit})</p>
                          </div>
                      </div>
                  </div>
              )}
            </div>
            );
            };
            
            const AirborneCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, releaseActivity, setReleaseActivity, activityUnit, setActivityUnit, activityUnits, roomVolume, setRoomVolume, volumeUnit, setVolumeUnit, ventilationRate, setVentilationRate, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const dosimetryNuclides = React.useMemo(() => radionuclides.filter(n => n.dosimetry?.DAC).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
            const selectedNuclide = React.useMemo(() => dosimetryNuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, dosimetryNuclides]);
            
            // Multipliers to convert input unit to µCi (for ALI calculation logic)
            const toMicroCurie = { 'pCi': 1e-6, 'nCi': 1e-3, 'µCi': 1, 'mCi': 1e3, 'Ci': 1e6, 'Bq': 2.7e-5, 'kBq': 0.027, 'MBq': 27, 'GBq': 27000 };
            
            React.useEffect(() => {
            if (!selectedNuclide) { setResult(null); return; }
            try {
            setError('');
            const act = parseFloat(releaseActivity); const vol = parseFloat(roomVolume); const vent = parseFloat(ventilationRate);
            if ([act, vol, vent].some(isNaN) || act < 0 || vol <= 0 || vent < 0) throw new Error("Inputs must be valid numbers.");
            
            const act_uCi = act * toMicroCurie[activityUnit];
            const vol_mL = vol * ({ 'm³': 1e6, 'L': 1000, 'ft³': 28316.8 }[volumeUnit]);
            
            const dac_uCi_mL = selectedNuclide.dosimetry.DAC.inhalation_W || selectedNuclide.dosimetry.DAC.inhalation_D || selectedNuclide.dosimetry.DAC.inhalation_Y || selectedNuclide.dosimetry.DAC.inhalation;
            if (!dac_uCi_mL) throw new Error(`DAC value not found for ${selectedNuclide.name}.`);
            
            const initialConc_uCi_mL = act_uCi / vol_mL;
            const lambda_eff_per_hr = vent;
            const time_to_1_dac_hr = lambda_eff_per_hr > 0 ? (-1 / lambda_eff_per_hr) * Math.log(dac_uCi_mL / initialConc_uCi_mL) : Infinity;
            
            setResult({
              initialConc: initialConc_uCi_mL.toExponential(3),
              dacValue: dac_uCi_mL.toExponential(2),
              dacMultiple: (initialConc_uCi_mL / dac_uCi_mL).toPrecision(3),
              time_to_1_dac_hr: time_to_1_dac_hr > 0 ? time_to_1_dac_hr.toPrecision(3) : 0
            });
            } catch (e) { setError(e.message); setResult(null); }
            }, [selectedNuclide, releaseActivity, activityUnit, roomVolume, volumeUnit, ventilationRate, setResult, setError]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({
              id: Date.now(),
              type: 'Airborne Release',
              icon: ICONS.radon,
              inputs: `${releaseActivity} ${activityUnit} in ${roomVolume} ${volumeUnit}`,
              result: `${result.dacMultiple}x DAC`,
              view: VIEWS.OPERATIONAL_HP
            });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="space-y-4 max-w-md mx-auto">
            <div><label className="text-sm font-medium">Radionuclide</label><div className="mt-1">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={dosimetryNuclides} onSelect={setNuclideSymbol} placeholder="Select a nuclide with a DAC..." />}</div></div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div><label className="block text-sm font-medium">Released Activity</label><div className="flex"><input type="number" value={releaseActivity} onChange={e => setReleaseActivity(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" /><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
              <div><label className="block text-sm font-medium">Room Volume</label><div className="flex"><input type="number" value={roomVolume} onChange={e => setRoomVolume(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" /><select value={volumeUnit} onChange={e => setVolumeUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600"><option>m³</option><option>L</option><option>ft³</option></select></div></div>
              <div className="md:col-span-2"><label className="block text-sm font-medium">Ventilation Rate (ACH)</label><input type="number" value={ventilationRate} onChange={e => setVentilationRate(e.target.value)} placeholder="Air Changes per Hour" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
            </div>
            
            <ContextualNote type="warning">
              <strong>Safety Assumption:</strong> This model assumes perfect, instantaneous mixing of the contaminant. Localized concentrations near the release point may be significantly higher than the calculated average.
            </ContextualNote>
            
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (
              <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 space-y-3 text-center animate-fade-in">
                  <div className="flex justify-end -mt-2 -mr-2">
                      <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                          <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                              <Icon path={ICONS.notepad} className="w-5 h-5" />
                          </button>
                      </Tooltip>
                  </div>
                  <div className="grid grid-cols-2 gap-2 text-sm -mt-4"><p>Initial Concentration:</p><p className="font-mono">{result.initialConc} µCi/mL</p><p>Nuclide DAC:</p><p className="font-mono">{result.dacValue} µCi/mL</p></div>
                  <div className="border-t border-slate-300 dark:border-slate-600 pt-3">
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Initial Concentration</p>
                      <div className="flex items-center justify-center">
                          <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{result.dacMultiple}x DAC</p>
                          <CopyButton textToCopy={result.dacMultiple} />
                      </div>
                  </div>
                  <div className="border-t border-slate-300 dark:border-slate-600 pt-3">
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Time to reach 1 DAC</p>
                      <div className="flex items-center justify-center">
                          <p className="text-2xl font-bold">{result.time_to_1_dac_hr} hours</p>
                          <CopyButton textToCopy={result.time_to_1_dac_hr} />
                      </div>
                  </div>
              </div>
            )}
            </div>
            );
            };
            
            // 1. UPDATED: SurfaceContaminationCalculator (Added Probe Area)
            const SurfaceContaminationCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, staticData, setStaticData, wipeGrossCpm, setWipeGrossCpm, wipeBackgroundCpm, setWipeBackgroundCpm, instrumentEff, setInstrumentEff, smearEff, setSmearEff, probeArea, setProbeArea, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            const surveyNuclides = React.useMemo(() => radionuclides.filter(n => n.regGuideCategory && n.ansiCategory).sort((a,b) => a.name.localeCompare(b.name)), [radionuclides] );
            const selectedNuclide = React.useMemo(() => surveyNuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, surveyNuclides]);
            
            React.useEffect(() => {
            try {
            setError('');
            if (!selectedNuclide) { setResult(null); return; }
            
            const staticPoints = staticData.split(/[\s,;\n]+/).filter(d => d.trim() !== '' && !isNaN(d)).map(Number);
            const wipeGross = parseFloat(wipeGrossCpm);
            const wipeBkg = parseFloat(wipeBackgroundCpm);
            const instEff = parseFloat(instrumentEff) / 100.0;
            const smearFraction = parseFloat(smearEff);
            const area = parseFloat(probeArea);
            
            if (isNaN(instEff) || instEff <= 0) throw new Error("Instrument efficiency must be a positive number.");
            if (isNaN(area) || area <= 0) throw new Error("Probe physical area is required.");
            
            let removableDPM = null, totalDPM = null, maxDPM = null;
            
            // Calculate Removable (Wipe)
            // DPM/100cm2 = NetCPM / (Eff_inst * Eff_wipe)
            // Note: Standard assumes wipe covers 100cm2. If not, user adjusts efficiency or interpretation.
            if (!isNaN(wipeGross) && !isNaN(wipeBkg)) {
              if (wipeGross < wipeBkg) {
                   // Technically valid (stats), but for safety we treat as < LLD or 0
                   removableDPM = 0;
              } else {
                   if (isNaN(smearFraction) || smearFraction <= 0) throw new Error("Smear efficiency must be positive.");
                   const netWipeCpm = wipeGross - wipeBkg;
                   removableDPM = netWipeCpm / (instEff * smearFraction);
              }
            }
            
            // Calculate Total (Static)
            // DPM/100cm2 = (NetCPM / Eff_inst) * (100 / ProbeArea)
            if (staticPoints.length > 0) {
                const avgStaticCpm = staticPoints.reduce((sum, val) => sum + val, 0) / staticPoints.length;
                const maxStaticCpm = Math.max(...staticPoints);
            
                // Assume Gross inputs. Use Wipe Bkg as proxy if available, otherwise 0.
                const bkg = !isNaN(wipeBkg) ? wipeBkg : 0;
            
                const avgNet = Math.max(0, avgStaticCpm - bkg);
                const maxNet = Math.max(0, maxStaticCpm - bkg);
            
                totalDPM = (avgNet / instEff) * (100 / area);
                maxDPM = (maxNet / instEff) * (100 / area);
            } else {
                // Explicitly set to null if no data entered, preventing NaN
                totalDPM = null;
                maxDPM = null;
            }
            
            if (removableDPM === null && totalDPM === null) { setResult(null); return; }
            
            const rgLimits = REG_GUIDE_1_86_LIMITS[selectedNuclide.regGuideCategory];
            const ansiLimits = ANSI_13_12_LIMITS[selectedNuclide.ansiCategory];
            
            setResult({
              removable: removableDPM,
              total_avg: totalDPM,
              total_max: maxDPM,
              rg: {
                  removable_limit: rgLimits.removable,
                  total_limit: rgLimits.total,
                  removable_pass: removableDPM === null || removableDPM <= rgLimits.removable,
                  total_pass: totalDPM === null || totalDPM <= rgLimits.total,
              },
              ansi: {
                  removable_limit: ansiLimits.removable,
                  total_limit: ansiLimits.total,
                  removable_pass: removableDPM === null || removableDPM <= ansiLimits.removable,
                  total_pass: totalDPM === null || totalDPM <= ansiLimits.total,
              }
            });
            } catch (e) {
            setError(e.message);
            setResult(null);
            }
            }, [selectedNuclide, staticData, wipeGrossCpm, wipeBackgroundCpm, instrumentEff, smearEff, probeArea]);
            
            const handleSaveToHistory = () => {
            if (result && selectedNuclide) {
            addHistory({
              id: Date.now(),
              type: 'Surface Survey',
              icon: ICONS.gammaSpec,
              inputs: `${selectedNuclide.symbol}, Area=${probeArea}cm²`,
              result: `Removable: ${result.removable?.toFixed(0) || 'N/A'} dpm`,
              view: VIEWS.OPERATIONAL_HP
            });
            addToast("Saved to history!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div><label className="text-sm font-medium">Contaminant of Concern</label><div className="mt-1">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')}/> : <SearchableSelect options={surveyNuclides} onSelect={setNuclideSymbol} placeholder="Select nuclide to find limits..."/>}</div></div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-3">
                  <label className="block text-sm font-semibold text-slate-700 dark:text-slate-300">Total Contamination (Static)</label>
                  <textarea value={staticData} onChange={e => setStaticData(e.target.value)} rows="3" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-mono text-sm" placeholder="Paste Gross CPM values..."></textarea>
            
                  <div className="pt-2 border-t border-slate-200 dark:border-slate-700">
                      <label className="block text-xs font-bold text-slate-500 mb-1">Physical Probe Area (cm²)</label>
                      <div className="flex gap-2">
                           <input type="number" value={probeArea} onChange={e => setProbeArea(e.target.value)} className="w-full p-2 rounded-md bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 text-sm"/>
                           <select onChange={e => setProbeArea(e.target.value)} className="w-8 p-1 rounded-md bg-slate-200 dark:bg-slate-600 border-none text-xs text-center" value="">
                              <option value="" disabled>Presets</option>
                              <option value="15">15 (Pancake)</option>
                              <option value="100">100 (Alpha)</option>
                              <option value="584">584 (Floor)</option>
                           </select>
                      </div>
                  </div>
              </div>
              <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-3">
                  <label className="block text-sm font-semibold text-slate-700 dark:text-slate-300">Removable (Wipe)</label>
                  <div className="grid grid-cols-2 gap-2">
                      <div><label className="block text-xs font-medium">Gross CPM</label><input type="number" value={wipeGrossCpm} onChange={e => setWipeGrossCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                      <div><label className="block text-xs font-medium">Bkg CPM</label><input type="number" value={wipeBackgroundCpm} onChange={e => setWipeBackgroundCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  </div>
                  <div><label className="block text-xs font-medium">Smear Eff. (0-1)</label><input type="number" step="0.01" value={smearEff} onChange={e => setSmearEff(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
              </div>
            </div>
            
            <div><label className="block text-sm font-medium">Instrument Efficiency (%)</label><input type="number" value={instrumentEff} onChange={e => setInstrumentEff(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" placeholder="e.g. 10 (4pi)"/></div>
            
            {error && <p className="text-red-500 text-sm text-center bg-red-50 dark:bg-red-900/20 p-2 rounded">{error}</p>}
            
            {result && (
              <div className="p-5 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in shadow-sm">
                   <div className="flex justify-between items-center -mt-2 mb-2">
                       <div></div>
                       <h3 className="font-bold text-sm text-slate-500 dark:text-slate-400 uppercase tracking-wide">Survey Results (dpm/100cm²)</h3>
                       <Tooltip text="Save to history"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip>
                   </div>
            
                   <div className="flex flex-wrap justify-center gap-4">
                       {result.removable !== null && (
                           <div className="flex-1 min-w-[140px] p-3 bg-white dark:bg-slate-800 rounded-lg shadow-sm border-l-4 border-sky-500">
                               <p className="text-xs font-bold text-slate-500">Removable</p>
                               <p className="text-2xl font-bold text-slate-800 dark:text-white my-1">{parseInt(result.removable).toLocaleString()}</p>
                               <div className={`text-xs font-bold px-2 py-1 rounded ${result.rg.removable_pass ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                                   Limit: {result.rg.removable_limit}
                               </div>
                           </div>
                       )}
                       {result.total_avg !== null && (
                           <div className="flex-1 min-w-[140px] p-3 bg-white dark:bg-slate-800 rounded-lg shadow-sm border-l-4 border-purple-500">
                               <p className="text-xs font-bold text-slate-500">Total (Avg)</p>
                               <p className="text-2xl font-bold text-slate-800 dark:text-white my-1">{parseInt(result.total_avg).toLocaleString()}</p>
                               <div className={`text-xs font-bold px-2 py-1 rounded ${result.rg.total_pass ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                                   Limit: {result.rg.total_limit.toLocaleString()}
                               </div>
                           </div>
                       )}
                   </div>
              </div>
            )}
            </div>
            );
            };
            
            // 2. DetectorResponseCalculator (Dynamic Geometry)
            const DetectorResponseCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, activity, setActivity, activityUnit, setActivityUnit, distance, setDistance, distanceUnit, setDistanceUnit, detectorType, setDetectorType, shieldMaterial, setShieldMaterial, shieldThickness, setShieldThickness, shieldThicknessUnit, setShieldThicknessUnit, surfaceEff, setSurfaceEff, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            // --- CONFIG ---
            const DETECTORS = {
            'nai_1x1': { label: '1" x 1" NaI(Tl)', type: 'gamma_only', refCpmPerMicroR: 175, radius_cm: 1.27 },
            'nai_2x2': { label: '2" x 2" NaI(Tl)', type: 'gamma_only', refCpmPerMicroR: 900, radius_cm: 2.54 },
            'gm_pancake': { label: 'Pancake GM (Ludlum 44-9)', type: 'mix', refBetaEff: 0.20, alphaEff: 0.15, gammaCpmPerMicroR: 3.3, radius_cm: 2.2 },
            'zns_alpha': { label: 'ZnS(Ag) Scintillator', type: 'alpha_only', alphaEff: 0.25, radius_cm: 2.5 }
            };
            
            const SHIELD_PROPS = {
            'None': { density: 0 },
            'Paper/Clothing': { density: 0.8 },
            'Plastic/Lucite': { density: 1.18, mapTo: 'Water' },
            'Wood': { density: 0.6, mapTo: 'Water' },
            'Aluminum': { density: 2.7, mapTo: 'Aluminum' },
            'Steel': { density: 7.8, mapTo: 'Steel' },
            'Lead': { density: 11.34, mapTo: 'Lead' }
            };
            
            const FALLBACK_HVL = { 'Lead': 0.6, 'Steel': 1.5, 'Aluminum': 4.0, 'Water': 10.0 };
            
            // --- ROBUST CONVERSION FACTORS ---
            // Source of Truth: 1 Ci = 3.7e10 Bq
            const BQ_TO_CI = 1 / 3.7e10; 
            
            const activityFactorsCi = React.useMemo(() => ({
            'Ci': 1,
            'mCi': 1e-3,
            'µCi': 1e-6,
            'TBq': BQ_TO_CI * 1e12,
            'GBq': BQ_TO_CI * 1e9,
            'MBq': BQ_TO_CI * 1e6,
            'kBq': BQ_TO_CI * 1e3,
            'Bq': BQ_TO_CI
            }), [BQ_TO_CI]);
            
            const distanceFactorsM = { 'mm': 0.001, 'cm': 0.01, 'm': 1, 'in': 0.0254, 'ft': 0.3048 };
            const thicknessFactorsCm = { 'mm': 0.1, 'cm': 1, 'in': 2.54 };
            
            const parseE = (str) => {
            if (!str) return 0;
            const parts = str.split(' ');
            let val = parseFloat(parts[0]);
            if (str.toLowerCase().includes('kev')) val /= 1000;
            return val;
            };
            
            const availableNuclides = React.useMemo(() => {
            const det = DETECTORS[detectorType];
            if (det.type === 'alpha_only') return radionuclides.filter(n => n.emissionEnergies?.alpha?.length > 0);
            if (det.type === 'gamma_only') return radionuclides.filter(n => n.gammaConstant);
            return radionuclides;
            }, [radionuclides, detectorType]);
            
            const selectedNuclide = React.useMemo(() => radionuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, radionuclides]);
            
            // --- RECALCULATION TRIGGER ---
            React.useEffect(() => {
            try {
               setError('');
               if (!selectedNuclide) { setResult(null); return; }
            
               const A_val = parseFloat(activity);
               const d_val = parseFloat(distance);
               const t_val = shieldMaterial === 'None' ? 0 : parseFloat(shieldThickness);
               const eff_surf_pct = parseFloat(surfaceEff);
            
               if (isNaN(A_val) || isNaN(d_val) || A_val <= 0 || d_val <= 0) {
                   if (activity && distance) setError("Inputs must be positive.");
                   setResult(null);
                   return;
               }
            
               const detInfo = DETECTORS[detectorType];
               
               // Convert everything to Base Units (Ci, meters, cm)
               const A_Ci = A_val * activityFactorsCi[activityUnit];
               const d_m = d_val * distanceFactorsM[distanceUnit];
               const t_cm = t_val * thicknessFactorsCm[shieldThicknessUnit];
               const shieldDensity = SHIELD_PROPS[shieldMaterial].density;
               const eff_surf = eff_surf_pct / 100.0;
            
               let cpmGamma = 0, cpmBeta = 0, cpmAlpha = 0;
               let attenuationMsg = [];
            
               // 1. Gamma Calculation
               if (detInfo.type !== 'alpha_only' && selectedNuclide.gammaConstant) {
                   const gamma = parseFloat(selectedNuclide.gammaConstant);
                   
                   if (gamma > 0) {
                       // Dose Rate in uR/hr
                       const doseRate_uR_hr = ((gamma * A_Ci) / Math.pow(d_m, 2)) * 1e6;
                       
                       let transmission = 1;
                       if (shieldMaterial !== 'None' && t_cm > 0) {
                           const mapTo = SHIELD_PROPS[shieldMaterial].mapTo;
                           const hvl = (typeof HVL_DATA !== 'undefined' && HVL_DATA[selectedNuclide.symbol]?.[mapTo]) 
                                       || FALLBACK_HVL[mapTo] 
                                       || 0.6; 
                           
                           transmission = Math.pow(0.5, t_cm / hvl);
                       }
            
                       const responseFactor = detInfo.refCpmPerMicroR || detInfo.gammaCpmPerMicroR;
                       cpmGamma = doseRate_uR_hr * transmission * responseFactor;
                   }
               }
            
               // 2. Beta/Alpha Geometry
               if (detInfo.type === 'mix' || detInfo.type === 'alpha_only') {
                   const r_det = detInfo.radius_cm;
                   const d_cm = d_m * 100;
                   
                   // Solid Angle Efficiency
                   const geoEff = 0.5 * (1 - (d_cm / Math.sqrt(Math.pow(d_cm, 2) + Math.pow(r_det, 2))));
                   const A_dpm = A_Ci * 2.22e12; // 1 Ci = 2.22e12 dpm
            
                   if (detInfo.type === 'mix' && selectedNuclide.emissionEnergies?.beta?.length > 0) {
                       const eMax = parseE(selectedNuclide.emissionEnergies.beta[0]);
                       let range_cm = (0.542 * eMax - 0.133) / shieldDensity; 
                       
                       if (shieldMaterial !== 'None' && t_cm > range_cm) {
                           attenuationMsg.push("Betas blocked by shield.");
                       } else if (d_m > (range_cm / 1.2 / 100)) { 
                            attenuationMsg.push("Betas ranged out in air.");
                       } else {
                           cpmBeta = A_dpm * geoEff * (detInfo.refBetaEff || 0.2) * eff_surf;
                       }
                   }
            
                   if (detInfo.alphaEff && selectedNuclide.emissionEnergies?.alpha?.length > 0) {
                       if (shieldMaterial !== 'None' || d_m > 0.05) { 
                           attenuationMsg.push("Alphas blocked.");
                       } else {
                           cpmAlpha = A_dpm * geoEff * detInfo.alphaEff * eff_surf;
                       }
                   }
               }
            
               const totalCpm = cpmGamma + cpmBeta + cpmAlpha;
            
               setResult({
                   // FIX: Use toLocaleString without parseInt to show decimals for low counts
                   displayValue: totalCpm < 10 ? totalCpm.toFixed(2) : Math.round(totalCpm).toLocaleString(),
                   rawCpm: totalCpm,
                   detLabel: detInfo.label,
                   breakdown: `γ:${cpmGamma.toFixed(1)} β:${cpmBeta.toFixed(1)} α:${cpmAlpha.toFixed(1)}`,
                   notes: attenuationMsg
               });
            
            } catch (e) {
               setError(e.message);
               setResult(null);
            }
            }, [nuclideSymbol, activity, activityUnit, distance, distanceUnit, detectorType, shieldMaterial, shieldThickness, shieldThicknessUnit, surfaceEff, radionuclides, activityFactorsCi]);
            
            const handleSave = () => {
            if (result) {
               addHistory({
                   id: Date.now(),
                   type: 'Detector Response',
                   icon: ICONS.doseRate,
                   inputs: `${activity} ${activityUnit} ${nuclideSymbol} @ ${distance} ${distanceUnit}`,
                   result: `${Math.round(result.rawCpm)} cpm`,
                   view: VIEWS.OPERATIONAL_HP
               });
               addToast("Saved!");
            }
            }
            
            return (
            <div className="space-y-4">
               <ContextualNote type="info"><strong>Geometry:</strong> Calculates solid angle efficiency based on detector radius ({DETECTORS[detectorType].radius_cm} cm). Gamma calculation assumes point source.</ContextualNote>
               <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                   <div><label className="block text-sm font-medium">Detector</label><select value={detectorType} onChange={e => setDetectorType(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{Object.entries(DETECTORS).map(([k, v]) => <option key={k} value={k}>{v.label}</option>)}</select></div>
                   <div className="min-h-[42px]">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={availableNuclides} onSelect={setNuclideSymbol} placeholder="Select nuclide..." />}</div>
                   <div className="grid grid-cols-2 gap-4">
                       <div><label className="block text-sm font-medium">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" /><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{Object.keys(activityFactorsCi).map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                       <div><label className="block text-sm font-medium">Distance</label><div className="flex"><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" /><select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{Object.keys(distanceFactorsM).map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                   </div>
                   {/* Shielding Inputs */}
                   <div className="grid grid-cols-2 gap-4 pt-2 border-t border-slate-200 dark:border-slate-700">
                        <div><label className="block text-sm font-medium">Shielding</label><select value={shieldMaterial} onChange={e => setShieldMaterial(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{Object.keys(SHIELD_PROPS).map(m => <option key={m} value={m}>{m}</option>)}</select></div>
                        {shieldMaterial !== 'None' && (
                            <div><label className="block text-sm font-medium">Thickness</label><div className="flex mt-1"><input type="number" value={shieldThickness} onChange={e => setShieldThickness(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/><select value={shieldThicknessUnit} onChange={e => setShieldThicknessUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{Object.keys(thicknessFactorsCm).map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                        )}
                   </div>
               </div>
               {result && (
                   <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm">
                       <div className="flex justify-end -mt-2 -mr-2"><button onClick={handleSave}><Icon path={ICONS.notepad} className="w-5 h-5 text-slate-400 hover:text-sky-500" /></button></div>
                       <p className="text-sm font-bold text-slate-500 uppercase">Estimated Response</p>
                       <p className="text-3xl font-extrabold text-sky-600 dark:text-sky-400 my-2">{result.displayValue} <span className="text-xl text-slate-500">cpm</span></p>
                       <p className="text-xs text-slate-500">{result.breakdown}</p>
                       {result.notes.map((n, i) => <p key={i} className="text-xs text-amber-600 mt-1">{n}</p>)}
                   </div>
               )}
            </div>
            );
            };
            
            // 3. LeakTestCalculator (Added Action Level)
            const LeakTestCalculator = ({ grossCpm, setGrossCpm, backgroundCpm, setBackgroundCpm, instrumentEff, setInstrumentEff, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const LIMIT_UCI = 0.005;
            
            // Auto-calculate Action Level
            const actionLevelNetCpm = React.useMemo(() => {
            const eff = parseFloat(instrumentEff) / 100;
            if (eff > 0) return Math.ceil(LIMIT_UCI * 2.22e6 * eff);
            return 0;
            }, [instrumentEff]);
            
            React.useEffect(() => {
            try {
            setError('');
            const gross = parseFloat(grossCpm);
            const bkg = parseFloat(backgroundCpm);
            const eff = parseFloat(instrumentEff);
            
            if (isNaN(gross) || isNaN(bkg) || isNaN(eff)) { setResult(null); return; }
            if (gross < bkg) throw new Error("Gross < Background.");
            
            const netCpm = gross - bkg;
            const act_uCi = (netCpm / (eff/100)) / 2.22e6;
            const pass = act_uCi < LIMIT_UCI;
            
            setResult({ activity: act_uCi.toExponential(2), pass, netCpm: netCpm.toFixed(0) });
            } catch (e) { setError(e.message); setResult(null); }
            }, [grossCpm, backgroundCpm, instrumentEff, setResult, setError]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Leak Test', icon: ICONS.check, inputs: `Gross: ${grossCpm}, Bkg: ${backgroundCpm}`, result: `${result.activity} µCi`, view: VIEWS.OPERATIONAL_HP });
            addToast("Saved!");
            }
            };
            
            return (
            <div className="space-y-4 max-w-md mx-auto">
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
            <div className="grid grid-cols-2 gap-4">
             <div><label className="block text-sm font-medium">Gross CPM</label><input type="number" value={grossCpm} onChange={e => setGrossCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
             <div><label className="block text-sm font-medium">Bkg CPM</label><input type="number" value={backgroundCpm} onChange={e => setBackgroundCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            </div>
            <div><label className="block text-sm font-medium">Efficiency (%)</label><input type="number" value={instrumentEff} onChange={e => setInstrumentEff(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            
            {/* Visual Action Level Indicator */}
            <div className="p-2 bg-blue-50 dark:bg-blue-900/30 rounded border border-blue-100 dark:border-blue-800 text-center">
             <p className="text-xs text-blue-800 dark:text-blue-200">Action Level (0.005 µCi): <strong>{actionLevelNetCpm} Net CPM</strong></p>
            </div>
            </div>
            
            {result && (
            <div className={`p-4 rounded-lg mt-4 text-center animate-fade-in ${result.pass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
             <div className="flex justify-between items-center -mt-2">
                 <div></div>
                 <p className={`text-3xl font-extrabold ${result.pass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>{result.pass ? 'PASS' : 'FAIL'}</p>
                 <button onClick={handleSaveToHistory}><Icon path={ICONS.notepad} className="w-5 h-5 text-slate-500"/></button>
             </div>
             <p className="text-xl font-bold">{result.activity} µCi</p>
             <p className="text-xs font-mono">Net: {result.netCpm} cpm</p>
            </div>
            )}
            </div>
            );
            };

const SimpleEfficiencyCalculator = ({
    mode, setMode,
    counts, setCounts,
    time, setTime,
    cpm, setCpm,
    dpm, setDpm,
    efficiency, setEfficiency,
    result, setResult,
    error, setError
}) => {
    
    // Auto-Calculate Effect
    React.useEffect(() => {
        // 1. Reset
        setResult(null);
        setError('');

        // --- MODE 1: SCALER (Counts + Time -> CPM) ---
        if (mode === 'scaler') {
            if (!counts || !time) return; // Wait for input
            const c = parseFloat(counts);
            const t = parseFloat(time);
            
            if (isNaN(c) || c < 0) return;
            if (isNaN(t) || t <= 0) return;
            
            const rate = c / t;
            // Poisson Error (Standard Deviation) = sqrt(N) / t
            const stdDev = Math.sqrt(c) / t;
            
            setResult({ 
                label: 'Net Rate', 
                value: rate.toFixed(1) + ' cpm',
                subtext: `± ${stdDev.toFixed(1)} cpm (1σ)`
            });
            // Auto-fill the CPM for the other tabs (silent update)
            setCpm(rate.toFixed(1));
        }

        // --- MODE 2: EFFICIENCY (CPM + DPM -> %) ---
        else if (mode === 'calcEff') {
            if (!cpm || !dpm) return;
            const c = parseFloat(cpm);
            const d = parseFloat(dpm);
            
            if (isNaN(c) || c < 0) return;
            if (isNaN(d) || d <= 0) return;
            
            const eff = (c / d) * 100;
            if (eff > 100) setError('Warning: Calculated efficiency > 100%');
            
            setResult({ label: 'Efficiency', value: eff.toFixed(2) + '%' });
            // Auto-fill efficiency (silent update)
            setEfficiency(eff.toFixed(2));
        }

        // --- MODE 3: ACTIVITY (CPM + % -> DPM) ---
        else {
            if (!cpm || !efficiency) return;
            const c = parseFloat(cpm);
            const e = parseFloat(efficiency);
            
            if (isNaN(c) || c < 0) return;
            if (isNaN(e) || e <= 0) return;
            
            const activity = c / (e / 100);
            
            setResult({ 
                label: 'Activity', 
                value: Math.round(activity).toLocaleString() + ' dpm',
                subtext: `${(activity / 2.22e6).toPrecision(3)} µCi`
            });
        }
    }, [mode, counts, time, cpm, dpm, efficiency, setCpm, setEfficiency, setResult, setError]);

    return (
        <div className="space-y-4 animate-fade-in">
            {/* 3-Way Toggle */}
            <div className="flex bg-slate-200 dark:bg-slate-700 p-1 rounded-lg">
                <button onClick={() => setMode('scaler')} className={`flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md transition-all ${mode === 'scaler' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Scaler</button>
                <button onClick={() => setMode('calcEff')} className={`flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md transition-all ${mode === 'calcEff' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Find Eff %</button>
                <button onClick={() => setMode('calcDpm')} className={`flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md transition-all ${mode === 'calcDpm' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Find DPM</button>
            </div>

            <div className="space-y-3">
                {/* Inputs for SCALER */}
                {mode === 'scaler' && (
                    <div className="grid grid-cols-2 gap-4 animate-fade-in">
                        <div>
                            <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Total Counts</label>
                            <input type="number" value={counts} onChange={e => setCounts(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Count Time (min)</label>
                            <input type="number" value={time} onChange={e => setTime(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                        </div>
                    </div>
                )}

                {/* Inputs for EFFICIENCY/DPM */}
                {mode !== 'scaler' && (
                    <div className="animate-fade-in">
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Net Count Rate (cpm)</label>
                        <input type="number" value={cpm} onChange={e => setCpm(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                    </div>
                )}

                {mode === 'calcEff' && (
                    <div className="animate-fade-in">
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Source Activity (dpm)</label>
                        <input type="number" value={dpm} onChange={e => setDpm(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                    </div>
                )}

                {mode === 'calcDpm' && (
                    <div className="animate-fade-in">
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Instrument Efficiency (%)</label>
                        <div className="relative mt-1">
                            <input type="number" value={efficiency} onChange={e => setEfficiency(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                            <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none text-slate-400">%</div>
                        </div>
                    </div>
                )}
            </div>
            
            {/* Error Message */}
            {error && <p className="text-red-500 text-sm text-center animate-fade-in">{error}</p>}
            
            {/* Result Box */}
            {result && (
                <div className="mt-4 p-4 bg-slate-100 dark:bg-slate-700 rounded-lg text-center border border-slate-200 dark:border-slate-600 animate-fade-in">
                    <p className="text-xs uppercase tracking-wide text-slate-500 dark:text-slate-400 mb-1">{result.label}</p>
                    <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{result.value}</p>
                    {result.subtext && <p className="text-sm text-slate-500 mt-1">{result.subtext}</p>}
                </div>
            )}
        </div>
    );
};

const InverseSquareCalculator = ({
    mode, setMode,
    i1, setI1,
    d1, setD1,
    i2, setI2,
    d2, setD2,
    result, setResult,
    error, setError
}) => {
    
    // Auto-Calculate Effect
    React.useEffect(() => {
        // 1. Reset State
        setResult(null);
        setError('');

        // 2. Parse Base Inputs (Reference)
        const rate1 = parseFloat(i1);
        const dist1 = parseFloat(d1);

        // 3. Silent Fail: If base inputs are empty/invalid, just do nothing yet.
        if (!i1 || !d1 || isNaN(rate1) || isNaN(dist1) || rate1 <= 0 || dist1 <= 0) {
            return; 
        }

        // --- MODE 1: CALCULATE NEW RATE (I2) ---
        if (mode === 'calcI2') {
            // Check Target Distance
            if (!d2) return; // Wait for input
            const dist2 = parseFloat(d2);
            if (isNaN(dist2) || dist2 <= 0) return;

            // Calculate
            const rate2 = rate1 * Math.pow(dist1 / dist2, 2);
            
            setResult({ 
                label: 'Projected Rate (I₂)', 
                value: rate2.toPrecision(3),
                subtext: `at ${dist2} distance units`
            });
        }

        // --- MODE 2: CALCULATE BOUNDARY DISTANCE (D2) ---
        else {
            // Check Target Rate
            if (!i2) return; // Wait for input
            const rate2 = parseFloat(i2);
            if (isNaN(rate2) || rate2 <= 0) return;

            // Physics Check: You can't get HIGHER dose by moving away (assuming point source)
            if (rate2 >= rate1) { 
                setError('Target rate must be lower than reference rate to calculate a distance boundary.'); 
                return; 
            }

            // Calculate
            const dist2 = dist1 * Math.sqrt(rate1 / rate2);
            
            setResult({ 
                label: 'Boundary Distance (d₂)', 
                value: dist2.toFixed(2),
                subtext: `Distance for ${rate2} rate units`
            });
        }

    }, [mode, i1, d1, i2, d2, setResult, setError]); // Run whenever these change

    return (
        <div className="space-y-4 animate-fade-in">
            <div className="p-3 bg-slate-50 dark:bg-slate-700/50 rounded-lg text-sm text-slate-600 dark:text-slate-400">
                <p>Calculate distance boundaries or projected dose rates using actual field measurements.</p>
            </div>

            {/* Mode Toggle */}
            <div className="flex bg-slate-200 dark:bg-slate-700 p-1 rounded-lg">
                <button onClick={() => setMode('calcD2')} className={`flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md transition-all ${mode === 'calcD2' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Find Distance (Boundary)</button>
                <button onClick={() => setMode('calcI2')} className={`flex-1 py-1.5 text-xs sm:text-sm font-medium rounded-md transition-all ${mode === 'calcI2' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}>Find Dose Rate</button>
            </div>

            <div className="space-y-3">
                <div className="grid grid-cols-2 gap-4 animate-fade-in">
                    <div>
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Ref. Rate (I₁)</label>
                        <input type="number" value={i1} onChange={e => setI1(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" placeholder="e.g. 100" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Ref. Distance (d₁)</label>
                        <input type="number" value={d1} onChange={e => setD1(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" placeholder="e.g. 1" />
                    </div>
                </div>

                {mode === 'calcD2' ? (
                    <div className="animate-fade-in">
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Target Limit / Rate (I₂)</label>
                        <input type="number" value={i2} onChange={e => setI2(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" placeholder="e.g. 2" />
                        <p className="text-xs text-slate-500 mt-1">Example: Enter "2" to find the 2 mR/hr boundary line.</p>
                    </div>
                ) : (
                    <div className="animate-fade-in">
                        <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">New Distance (d₂)</label>
                        <input type="number" value={d2} onChange={e => setD2(e.target.value)} className="w-full p-2 mt-1 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" placeholder="e.g. 10" />
                    </div>
                )}
            </div>
            
            {/* Error Message */}
            {error && <p className="text-red-500 text-sm text-center animate-fade-in">{error}</p>}
            
            {/* Result Box */}
            {result && (
                <div className="mt-4 p-4 bg-slate-100 dark:bg-slate-700 rounded-lg text-center border border-slate-200 dark:border-slate-600 animate-fade-in">
                    <p className="text-xs uppercase tracking-wide text-slate-500 dark:text-slate-400 mb-1">{result.label}</p>
                    <p className="text-2xl font-bold text-sky-600 dark:text-sky-400">{result.value}</p>
                    {result.subtext && <p className="text-xs text-slate-500 mt-1">{result.subtext}</p>}
                </div>
            )}
        </div>
    );
};
            
            const OperationalHPCalculators = ({ radionuclides, initialTab }) => {
            const [activeCalculator, setActiveCalculator] = React.useState(initialTab || 'surfaceContam');
            
            React.useEffect(() => {
            if (initialTab) setActiveCalculator(initialTab);
            }, [initialTab]);
            
            const { settings } = React.useContext(SettingsContext);
            const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq'] : ['pCi', 'nCi', 'µCi', 'mCi', 'Ci'], [settings.unitSystem]);
            
            // --- STATE: Surface Contamination ---
            const [sc_nuclideSymbol, setSc_nuclideSymbol] = React.useState('');
            const [sc_staticData, setSc_staticData] = React.useState('');
            const [sc_wipeGrossCpm, setSc_wipeGrossCpm] = React.useState('150');
            const [sc_wipeBackgroundCpm, setSc_wipeBackgroundCpm] = React.useState('50');
            const [sc_instrumentEff, setSc_instrumentEff] = React.useState('25');
            const [sc_smearEff, setSc_smearEff] = React.useState('0.1');
            const [sc_probeArea, setSc_probeArea] = React.useState('15'); 
            const [sc_result, setSc_result] = React.useState(null);
            const [sc_error, setSc_error] = React.useState('');
            
            // --- STATE: Leak Test ---
            const [lt_grossCpm, setLt_grossCpm] = React.useState(() => localStorage.getItem('leakTest_grossCpm') || '150');
            const [lt_backgroundCpm, setLt_backgroundCpm] = React.useState(() => localStorage.getItem('leakTest_backgroundCpm') || '50');
            const [lt_instrumentEff, setLt_instrumentEff] = React.useState(() => localStorage.getItem('leakTest_instrumentEff') || '25');
            const [lt_result, setLt_result] = React.useState(null);
            const [lt_error, setLt_error] = React.useState('');
            
            // --- STATE: Airborne ---
            const [ac_nuclideSymbol, setAc_nuclideSymbol] = React.useState('');
            const [ac_releaseActivity, setAc_releaseActivity] = React.useState('1');
            const [ac_activityUnit, setAc_activityUnit] = React.useState(activityUnits[0]);
            const [ac_roomVolume, setAc_roomVolume] = React.useState('100');
            const [ac_volumeUnit, setAc_volumeUnit] = React.useState('m³');
            const [ac_ventilationRate, setAc_ventilationRate] = React.useState('2');
            const [ac_result, setAc_result] = React.useState(null);
            const [ac_error, setAc_error] = React.useState('');
            
            // --- STATE: Detector Response ---
            const [resp_nuclideSymbol, setResp_nuclideSymbol] = React.useState('');
            const [resp_activity, setResp_activity] = React.useState('1');
            const [resp_activityUnit, setResp_activityUnit] = React.useState('µCi');
            const [resp_distance, setResp_distance] = React.useState('30');
            const [resp_distanceUnit, setResp_distanceUnit] = React.useState('cm');
            const [resp_detectorType, setResp_detectorType] = React.useState('nai_2x2');
            const [resp_shieldMaterial, setResp_shieldMaterial] = React.useState('None');
            const [resp_shieldThickness, setResp_shieldThickness] = React.useState('1');
            const [resp_shieldThicknessUnit, setResp_shieldThicknessUnit] = React.useState('cm');
            const [resp_surfaceEff, setResp_surfaceEff] = React.useState('100');
            const [resp_result, setResp_result] = React.useState(null);
            const [resp_error, setResp_error] = React.useState('');
            
            // --- STATE: Counting Lab (Eff/Activity) ---
            const [eff_mode, setEff_mode] = React.useState('scaler');
            const [eff_counts, setEff_counts] = React.useState('');
            const [eff_time, setEff_time] = React.useState('');
            const [eff_cpm, setEff_cpm] = React.useState('');
            const [eff_dpm, setEff_dpm] = React.useState('');
            const [eff_efficiency, setEff_efficiency] = React.useState('');
            const [eff_result, setEff_result] = React.useState(null);
            const [eff_error, setEff_error] = React.useState('');

            // --- STATE: Inverse Square (NEW 6th Module) ---
            const [inv_mode, setInv_mode] = React.useState('calcD2');
            const [inv_i1, setInv_i1] = React.useState('');
            const [inv_d1, setInv_d1] = React.useState('');
            const [inv_i2, setInv_i2] = React.useState('');
            const [inv_d2, setInv_d2] = React.useState('');
            const [inv_result, setInv_result] = React.useState(null);
            const [inv_error, setInv_error] = React.useState('');
            
            // Full Clear Handler
            const handleClear = () => {
                if(activeCalculator === 'surfaceContam') {
                    setSc_nuclideSymbol(''); setSc_staticData(''); setSc_wipeGrossCpm('150'); setSc_wipeBackgroundCpm('50');
                    setSc_instrumentEff('25'); setSc_smearEff('0.1'); setSc_probeArea('15'); setSc_result(null); setSc_error('');
                }
                if(activeCalculator === 'leakTest') {
                    setLt_grossCpm('150'); setLt_backgroundCpm('50'); setLt_instrumentEff('25'); setLt_result(null); setLt_error('');
                }
                if(activeCalculator === 'efficiency') {
                    setEff_counts(''); setEff_time(''); setEff_cpm(''); setEff_dpm(''); setEff_efficiency(''); setEff_result(null); setEff_error('');
                }
                if(activeCalculator === 'inverseSquare') {
                    setInv_i1(''); setInv_d1(''); setInv_i2(''); setInv_d2(''); setInv_result(null); setInv_error('');
                }
                if(activeCalculator === 'airborne') {
                    setAc_nuclideSymbol(''); setAc_releaseActivity('1'); setAc_roomVolume('100'); setAc_ventilationRate('2'); setAc_result(null); setAc_error('');
                }
                if(activeCalculator === 'response') {
                    setResp_nuclideSymbol(''); setResp_activity('1'); setResp_distance('30'); setResp_shieldMaterial('None'); setResp_surfaceEff('100'); setResp_result(null); setResp_error('');
                }
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-slate-800 dark:text-white">Operational HP Calculators</h2>
                    <ClearButton onClick={handleClear} />
                </div>
            
                {/* 6-Item Grid Navigation */}
                <div className="grid grid-cols-2 sm:grid-cols-3 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-6">
                    <button onClick={() => setActiveCalculator('surfaceContam')} className={`p-2 rounded-md text-xs sm:text-xs font-semibold transition-colors ${activeCalculator === 'surfaceContam' ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Surface</button>
                    <button onClick={() => setActiveCalculator('leakTest')} className={`p-2 rounded-md text-xs sm:text-xs font-semibold transition-colors ${activeCalculator === 'leakTest' ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Leak Test</button>
                    <button onClick={() => setActiveCalculator('efficiency')} className={`p-2 rounded-md text-xs sm:text-xs font-semibold transition-colors ${activeCalculator === 'efficiency' ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Count Lab</button>
                    <button onClick={() => setActiveCalculator('inverseSquare')} className={`p-2 rounded-md text-xs sm:text-xs font-semibold transition-colors ${activeCalculator === 'inverseSquare' ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Inv. Sq</button>
                    <button onClick={() => setActiveCalculator('airborne')} className={`p-2 rounded-md text-xs sm:text-xs font-semibold transition-colors ${activeCalculator === 'airborne' ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Airborne</button>
                    <button onClick={() => setActiveCalculator('response')} className={`p-2 rounded-md text-xs sm:text-xs font-semibold transition-colors ${activeCalculator === 'response' ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>Det. Resp.</button>
                </div>
            
                <div className="mt-4">
                    {activeCalculator === 'surfaceContam' && <SurfaceContaminationCalculator
                        radionuclides={radionuclides}
                        nuclideSymbol={sc_nuclideSymbol} setNuclideSymbol={setSc_nuclideSymbol}
                        staticData={sc_staticData} setStaticData={setSc_staticData}
                        wipeGrossCpm={sc_wipeGrossCpm} setWipeGrossCpm={setSc_wipeGrossCpm}
                        wipeBackgroundCpm={sc_wipeBackgroundCpm} setWipeBackgroundCpm={setSc_wipeBackgroundCpm}
                        instrumentEff={sc_instrumentEff} setInstrumentEff={setSc_instrumentEff}
                        smearEff={sc_smearEff} setSmearEff={setSc_smearEff}
                        probeArea={sc_probeArea} setProbeArea={setSc_probeArea}
                        result={sc_result} setResult={setSc_result}
                        error={sc_error} setError={setSc_error}
                    />}
                    
                    {activeCalculator === 'leakTest' && <LeakTestCalculator
                        grossCpm={lt_grossCpm} setGrossCpm={setLt_grossCpm}
                        backgroundCpm={lt_backgroundCpm} setBackgroundCpm={setLt_backgroundCpm}
                        instrumentEff={lt_instrumentEff} setInstrumentEff={setLt_instrumentEff}
                        result={lt_result} setResult={setLt_result}
                        error={lt_error} setError={setLt_error}
                    />}
                    
                    {activeCalculator === 'efficiency' && <SimpleEfficiencyCalculator
                        mode={eff_mode} setMode={setEff_mode}
                        counts={eff_counts} setCounts={setEff_counts}
                        time={eff_time} setTime={setEff_time}
                        cpm={eff_cpm} setCpm={setEff_cpm}
                        dpm={eff_dpm} setDpm={setEff_dpm}
                        efficiency={eff_efficiency} setEfficiency={setEff_efficiency}
                        result={eff_result} setResult={setEff_result}
                        error={eff_error} setError={setEff_error}
                    />}

                    {activeCalculator === 'inverseSquare' && <InverseSquareCalculator
                        mode={inv_mode} setMode={setInv_mode}
                        i1={inv_i1} setI1={setInv_i1}
                        d1={inv_d1} setD1={setInv_d1}
                        i2={inv_i2} setI2={setInv_i2}
                        d2={inv_d2} setD2={setInv_d2}
                        result={inv_result} setResult={setInv_result}
                        error={inv_error} setError={setInv_error}
                    />}

                    {activeCalculator === 'airborne' && <AirborneCalculator
                        radionuclides={radionuclides}
                        nuclideSymbol={ac_nuclideSymbol} setNuclideSymbol={setAc_nuclideSymbol}
                        releaseActivity={ac_releaseActivity} setReleaseActivity={setAc_releaseActivity}
                        activityUnit={ac_activityUnit} setActivityUnit={setAc_activityUnit} activityUnits={activityUnits}
                        roomVolume={ac_roomVolume} setRoomVolume={setAc_roomVolume}
                        volumeUnit={ac_volumeUnit} setVolumeUnit={setAc_volumeUnit}
                        ventilationRate={ac_ventilationRate} setVentilationRate={setAc_ventilationRate}
                        result={ac_result} setResult={setAc_result}
                        error={ac_error} setError={setAc_error}
                    />}
                    
                    {activeCalculator === 'response' && <DetectorResponseCalculator
                        radionuclides={radionuclides}
                        nuclideSymbol={resp_nuclideSymbol} setNuclideSymbol={setResp_nuclideSymbol}
                        activity={resp_activity} setActivity={setResp_activity}
                        activityUnit={resp_activityUnit} setActivityUnit={setResp_activityUnit}
                        distance={resp_distance} setDistance={setResp_distance}
                        distanceUnit={resp_distanceUnit} setDistanceUnit={setResp_distanceUnit}
                        detectorType={resp_detectorType} setDetectorType={setResp_detectorType}
                        shieldMaterial={resp_shieldMaterial} setShieldMaterial={setResp_shieldMaterial}
                        shieldThickness={resp_shieldThickness} setShieldThickness={setResp_shieldThickness}
                        shieldThicknessUnit={resp_shieldThicknessUnit} setShieldThicknessUnit={setResp_shieldThicknessUnit}
                        surfaceEff={resp_surfaceEff} setSurfaceEff={setResp_surfaceEff}
                        result={resp_result} setResult={setResp_result}
                        error={resp_error} setError={setResp_error}
                    />}
                </div>
            </div>
            </div>
            );
            };
            
            /**
            * @description A calculator to determine radioactive material shipping classification (Excepted, Type A, Type B)
            * based on the nuclide, activity, and form, according to DOT/IAEA A1/A2 values.
            */
            
            const TransportationCalculator = ({ radionuclides, preselectedNuclide }) => {
    // --- 1. CONTEXT & CONSTANTS ---
    const { settings } = React.useContext(SettingsContext);
    const { addHistory } = useCalculationHistory();
    const { addToast } = useToast();
    
    const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci'], [settings.unitSystem]);
    
    const CONTAM_LIMITS = {
        beta_gamma: { removable: 22000, label: 'Beta/Gamma/Low-Tox Alpha' },
        alpha: { removable: 2200, label: 'Other Alpha' }
    };

    // --- 2. STATE: PACKAGE CONTENTS ---
    // List of sources in the package
    const [packageItems, setPackageItems] = React.useState([]);
    
    // "Add New Item" Form State
    const [newItemSymbol, setNewItemSymbol] = React.useState('');
    const [newItemForm, setNewItemForm] = React.useState('A2'); // A1 (Special) or A2 (Normal)
    const [newItemState, setNewItemState] = React.useState('solid'); // solid, liquid, gas
    const [newItemActivity, setNewItemActivity] = React.useState('1');
    const [newItemUnit, setNewItemUnit] = React.useState(() => activityUnits[activityUnits.length - 1]);

    // Package Level Inputs (Dose Rate & Contam)
    const [doseRateAt1m, setDoseRateAt1m] = React.useState('');
    const [doseRateUnit, setDoseRateUnit] = React.useState('mrem/hr');
    const [surfaceDoseRate, setSurfaceDoseRate] = React.useState('');
    const [surfaceDoseRateUnit, setSurfaceDoseRateUnit] = React.useState('mrem/hr');
    
    const [checkContam, setCheckContam] = React.useState(false);
    const [contamNuclideType, setContamNuclideType] = React.useState('beta_gamma');
    const [removableContam, setRemovableContam] = React.useState('');
    const [fixedContam, setFixedContam] = React.useState('');
    
    // Outputs
    const [classificationResult, setClassificationResult] = React.useState(null);
    const [labelResult, setLabelResult] = React.useState(null);
    const [contamResult, setContamResult] = React.useState(null);
    const [error, setError] = React.useState('');

    // --- 3. HELPER: NUCLIDE DATA ---
    const transportNuclides = React.useMemo(() => radionuclides.filter(n => n.shipping && n.shipping.A1 !== undefined && n.shipping.A2 !== undefined).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
    
    // Pre-select logic
    React.useEffect(() => {
        if (preselectedNuclide && transportNuclides.some(n => n.symbol === preselectedNuclide)) {
            setNewItemSymbol(preselectedNuclide);
        }
    }, [preselectedNuclide, transportNuclides]);

    // Update unit default if system changes
    React.useEffect(() => {
        if (!activityUnits.includes(newItemUnit)) {
            setNewItemUnit(activityUnits[activityUnits.length - 1]);
        }
    }, [activityUnits, newItemUnit]);

    // --- 4. LOGIC: ADD/REMOVE ITEMS ---
    const activityFactorsTBq = { 'TBq': 1, 'GBq': 0.001, 'MBq': 1e-6, 'kBq': 1e-9, 'Bq': 1e-12, 'Ci': 0.037, 'mCi': 3.7e-5, 'µCi': 3.7e-8 };

    const handleAddItem = () => {
        if (!newItemSymbol) { setError('Select a nuclide.'); return; }
        const val = parseFloat(newItemActivity);
        if (isNaN(val) || val <= 0) { setError('Invalid activity.'); return; }
        
        const nuclideData = transportNuclides.find(n => n.symbol === newItemSymbol);
        if(!nuclideData) return;

        // Get Limits for this specific item
        let rawLimit = nuclideData.shipping[newItemForm]; // A1 or A2
        let limitTBq = (typeof rawLimit === 'string' && rawLimit.toLowerCase().includes('unlimited')) ? Infinity : parseFloat(rawLimit);
        
        // Multipliers for Excepted
        let matMultiplier = 0; let instMultiplier = 0;
        if (newItemSymbol === 'H-3') { matMultiplier = 2e-2; instMultiplier = 2e-1; } 
        else {
            if (newItemState === 'liquid') { matMultiplier = 1e-4; instMultiplier = 1e-3; } 
            else { matMultiplier = 1e-3; instMultiplier = 1e-2; }
        }
        
        const actTBq = val * activityFactorsTBq[newItemUnit];

        const item = {
            id: Date.now(),
            symbol: newItemSymbol,
            form: newItemForm,
            state: newItemState,
            activityDisplay: `${val} ${newItemUnit}`,
            actTBq: actTBq,
            typeALimit: limitTBq,
            exceptedMatLimit: limitTBq === Infinity ? Infinity : limitTBq * matMultiplier,
            exceptedInstLimit: limitTBq === Infinity ? Infinity : limitTBq * instMultiplier,
            // Calculate fractions immediately
            fracTypeA: limitTBq === Infinity ? 0 : actTBq / limitTBq,
            fracExcMat: (limitTBq === Infinity || limitTBq * matMultiplier === 0) ? 0 : actTBq / (limitTBq * matMultiplier),
            fracExcInst: (limitTBq === Infinity || limitTBq * instMultiplier === 0) ? 0 : actTBq / (limitTBq * instMultiplier),
        };

        setPackageItems(prev => [...prev, item]);
        setNewItemActivity(''); // Reset input
        setError('');
    };

    const handleRemoveItem = (id) => {
        setPackageItems(prev => prev.filter(i => i.id !== id));
    };

    // --- 5. LOGIC: CLASSIFY PACKAGE (Sum of Fractions) ---
    React.useEffect(() => {
        if (packageItems.length === 0) { setClassificationResult(null); return; }

        let totalTBq = 0;
        let sumFracTypeA = 0;
        let sumFracExcMat = 0;
        let sumFracExcInst = 0;
        let sumFracHRCQ = 0;

        packageItems.forEach(item => {
            totalTBq += item.actTBq;
            sumFracTypeA += item.fracTypeA;
            sumFracExcMat += item.fracExcMat;
            sumFracExcInst += item.fracExcInst;
            // HRCQ Threshold: 3000 * A value
            sumFracHRCQ += (item.actTBq / (3000 * item.typeALimit)); 
        });

        // Determine Class
        let classification = '';
        let methodology = '';

        // Check Excepted (Material)
        if (sumFracExcMat <= 1.0) {
            classification = 'EXCEPTED';
            methodology = 'Sum of Fractions ≤ 1.0 (Excepted Material Limits)';
        }
        // Check Excepted (Instrument) - usually usually an "OR" but for a mixed package we verify against material first as worst case? 
        // Actually, mixing materials and instruments is complex. We will display the Material result as primary "Excepted" check.
        
        else if (sumFracTypeA <= 1.0) {
            classification = 'TYPE_A';
            methodology = 'Sum of Fractions ≤ 1.0 (A1/A2 Limits)';
        } else {
            // Check HRCQ (Sum of fractions > 1.0 for 3000xA) OR Total Activity > 1000 TBq
            if (sumFracHRCQ > 1.0 || totalTBq > 1000) {
                classification = 'HRCQ';
                methodology = 'Activity exceeds Type A and HRCQ thresholds.';
            } else {
                classification = 'TYPE_B';
                methodology = 'Activity exceeds Type A limits.';
            }
        }

        setClassificationResult({
            count: packageItems.length,
            totalTBq,
            classification,
            methodology,
            sumFracTypeA,
            sumFracExcMat
        });

    }, [packageItems]);

    // --- 6. LOGIC: LABEL & CONTAM (Package Level) ---
    const toMremHr = (val, unit) => {
        if (unit === 'mrem/hr') return val;
        if (unit === 'rem/hr') return val * 1000;
        if (unit === 'mSv/hr') return val * 100;
        if (unit === 'µSv/hr') return val * 0.1;
        return 0;
    };

    React.useEffect(() => {
        // Label Logic
        if (!doseRateAt1m && !surfaceDoseRate) { setLabelResult(null); }
        else {
            const rate1m = parseFloat(doseRateAt1m);
            const rateSurface = parseFloat(surfaceDoseRate);
            let TI = 0;
            if (!isNaN(rate1m) && rate1m > 0) {
                let mremAt1m = toMremHr(rate1m, doseRateUnit);
                if (mremAt1m <= 0.05) TI = 0;
                else TI = Math.ceil(mremAt1m * 10) / 10;
            }
            
            let labelCategory = "Unknown";
            const surfMrem = !isNaN(rateSurface) ? toMremHr(rateSurface, surfaceDoseRateUnit) : 0;
            
            if (surfMrem <= 0.5 && TI === 0) labelCategory = "White-I";
            else if (surfMrem <= 50 && TI <= 1) labelCategory = "Yellow-II";
            else if (surfMrem <= 200 && TI <= 10) labelCategory = "Yellow-III";
            else if (surfMrem > 200 || TI > 10) labelCategory = "Yellow-III (Exclusive Use)";
            else labelCategory = "Check Limits";
            
            setLabelResult({ TI, labelCategory });
        }

        // Contam Logic
        if (!checkContam) { setContamResult(null); }
        else {
            const remVal = parseFloat(removableContam);
            if (isNaN(remVal)) { setContamResult(null); }
            else {
                const limit = CONTAM_LIMITS[contamNuclideType].removable;
                const fail = remVal > limit;
                setContamResult({
                    status: fail ? 'FAIL' : 'PASS',
                    msg: fail ? `Exceeds 49 CFR Limit (${limit.toLocaleString()} dpm/100cm²)` : 'Within Limits',
                    limit
                });
            }
        }
    }, [doseRateAt1m, doseRateUnit, surfaceDoseRate, surfaceDoseRateUnit, checkContam, removableContam, contamNuclideType]);

    // --- 7. CLEAR & SAVE ---
    const handleClear = () => {
        setPackageItems([]);
        setNewItemSymbol(''); setNewItemActivity('1');
        setDoseRateAt1m(''); setSurfaceDoseRate('');
        setCheckContam(false); setRemovableContam('');
        setError('');
    };

    const handleSave = () => {
        if (!classificationResult) return;
        const labelInfo = labelResult ? ` | ${labelResult.labelCategory} (TI: ${labelResult.TI})` : '';
        const contamInfo = contamResult ? ` | Contam: ${contamResult.status}` : '';
        addHistory({
            id: Date.now(),
            type: 'Transportation',
            icon: ICONS.transport,
            inputs: `${packageItems.length} Items (Total ${classificationResult.totalTBq.toExponential(2)} TBq)`,
            result: `${classificationResult.classification.replace('_', ' ')}${labelInfo}${contamInfo}`,
            view: VIEWS.TRANSPORTATION
        });
        addToast("Saved to history!");
    };

    // --- STYLE HELPERS ---
    const resultStyles = {
        EXCEPTED: { container: 'bg-green-100 dark:bg-green-900/50', title: 'text-green-600 dark:text-green-400', display: 'Excepted Package' },
        TYPE_A: { container: 'bg-sky-100 dark:bg-sky-900/50', title: 'text-sky-600 dark:text-sky-400', display: 'Type A Package' },
        TYPE_B: { container: 'bg-amber-100 dark:bg-amber-900/50', title: 'text-amber-600 dark:text-amber-400', display: 'Type B Package' },
        HRCQ: { container: 'bg-red-100 dark:bg-red-900/50', title: 'text-red-600 dark:text-red-400', display: 'HRCQ (Type B)' }
    };

    return (
        <div className="p-4 animate-fade-in">
            <div className="max-w-2xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-slate-800 dark:text-white">Shipping Calculator</h2>
                    <ClearButton onClick={handleClear} />
                </div>

                {/* --- 1. PACKAGE CONTENTS BUILDER --- */}
                <div className="space-y-4 mb-6 border-b border-slate-200 dark:border-slate-700 pb-6">
                    <h3 className="font-bold text-sm text-slate-500 uppercase">1. Add Package Contents</h3>
                    
                    {/* Add Item Form */}
                    <div className="p-4 bg-slate-50 dark:bg-slate-700/50 rounded-lg space-y-3 border border-slate-200 dark:border-slate-700">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                            {/* Nuclide */}
                            <div>
                                <label className="block text-xs font-medium mb-1">Radionuclide</label>
                                <div className="h-[38px]">
                                    {newItemSymbol ? (
                                        <div className="flex items-center justify-between bg-white dark:bg-slate-800 border dark:border-slate-600 rounded p-2 text-sm">
                                            <span className="font-bold">{newItemSymbol}</span>
                                            <button onClick={() => setNewItemSymbol('')} className="text-red-500 hover:text-red-700"><Icon path={ICONS.clear} className="w-4 h-4"/></button>
                                        </div>
                                    ) : (
                                        <SearchableSelect options={transportNuclides} onSelect={setNewItemSymbol} placeholder="Select..." />
                                    )}
                                </div>
                            </div>
                            
                            {/* Activity */}
                            <div>
                                <label className="block text-xs font-medium mb-1">Activity</label>
                                <div className="flex">
                                    <input type="number" value={newItemActivity} onChange={e => setNewItemActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-white dark:bg-slate-800 border dark:border-slate-600 text-sm" />
                                    <select value={newItemUnit} onChange={e => setNewItemUnit(e.target.value)} className="p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                                </div>
                            </div>

                            {/* Form */}
                            <div>
                                <label className="block text-xs font-medium mb-1">Form</label>
                                <div className="flex gap-2">
                                    <label className={`flex-1 text-center p-2 text-xs font-semibold rounded cursor-pointer ${newItemForm === 'A1' ? 'bg-sky-600 text-white' : 'bg-white dark:bg-slate-800 border dark:border-slate-600'}`}><input type="radio" className="hidden" name="itemForm" checked={newItemForm === 'A1'} onChange={() => setNewItemForm('A1')} />Special (A1)</label>
                                    <label className={`flex-1 text-center p-2 text-xs font-semibold rounded cursor-pointer ${newItemForm === 'A2' ? 'bg-sky-600 text-white' : 'bg-white dark:bg-slate-800 border dark:border-slate-600'}`}><input type="radio" className="hidden" name="itemForm" checked={newItemForm === 'A2'} onChange={() => setNewItemForm('A2')} />Normal (A2)</label>
                                </div>
                            </div>

                            {/* State */}
                            <div>
                                <label className="block text-xs font-medium mb-1">Physical State</label>
                                <select value={newItemState} onChange={e => setNewItemState(e.target.value)} className="w-full p-2 rounded bg-white dark:bg-slate-800 border dark:border-slate-600 text-sm">
                                    <option value="solid">Solid</option><option value="liquid">Liquid</option><option value="gas">Gas</option>
                                </select>
                            </div>
                        </div>
                        <button onClick={handleAddItem} className="w-full py-2 bg-sky-600 hover:bg-sky-700 text-white font-bold rounded shadow-sm text-sm">+ Add Item to Package</button>
                        {error && <p className="text-red-500 text-xs text-center">{error}</p>}
                    </div>

                    {/* Items List */}
                    {packageItems.length > 0 && (
                        <div className="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-lg overflow-hidden">
                            <table className="w-full text-sm text-left">
                                <thead className="bg-slate-100 dark:bg-slate-800 text-xs text-slate-500 uppercase">
                                    <tr><th className="p-2">Nuclide</th><th className="p-2">Activity</th><th className="p-2">Type A Frac</th><th className="p-2"></th></tr>
                                </thead>
                                <tbody className="divide-y divide-slate-100 dark:divide-slate-800">
                                    {packageItems.map(item => (
                                        <tr key={item.id}>
                                            <td className="p-2 font-bold">{item.symbol} <span className="text-[10px] font-normal text-slate-500 block">{item.form}, {item.state}</span></td>
                                            <td className="p-2 font-mono">{item.activityDisplay}</td>
                                            <td className="p-2 font-mono">{item.fracTypeA.toFixed(3)}</td>
                                            <td className="p-2 text-right"><button onClick={() => handleRemoveItem(item.id)} className="text-red-500 hover:text-red-700"><Icon path={ICONS.trash} className="w-4 h-4"/></button></td>
                                        </tr>
                                    ))}
                                </tbody>
                                <tfoot className="bg-slate-50 dark:bg-slate-800/50 text-xs font-bold border-t border-slate-200 dark:border-slate-700">
                                    <tr>
                                        <td className="p-2" colSpan="2">TOTAL FRACTION (Sum of A1/A2):</td>
                                        <td className="p-2 font-mono text-base text-sky-600 dark:text-sky-400">
                                            {classificationResult ? classificationResult.sumFracTypeA.toFixed(3) : '0.000'}
                                        </td>
                                        <td></td>
                                    </tr>
                                </tfoot>
                            </table>
                        </div>
                    )}
                </div>

                {/* --- 2. CLASSIFICATION RESULT --- */}
                {classificationResult && (
                    <div className={`p-4 rounded-lg text-center mb-6 animate-fade-in ${resultStyles[classificationResult.classification].container}`}>
                        <p className="text-xs uppercase font-bold opacity-70 mb-1">Package Classification</p>
                        <p className={`text-2xl font-extrabold ${resultStyles[classificationResult.classification].title}`}>{resultStyles[classificationResult.classification].display}</p>
                        <p className="text-xs mt-2 opacity-80">{classificationResult.methodology}</p>
                    </div>
                )}

                {/* --- 3. LABEL ESTIMATION --- */}
                <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4 mb-6">
                    <h3 className="font-bold text-sm text-slate-500 uppercase">2. Measure Package (Labeling)</h3>
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <label className="block text-xs font-medium">Max Dose Rate @ 1m</label>
                            <div className="flex"><input type="number" value={doseRateAt1m} onChange={e => setDoseRateAt1m(e.target.value)} placeholder="0" className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm" /><select value={doseRateUnit} onChange={e => setDoseRateUnit(e.target.value)} className="p-1 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs"><option value="mrem/hr">mrem/h</option><option value="mSv/hr">mSv/h</option></select></div>
                        </div>
                        <div>
                            <label className="block text-xs font-medium">Max Surface Dose Rate</label>
                            <div className="flex"><input type="number" value={surfaceDoseRate} onChange={e => setSurfaceDoseRate(e.target.value)} placeholder="0" className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm" /><select value={surfaceDoseRateUnit} onChange={e => setSurfaceDoseRateUnit(e.target.value)} className="p-1 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs"><option value="mrem/hr">mrem/h</option><option value="mSv/hr">mSv/h</option></select></div>
                        </div>
                    </div>
                    {labelResult && (
                        <div className="p-3 bg-white/50 dark:bg-black/20 rounded border border-slate-200 dark:border-slate-700 flex justify-between items-center">
                            <div><p className="text-xs text-slate-500">Transport Index (TI)</p><p className="text-lg font-bold">{labelResult.TI.toFixed(1)}</p></div>
                            <div className="text-right"><p className="text-xs text-slate-500">Required Label</p><p className="text-lg font-bold text-sky-600 dark:text-sky-400">{labelResult.labelCategory}</p></div>
                        </div>
                    )}
                </div>

                {/* --- 4. CONTAMINATION --- */}
                <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                    <label className="flex items-center gap-2 font-bold text-sm text-slate-500 uppercase cursor-pointer">
                        <input type="checkbox" checked={checkContam} onChange={e => setCheckContam(e.target.checked)} className="form-checkbox h-4 w-4 rounded text-sky-600" />
                        3. Surface Contamination
                    </label>
                    
                    {checkContam && (
                        <div className="animate-fade-in space-y-3">
                            <div>
                                <label className="block text-xs font-medium mb-1">Category</label>
                                <select value={contamNuclideType} onChange={e => setContamNuclideType(e.target.value)} className="w-full p-2 rounded border bg-white dark:bg-slate-600 dark:border-slate-500 text-sm">
                                    <option value="beta_gamma">Beta / Gamma / Low-Tox Alpha</option>
                                    <option value="alpha">All Other Alpha</option>
                                </select>
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-xs font-medium mb-1">Removable (dpm/100cm²)</label>
                                    <input type="number" value={removableContam} onChange={e => setRemovableContam(e.target.value)} className="w-full p-2 rounded border bg-slate-100 dark:bg-slate-700 text-sm" placeholder="e.g. 500" />
                                    <p className="text-[10px] text-slate-500 mt-1 italic">Limit: {CONTAM_LIMITS[contamNuclideType].removable.toLocaleString()} dpm/100cm²</p>
                                </div>
                                <div>
                                    <label className="block text-xs font-medium mb-1">Fixed (dpm/100cm²)</label>
                                    <input type="number" value={fixedContam} onChange={e => setFixedContam(e.target.value)} className="w-full p-2 rounded border bg-slate-100 dark:bg-slate-700 text-sm" placeholder="Optional" />
                                    <p className="text-[10px] text-slate-500 mt-1">Informational only. Fixed contamination increases surface dose rate but is not limited by 49 CFR 173.443.</p>
                                </div>
                            </div>
                            {contamResult && (
                                <div className={`p-2 rounded text-center text-sm font-bold ${contamResult.status === 'FAIL' ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'}`}>
                                    Result: {contamResult.status} ({contamResult.msg})
                                </div>
                            )}
                        </div>
                    )}
                </div>

                <div className="text-right mt-4">
                    <button onClick={handleSave} className="text-sm text-sky-600 hover:underline font-semibold" disabled={!classificationResult}>Save Full Record</button>
                </div>
            </div>
        </div>
    );
};
            
            /**
             * @description React component acting as a container for various medical physics tools.
             */
            
            const MedicalCalculator = ({ radionuclides }) => {
                const [activeTab, setActiveTab] = React.useState('xrayShielding');
                const { settings } = React.useContext(SettingsContext);
                
                // --- SHARED DATA ---
                const COMMON_THERAPY_ISOTOPES = ['I-131', 'Lu-177', 'Y-90', 'In-111', 'Tc-99m', 'Ra-223', 'Sm-153'];
                
                // State for XRayShieldingCalculator
                const [xray_kvp, setXray_kvp] = React.useState('100');
                const [xray_workload, setXray_workload] = React.useState('200');
                const [xray_useFactor, setXray_useFactor] = React.useState('1');
                const [xray_occupancyFactor, setXray_occupancyFactor] = React.useState('1');
                const [xray_distance, setXray_distance] = React.useState('2.1');
                const [xray_doseLimit, setXray_doseLimit] = React.useState('0.02');
                const [xray_shieldMaterial, setXray_shieldMaterial] = React.useState('Lead');
                const [xray_result, setXray_result] = React.useState(null);
                const [xray_error, setXray_error] = React.useState('');
                
                // State for PatientReleaseCalculator
                const [pr_nuclideSymbol, setPr_nuclideSymbol] = React.useState('');
                const [pr_activity, setPr_activity] = React.useState('30');
                const [pr_activityUnit, setPr_activityUnit] = React.useState(settings.unitSystem === 'si' ? 'GBq' : 'mCi');
                const [pr_measuredRate, setPr_measuredRate] = React.useState(''); // NEW: 1m Rate Check
                const [pr_occupancyFactor, setPr_occupancyFactor] = React.useState('0.25');
                const [pr_distance, setPr_distance] = React.useState('1');
                const [pr_attenuation, setPr_attenuation] = React.useState('0.8');
                const [pr_effectiveHalfLife, setPr_effectiveHalfLife] = React.useState('');
                const [pr_effectiveHalfLifeUnit, setPr_effectiveHalfLifeUnit] = React.useState('hours');
                const [pr_result, setPr_result] = React.useState(null);
                const [pr_error, setPr_error] = React.useState('');
                
                // State for DecayInStorageCalculator
                const [dis_nuclideSymbol, setDis_nuclideSymbol] = React.useState('');
                const [dis_currentRate, setDis_currentRate] = React.useState('5.0');
                const [dis_limit, setDis_limit] = React.useState('0.02');
                const [dis_result, setDis_result] = React.useState(null);
                
                // Dynamic Units
                const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci'], [settings.unitSystem]);
                
                React.useEffect(() => {
                    if (!activityUnits.includes(pr_activityUnit)) setPr_activityUnit(activityUnits[1]);
                }, [settings.unitSystem]);
                
                // Auto-set Attenuation for I-131
                React.useEffect(() => {
                    if (pr_nuclideSymbol === 'I-131') setPr_attenuation('0.8');
                    else setPr_attenuation('1.0');
                }, [pr_nuclideSymbol]);
                
                const handleClearActiveCalculator = () => {
                    if (activeTab === 'xrayShielding') {
                        setXray_kvp('100'); setXray_workload('200'); setXray_useFactor('1');
                        setXray_occupancyFactor('1'); setXray_distance('2.1'); setXray_doseLimit('0.02');
                        setXray_shieldMaterial('Lead'); setXray_result(null); setXray_error('');
                    } else if (activeTab === 'patientRelease') {
                        setPr_nuclideSymbol(''); setPr_activity('30'); setPr_measuredRate('');
                        setPr_occupancyFactor('0.25'); setPr_distance('1'); setPr_attenuation('0.8');
                        setPr_effectiveHalfLife(''); setPr_result(null); setPr_error('');
                    } else if (activeTab === 'decayStorage') {
                        setDis_nuclideSymbol(''); setDis_currentRate('5.0'); setDis_result(null);
                    }
                };
                
                return (
                    <div className="p-4 animate-fade-in">
                        <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                            <div className="flex justify-between items-center">
                                <h2 className="text-xl font-bold text-slate-800 dark:text-white">Medical Physics Tools</h2>
                                <ClearButton onClick={handleClearActiveCalculator} />
                            </div>
                        
                            {/* 4-Way Navigation Tab */}
                            <div className="flex w-full p-1 bg-slate-200 dark:bg-slate-700 rounded-lg my-4 gap-1">
                                {['xrayShielding', 'patientRelease', 'decayStorage', 'effHalfLife'].map(tab => (
                                    <button key={tab} onClick={() => setActiveTab(tab)}
                                        className={`flex-1 p-2 rounded-md text-[10px] sm:text-xs font-bold transition-colors uppercase ${activeTab === tab ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>
                                        {tab === 'xrayShielding' ? 'X-Ray' : tab === 'patientRelease' ? 'Pt Release' : tab === 'decayStorage' ? 'Waste' : 'T½ Eff'}
                                    </button>
                                ))}
                            </div>
                        
                            {activeTab === 'xrayShielding' && <XRayShieldingCalculator
                                kvp={xray_kvp} setKvp={setXray_kvp}
                                workload={xray_workload} setWorkload={setXray_workload}
                                useFactor={xray_useFactor} setUseFactor={setXray_useFactor}
                                occupancyFactor={xray_occupancyFactor} setOccupancyFactor={setXray_occupancyFactor}
                                distance={xray_distance} setDistance={setXray_distance}
                                doseLimit={xray_doseLimit} setDoseLimit={setXray_doseLimit}
                                shieldMaterial={xray_shieldMaterial} setShieldMaterial={setXray_shieldMaterial}
                                result={xray_result} setResult={setXray_result}
                                error={xray_error} setError={setXray_error}
                            />}
                        
                            {activeTab === 'patientRelease' && <PatientReleaseCalculator
                                radionuclides={radionuclides} therapyList={COMMON_THERAPY_ISOTOPES}
                                nuclideSymbol={pr_nuclideSymbol} setNuclideSymbol={setPr_nuclideSymbol}
                                activity={pr_activity} setActivity={setPr_activity}
                                activityUnit={pr_activityUnit} setActivityUnit={setPr_activityUnit}
                                measuredRate={pr_measuredRate} setMeasuredRate={setPr_measuredRate} // NEW PROP
                                activityUnits={activityUnits}
                                occupancyFactor={pr_occupancyFactor} setOccupancyFactor={setPr_occupancyFactor}
                                distance={pr_distance} setDistance={setPr_distance}
                                attenuation={pr_attenuation} setAttenuation={setPr_attenuation}
                                effectiveHalfLife={pr_effectiveHalfLife} setEffectiveHalfLife={setPr_effectiveHalfLife}
                                effectiveHalfLifeUnit={pr_effectiveHalfLifeUnit} setEffectiveHalfLifeUnit={setPr_effectiveHalfLifeUnit}
                                result={pr_result} setResult={setPr_result}
                                error={pr_error} setError={setPr_error}
                                settings={settings}
                            />}
                        
                            {activeTab === 'decayStorage' && <DecayInStorageCalculator
                                radionuclides={radionuclides}
                                nuclideSymbol={dis_nuclideSymbol} setNuclideSymbol={setDis_nuclideSymbol}
                                currentRate={dis_currentRate} setCurrentRate={setDis_currentRate}
                                limit={dis_limit} setLimit={setDis_limit}
                                result={dis_result} setResult={setDis_result}
                            />}

                            {activeTab === 'effHalfLife' && <EffectiveHalfLifeCalculator radionuclides={radionuclides} />}
                        </div>
                    </div>
                );
            };
            
            // --- SUB-COMPONENTS ---

            const XRayShieldingCalculator = ({ kvp, setKvp, workload, setWorkload, useFactor, setUseFactor, occupancyFactor, setOccupancyFactor, distance, setDistance, doseLimit, setDoseLimit, shieldMaterial, setShieldMaterial, result, setResult, error, setError }) => {
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                
                const TVL_DATA = {
                    'Lead': { 50: { TVL1: 0.06, TVLe: 0.17 }, 70: { TVL1: 0.15, TVLe: 0.25 }, 100: { TVL1: 0.25, TVLe: 0.35 }, 125: { TVL1: 0.27, TVLe: 0.38 }, 150: { TVL1: 0.29, TVLe: 0.41 } },
                    'Concrete': { 50: { TVL1: 4.3, TVLe: 4.3 }, 70: { TVL1: 5.4, TVLe: 5.4 }, 100: { TVL1: 6.0, TVLe: 6.0 }, 125: { TVL1: 6.6, TVLe: 6.6 }, 150: { TVL1: 7.0, TVLe: 7.0 } },
                    'Drywall': { 50: { TVL1: 1.8, TVLe: 1.8 }, 70: { TVL1: 2.5, TVLe: 2.5 }, 100: { TVL1: 3.5, TVLe: 3.5 }, 125: { TVL1: 4.2, TVLe: 4.2 }, 150: { TVL1: 4.8, TVLe: 4.8 } }
                };
                const K_FACTORS = { 50: 3.5, 70: 5.0, 100: 7.5, 125: 10.0, 150: 13.0 };
                
                React.useEffect(() => {
                    try {
                        setError('');
                        const W = parseFloat(workload); const U = parseFloat(useFactor); const T = parseFloat(occupancyFactor);
                        const d = parseFloat(distance); const P = parseFloat(doseLimit);
                        if ([W, U, T, d, P].some(isNaN) || W <= 0 || d <= 0) { throw new Error("All inputs must be valid, positive numbers."); }
                        
                        const K_output = K_FACTORS[kvp] || 5.0;
                        const K_unshielded = (K_output * W * U * T) / Math.pow(d, 2);
                        const B = P / K_unshielded;
                        
                        if (B >= 1) { setResult({ thickness: 0, tvls: 0, transmission: `Safe (Factor: ${B.toFixed(1)}x)` }); return; }
                        
                        const n_tvl = -Math.log10(B);
                        const { TVL1, TVLe } = TVL_DATA[shieldMaterial][kvp];
                        const thickness = TVL1 + (n_tvl - 1) * TVLe;
                        
                        setResult({ transmission: B.toExponential(2), tvls: n_tvl.toFixed(2), thickness: thickness.toFixed(2), });
                    } catch (e) { setResult(null); setError(e.message); }
                }, [kvp, workload, useFactor, occupancyFactor, distance, doseLimit, shieldMaterial, setResult, setError]);
                
                const handleSaveToHistory = () => {
                    if (result) {
                        addHistory({ id: Date.now(), type: 'X-Ray Shielding', icon: ICONS.medical, inputs: `${workload} mA-min/wk @ ${kvp} kVp`, result: `${result.thickness} ${shieldMaterial === 'Lead' ? 'mm' : 'cm'}`, view: VIEWS.MEDICAL });
                        addToast("Saved!");
                    }
                };
                
                const useFactorOptions = [ { value: 1, label: '1 (Floors, full-time)' }, { value: 0.25, label: '1/4 (Doors, walls)' }, { value: 0.0625, label: '1/16 (Ceilings)' } ];
                const occupancyOptions = [ { value: 1, label: '1 (Offices, labs)' }, { value: 0.2, label: '1/5 (Corridors)' }, { value: 0.05, label: '1/20 (Restrooms)' }, { value: 0.025, label: '1/40 (Outdoors)' } ];
                const doseLimitOptions = [ { value: 0.1, label: '0.1 mGy/wk (Controlled)' }, { value: 0.02, label: '0.02 mGy/wk (Uncontrolled)' } ];
                
                return (
                    <div className="space-y-4">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><label className="block text-xs font-bold mb-1">Tube Potential</label><select value={kvp} onChange={e => setKvp(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm">{Object.keys(K_FACTORS).map(k => <option key={k} value={k}>{k} kVp</option>)}</select></div>
                            <div><label className="block text-xs font-bold mb-1">Workload (mA-min/wk)</label><input type="number" value={workload} onChange={e => setWorkload(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
                            <div><label className="block text-xs font-bold mb-1">Use Factor (U)</label><select value={useFactor} onChange={e => setUseFactor(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm">{useFactorOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}</select></div>
                            <div><label className="block text-xs font-bold mb-1">Occupancy (T)</label><select value={occupancyFactor} onChange={e => setOccupancyFactor(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm">{occupancyOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}</select></div>
                            <div><label className="block text-xs font-bold mb-1">Distance (m)</label><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
                            <div><label className="block text-xs font-bold mb-1">Limit (Air Kerma)</label><select value={doseLimit} onChange={e => setDoseLimit(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm">{doseLimitOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}</select></div>
                            <div className="md:col-span-2"><label className="block text-xs font-bold mb-1">Shield Material</label><select value={shieldMaterial} onChange={e => setShieldMaterial(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"><option value="Lead">Lead (mm)</option><option value="Concrete">Concrete (cm)</option><option value="Drywall">Drywall (cm)</option></select></div>
                        </div>
                        {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                        {result && (
                            <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in relative">
                                <div className="absolute top-2 right-2"><button onClick={handleSaveToHistory}><Icon path={ICONS.notepad} className="w-5 h-5 text-slate-400 hover:text-sky-500"/></button></div>
                                <p className="text-sm text-slate-500 uppercase font-bold">Required Shielding</p>
                                <p className="text-4xl font-extrabold text-sky-600 dark:text-sky-400 my-2">{result.thickness} <span className="text-xl text-slate-500">{shieldMaterial === 'Lead' ? 'mm' : 'cm'}</span></p>
                                <p className="text-xs text-slate-400">TVLs needed: {result.tvls}</p>
                            </div>
                        )}
                    </div>
                );
            };
            
            const PatientReleaseCalculator = ({ radionuclides, therapyList, nuclideSymbol, setNuclideSymbol, activity, setActivity, activityUnit, setActivityUnit, measuredRate, setMeasuredRate, activityUnits, occupancyFactor, setOccupancyFactor, distance, setDistance, attenuation, setAttenuation, effectiveHalfLife, setEffectiveHalfLife, effectiveHalfLifeUnit, setEffectiveHalfLifeUnit, result, setResult, error, setError, settings }) => {
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                
                const TEDE_LIMIT_MREM = 500;
                const I131_ACTIVITY_LIMIT_MCI = 33;
                const I131_RATE_LIMIT_MREM_HR = 7.0; // 7 mrem/hr at 1 meter
                const actToMci = { 'µCi': 1e-3, 'mCi': 1, 'Ci': 1000, 'MBq': 1/37, 'GBq': 1000/37, 'TBq': 1e6/37 };
                
                const therapyNuclides = React.useMemo(() => radionuclides.filter(n => therapyList.includes(n.symbol) && n.gammaConstant).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides, therapyList]);
                const selectedNuclide = React.useMemo(() => therapyNuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, therapyNuclides]);
                
                React.useEffect(() => {
                    if (!selectedNuclide) { setResult(null); return; }
                    try {
                        setError('');
                        const A0_mCi = parseFloat(activity) * actToMci[activityUnit];
                        const rateCheck = parseFloat(measuredRate); // Optional input
                        
                        if (isNaN(A0_mCi) || A0_mCi <= 0) throw new Error("Invalid activity.");
                        
                        // 1. Tier 1 Check (Activity OR Dose Rate)
                        if (selectedNuclide.symbol.includes('I-131')) {
                            const passesActivity = A0_mCi <= I131_ACTIVITY_LIMIT_MCI;
                            const passesRate = !isNaN(rateCheck) && rateCheck > 0 && rateCheck <= I131_RATE_LIMIT_MREM_HR;
                            
                            if (passesActivity) {
                                setResult({ title: 'PASS (Tier 1)', pass: true, details: [`Activity ≤ ${I131_ACTIVITY_LIMIT_MCI} mCi. Release permitted.`] });
                                return;
                            }
                            if (passesRate) {
                                setResult({ title: 'PASS (Tier 1)', pass: true, details: [`Rate @ 1m ≤ ${I131_RATE_LIMIT_MREM_HR} mrem/hr. Release permitted.`] });
                                return;
                            }
                        }
                        
                        // 2. Calc Effective Half Life
                        let T_half_hours_eff;
                        const T_half_hours_phys = parseHalfLifeToSeconds(selectedNuclide.halfLife) / 3600;
                        const effHL = parseFloat(effectiveHalfLife);
                        
                        if (!isNaN(effHL) && effHL > 0) {
                            const factors = { 'hours': 1, 'days': 24 };
                            T_half_hours_eff = effHL * factors[effectiveHalfLifeUnit];
                            if (T_half_hours_eff > T_half_hours_phys) throw new Error("Effective T½ > Physical T½");
                        } else { T_half_hours_eff = T_half_hours_phys; }
                        
                        // 3. Dose Calc
                        const gamma_app = parseFloat(selectedNuclide.gammaConstant); // R·m²/hr·Ci
                        const gamma_nureg = gamma_app * 10; // Convert to R·cm²/hr·mCi
                        const d_cm = parseFloat(distance) * 100;
                        const E = parseFloat(occupancyFactor);
                        const att = parseFloat(attenuation);
                        
                        if ([d_cm, E, att].some(isNaN) || d_cm <= 0) throw new Error("Invalid inputs.");
                        
                        // If measured rate exists, use it instead of calculating!
                        let rate_R_hr;
                        if (!isNaN(rateCheck) && rateCheck > 0) {
                            // rateCheck is in mrem/hr @ 1m. Scale to distance d.
                            // But usually release calc assumes "rate at 1m" as the source term for 0.25 occupancy
                            // Simplified: if user gave measured rate, use it as the base rate at 1m
                            const rate_mrem_hr_at_1m = rateCheck;
                            rate_R_hr = (rate_mrem_hr_at_1m / 1000) * Math.pow(100 / d_cm, 2); // Inverse square from 1m (100cm) to d_cm
                        } else {
                            rate_R_hr = (gamma_nureg * A0_mCi * att) / Math.pow(d_cm, 2);
                        }

                        const total_dose_R = (rate_R_hr * E) * (T_half_hours_eff * 1.443);
                        const dose_mrem = total_dose_R * 1000;
                        
                        setResult({
                            title: dose_mrem <= TEDE_LIMIT_MREM ? 'PASS (Tier 2)' : 'FAIL',
                            pass: dose_mrem <= TEDE_LIMIT_MREM,
                            details: [`Total Dose: ${formatDoseValue(dose_mrem, 'dose', settings).value} ${formatDoseValue(dose_mrem, 'dose', settings).unit}`, `(Limit: 500 mrem)`],
                            rawDose: dose_mrem
                        });
                    } catch (e) { setResult(null); setError(e.message); }
                }, [selectedNuclide, activity, activityUnit, measuredRate, occupancyFactor, distance, attenuation, effectiveHalfLife, effectiveHalfLifeUnit, settings.unitSystem]);
                
                const handleSave = () => {
                    if (result && selectedNuclide) {
                        addHistory({ id: Date.now(), type: 'Patient Release', icon: ICONS.medical, inputs: `${activity} ${activityUnit} ${selectedNuclide.symbol}`, result: result.title, view: VIEWS.MEDICAL });
                        addToast("Saved!");
                    }
                };
                
                return (
                    <div className="space-y-4">
                        <div><label className="text-xs font-bold mb-1 block">Isotope</label>{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={therapyNuclides} onSelect={setNuclideSymbol} placeholder="Select nuclide..." />}</div>
                        <div className="grid grid-cols-2 gap-4">
                            <div><label className="text-xs font-bold mb-1 block">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                            {/* NEW: MEASURED RATE INPUT */}
                            <div><label className="text-xs font-bold mb-1 block">Meas. Rate @ 1m (mrem/h)</label><input type="number" value={measuredRate} onChange={e => setMeasuredRate(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm" placeholder="Optional" /></div>
                        </div>
                        <div className="grid grid-cols-2 gap-4">
                            <div><label className="text-xs font-bold mb-1 block">Occupancy (E)</label><input type="number" value={occupancyFactor} onChange={e => setOccupancyFactor(e.target.value)} step="0.05" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
                            <div><label className="text-xs font-bold mb-1 block">Distance (m)</label><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
                        </div>
                        {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                        {result && (
                            <div className={`p-4 rounded-lg text-center mt-4 relative ${result.pass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                                <div className="absolute top-2 right-2"><button onClick={handleSave}><Icon path={ICONS.notepad} className="w-5 h-5 text-slate-500 hover:text-black"/></button></div>
                                <p className={`text-2xl font-extrabold ${result.pass ? 'text-green-700 dark:text-green-400' : 'text-red-700 dark:text-red-400'}`}>{result.title}</p>
                                <div className="mt-2 text-sm font-medium text-slate-700 dark:text-slate-300">{result.details.map((d,i) => <p key={i}>{d}</p>)}</div>
                            </div>
                        )}
                    </div>
                );
            };
            
            const DecayInStorageCalculator = ({ radionuclides, nuclideSymbol, setNuclideSymbol, currentRate, setCurrentRate, limit, setLimit, result, setResult }) => {
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                
                React.useEffect(() => {
                    const n = radionuclides?.find(r => r.symbol === nuclideSymbol);
                    const R_curr = parseFloat(currentRate); const R_lim = parseFloat(limit);
                    if (!n || isNaN(R_curr) || isNaN(R_lim) || R_curr <= R_lim) { setResult(null); if (R_curr <= R_lim && R_curr > 0) setResult({ days: 0, date: 'Now' }); return; }
                    
                    const hlSeconds = parseHalfLifeToSeconds(n.halfLife);
                    const hlDays = hlSeconds / 86400;
                    if (hlDays === 0) return;
                    
                    const lambda = Math.log(2) / hlDays;
                    const timeDays = -Math.log(R_lim / R_curr) / lambda;
                    const releaseDate = new Date();
                    releaseDate.setDate(releaseDate.getDate() + Math.ceil(timeDays));
                    
                    setResult({ days: Math.ceil(timeDays), date: releaseDate.toLocaleDateString(), hl: hlDays });
                }, [nuclideSymbol, currentRate, limit, radionuclides]);
                
                const handleSave = () => {
                    if (result) {
                        addHistory({ id: Date.now(), type: 'Waste Storage', icon: ICONS.trash, inputs: `${nuclideSymbol} @ ${currentRate} mR/hr`, result: `Hold ${result.days} days`, view: VIEWS.MEDICAL });
                        addToast("Saved!");
                    }
                };
                
                return (
                    <div className="space-y-4">
                        <div><label className="text-xs font-bold mb-1 block">Waste Isotope</label>{nuclideSymbol ? <CalculatorNuclideInfo nuclide={radionuclides.find(n => n.symbol === nuclideSymbol)} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={radionuclides} onSelect={setNuclideSymbol} placeholder="Select nuclide..." />}</div>
                        <div className="grid grid-cols-2 gap-4">
                            <div><label className="text-xs font-bold mb-1 block">Current Rate (mR/hr)</label><input type="number" value={currentRate} onChange={e => setCurrentRate(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
                            <div><label className="text-xs font-bold mb-1 block">Release Limit</label><input type="number" value={limit} onChange={e => setLimit(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
                        </div>
                        {result && (
                            <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in relative">
                                <div className="absolute top-2 right-2"><button onClick={handleSave}><Icon path={ICONS.notepad} className="w-5 h-5 text-slate-400 hover:text-sky-500"/></button></div>
                                <p className="text-xs uppercase font-bold text-slate-500">Hold For</p>
                                <p className="text-4xl font-extrabold text-sky-600 dark:text-sky-400 my-1">{result.days} <span className="text-xl text-slate-500">Days</span></p>
                                <div className="mt-2 border-t border-slate-300 dark:border-slate-600 pt-2">
                                    <p className="text-sm font-bold text-slate-700 dark:text-slate-200">Release Date: {result.date}</p>
                                    <p className="text-xs text-slate-400">({(result.days / result.hl).toFixed(1)} Half-Lives)</p>
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            const EffectiveHalfLifeCalculator = ({ radionuclides }) => {
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                const [selectedSymbol, setSelectedSymbol] = React.useState('');
                const [bioHalfLife, setBioHalfLife] = React.useState('');
                const [bioUnit, setBioUnit] = React.useState('hours');
                
                // NEW: Manual Physical T1/2 State
                const [useManualTp, setUseManualTp] = React.useState(false);
                const [manualTp, setManualTp] = React.useState('');
                const [manualTpUnit, setManualTpUnit] = React.useState('hours');
                
                const [result, setResult] = React.useState(null);
                const [error, setError] = React.useState('');

                const toHours = (val, unit) => { const factors = { 'seconds': 1/3600, 'minutes': 1/60, 'hours': 1, 'days': 24, 'years': 8760 }; return val * (factors[unit] || 1); };
                const formatTime = (hours) => { if (hours < 1) return `${(hours * 60).toFixed(2)} min`; if (hours > 48) return `${(hours / 24).toFixed(2)} days`; return `${hours.toFixed(2)} hours`; };
                const parseDbHalfLife = (hlString) => {
                    if (!hlString || hlString === 'Stable') return null;
                    const parts = hlString.split(' '); if (parts.length < 2) return null;
                    const val = parseFloat(parts[0]); const unit = parts[1].toLowerCase();
                    let normUnit = 'hours';
                    if (unit.startsWith('s')) normUnit = 'seconds'; else if (unit.startsWith('m') && !unit.startsWith('mo')) normUnit = 'minutes'; else if (unit.startsWith('h')) normUnit = 'hours'; else if (unit.startsWith('d')) normUnit = 'days'; else if (unit.startsWith('y')) normUnit = 'years';
                    return toHours(val, normUnit);
                };

                const handleCalculate = () => {
                    setError(''); setResult(null);
                    
                    let tp_hours = 0;
                    let displaySym = selectedSymbol;
                    
                    if (useManualTp) {
                        const val = parseFloat(manualTp);
                        if(isNaN(val) || val <= 0) { setError('Invalid Manual T½'); return; }
                        tp_hours = toHours(val, manualTpUnit);
                        displaySym = "Custom Isotope";
                    } else {
                        if (!selectedSymbol) { setError('Please select a radionuclide.'); return; }
                        const nuclide = radionuclides.find(n => n.symbol === selectedSymbol);
                        tp_hours = parseDbHalfLife(nuclide.halfLife);
                        if (!tp_hours) { setError('Invalid physical half-life in database.'); return; }
                    }

                    const bioVal = parseFloat(bioHalfLife);
                    if (isNaN(bioVal) || bioVal <= 0) { setError('Please enter a valid biological half-life.'); return; }
                    const tb_hours = toHours(bioVal, bioUnit);
                    const teff_hours = (tp_hours * tb_hours) / (tp_hours + tb_hours);
                    setResult({ nuclide: displaySym, Tp: tp_hours, Tb: tb_hours, Teff: teff_hours, formattedTp: formatTime(tp_hours), formattedTb: formatTime(tb_hours), formattedTeff: formatTime(teff_hours), ratio: (teff_hours / tp_hours) });
                };

                const handleSave = () => {
                    if (!result) return;
                    addHistory({ id: Date.now(), type: 'Medical Calc', icon: ICONS.medical, inputs: `${result.nuclide} (Tb=${result.formattedTb})`, result: `Teff: ${result.formattedTeff}`, view: VIEWS.MEDICAL });
                    addToast("Saved!");
                };

                return (
                    <div className="space-y-4">
                        <div className="p-4 bg-slate-50 dark:bg-slate-700/50 rounded-lg border border-slate-200 dark:border-slate-700">
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="text-sm font-bold text-slate-500 uppercase">1. Physical Half-Life (T<sub>p</sub>)</h3>
                                <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={useManualTp} onChange={e => setUseManualTp(e.target.checked)} className="form-checkbox h-3 w-3 rounded text-sky-600" /> Manual Entry</label>
                            </div>
                            
                            {useManualTp ? (
                                <div className="flex gap-2 animate-fade-in">
                                    <input type="number" value={manualTp} onChange={e => setManualTp(e.target.value)} className="w-full p-2 rounded border dark:bg-slate-800 dark:border-slate-600" placeholder="e.g. 6.0" />
                                    <select value={manualTpUnit} onChange={e => setManualTpUnit(e.target.value)} className="p-2 rounded border bg-slate-100 dark:bg-slate-800 dark:border-slate-600"><option value="minutes">Minutes</option><option value="hours">Hours</option><option value="days">Days</option></select>
                                </div>
                            ) : (
                                <>
                                    {selectedSymbol ? (
                                        <div className="flex justify-between items-center bg-white dark:bg-slate-800 p-2 rounded border dark:border-slate-600">
                                            <span className="font-bold">{selectedSymbol}</span><span className="font-mono text-sm text-slate-500">{radionuclides.find(n => n.symbol === selectedSymbol)?.halfLife}</span>
                                            <button onClick={() => { setSelectedSymbol(''); setResult(null); }} className="text-red-500 hover:underline text-xs ml-2">Change</button>
                                        </div>
                                    ) : (<SearchableSelect options={radionuclides} onSelect={setSelectedSymbol} placeholder="Select Radionuclide..." />)}
                                </>
                            )}
                        </div>
                        
                        <div className="p-4 bg-slate-50 dark:bg-slate-700/50 rounded-lg border border-slate-200 dark:border-slate-700">
                            <h3 className="text-sm font-bold text-slate-500 uppercase mb-2">2. Biological Half-Life (T<sub>b</sub>)</h3>
                            <div className="flex gap-2"><input type="number" value={bioHalfLife} onChange={e => setBioHalfLife(e.target.value)} className="w-full p-2 rounded border dark:bg-slate-800 dark:border-slate-600" placeholder="e.g. 24" /><select value={bioUnit} onChange={e => setBioUnit(e.target.value)} className="p-2 rounded border bg-slate-100 dark:bg-slate-800 dark:border-slate-600"><option value="minutes">Minutes</option><option value="hours">Hours</option><option value="days">Days</option></select></div>
                        </div>
                        <button onClick={handleCalculate} className="w-full py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-bold rounded-lg transition shadow-md">Calculate T<sub>eff</sub></button>
                        {error && <p className="text-red-500 text-center text-sm">{error}</p>}
                        {result && (
                            <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-900 rounded-xl text-center animate-fade-in relative overflow-hidden">
                                <div className="absolute top-0 left-0 h-1 bg-emerald-500 transition-all duration-1000" style={{ width: `${result.ratio * 100}%` }}></div>
                                <p className="text-xs font-bold text-slate-500 uppercase mb-1">Effective Half-Life</p>
                                <p className="text-4xl font-extrabold text-emerald-600 dark:text-emerald-400 mb-2">{result.formattedTeff}</p>
                                <div className="grid grid-cols-2 gap-4 mt-4 pt-4 border-t border-slate-200 dark:border-slate-700 text-sm">
                                    <div><p className="text-slate-500">Physical (T<sub>p</sub>)</p><p className="font-mono font-bold">{result.formattedTp}</p></div>
                                    <div><p className="text-slate-500">Biological (T<sub>b</sub>)</p><p className="font-mono font-bold">{result.formattedTb}</p></div>
                                </div>
                                <div className="mt-4 text-xs text-slate-400 italic">Formula: (T<sub>p</sub> × T<sub>b</sub>) / (T<sub>p</sub> + T<sub>b</sub>)</div>
                                <button onClick={handleSave} className="mt-3 text-sky-600 hover:underline text-xs font-bold">Save Result</button>
                            </div>
                        )}
                    </div>
                );
            };
            
            /**
            * @description A component to display sortable and filterable data tables of all radionuclide emissions.
            */
            const PeakDataTables = ({ radionuclides, onNuclideClick }) => {
            const [activeTable, setActiveTable] = React.useState('gamma');
            const [sortConfig, setSortConfig] = React.useState({ key: 'energyMeV', direction: 'ascending' });
            const [filterText, setFilterText] = React.useState('');
            
            const parseEnergy = React.useCallback((energyStr) => {
            if (!energyStr) return null;
            const energyRegex = /([\d.]+)\s*(MeV|keV)/i;
            const energyMatch = energyStr.match(energyRegex);
            if (!energyMatch) return null;
            let energyMeV = parseFloat(energyMatch[1]);
            if (energyMatch[2].toLowerCase() === 'kev') energyMeV /= 1000;
            return { energyMeV, displayEnergy: energyStr };
            }, []);
            
            const flattenedData = React.useMemo(() => {
            const data = { gamma: [], alpha: [], beta: [] };
            radionuclides.forEach(nuclide => {
            Object.keys(data).forEach(type => {
              nuclide.emissionEnergies?.[type]?.forEach(energyStr => {
                  const parsed = parseEnergy(energyStr);
                  if (parsed) data[type].push({ nuclideSymbol: nuclide.symbol, nuclideName: nuclide.name, category: nuclide.category, ...parsed });
              });
            });
            if (nuclide.daughterEmissions) {
              const daughterNuclide = radionuclides.find(n => n.symbol === nuclide.daughterEmissions.from);
              const daughterCategory = daughterNuclide ? daughterNuclide.category : 'N/A';
              Object.keys(data).forEach(type => {
                  nuclide.daughterEmissions?.[type]?.forEach(energyStr => {
                      const parsed = parseEnergy(energyStr);
                      if (parsed) {
                          const daughterName = `${nuclide.daughterEmissions.from} (from ${nuclide.symbol})`;
                          data[type].push({ nuclideSymbol: nuclide.daughterEmissions.from, nuclideName: daughterName, category: daughterCategory, ...parsed });
                      }
                  });
              });
            }
            });
            return data;
            }, [radionuclides, parseEnergy]);
            
            const sortedAndFilteredData = React.useMemo(() => {
            let dataToProcess = [...flattenedData[activeTable]];
            if (filterText) {
            dataToProcess = dataToProcess.filter(item => item.nuclideName.toLowerCase().includes(filterText.toLowerCase()));
            }
            if (sortConfig.key !== null) {
            dataToProcess.sort((a, b) => {
              const valA = a[sortConfig.key] || '';
              const valB = b[sortConfig.key] || '';
              if (valA < valB) return sortConfig.direction === 'ascending' ? -1 : 1;
              if (valA > valB) return sortConfig.direction === 'ascending' ? 1 : -1;
              return 0;
            });
            }
            return dataToProcess;
            }, [flattenedData, activeTable, sortConfig, filterText]);
            
            const requestSort = (key) => {
            let direction = 'ascending';
            if (sortConfig.key === key && sortConfig.direction === 'ascending') direction = 'descending';
            setSortConfig({ key, direction });
            };
            
            const getSortIndicator = (key) => (sortConfig.key !== key ? '↕' : sortConfig.direction === 'ascending' ? '▲' : '▼');
            
            const handleExportCSV = () => {
            if (sortedAndFilteredData.length === 0) return;
            const headers = ['Nuclide', 'Energy', 'Category'];
            const rows = sortedAndFilteredData.map(item => [`"${item.nuclideName}"`, item.displayEnergy, item.category].join(','));
            const csvContent = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.setAttribute("href", URL.createObjectURL(blob));
            link.setAttribute("download", `${activeTable}_emissions_data.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            };
            
            return (
            <div className="animate-fade-in">
            <div className="flex w-full p-1 bg-slate-100 dark:bg-slate-900/50 rounded-lg mb-4 border border-slate-200 dark:border-slate-700">
              {['alpha', 'beta', 'gamma'].map(type => (
                  <button key={type} onClick={() => setActiveTable(type)} className={`w-1/3 p-2 rounded-md text-sm font-semibold transition-colors capitalize ${activeTable === type ? 'bg-white dark:bg-slate-700 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>
                      {type === 'gamma' ? 'γ' : type === 'beta' ? 'β' : 'α'} {type}
                  </button>
              ))}
            </div>
            
            <div className="flex justify-between items-center mb-2 gap-4">
              <div className="relative flex-grow">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><Icon path={ICONS.search} className="w-4 h-4 text-slate-400" /></div>
                  <input type="text" placeholder={`Filter by nuclide name...`} value={filterText} onChange={(e) => setFilterText(e.target.value)} className="w-full p-2 pl-9 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 text-sm" />
              </div>
              <button onClick={handleExportCSV} className="px-3 py-2 text-sm bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition flex items-center gap-2 flex-shrink-0">
                  <Icon path={ICONS.database} className="w-4 h-4" /> Export CSV
              </button>
            </div>
            
            <div className="overflow-y-auto max-h-[55vh] border border-slate-200 dark:border-slate-700 rounded-lg">
              <table className="w-full text-sm text-left">
                  <thead className="bg-slate-100 dark:bg-slate-700 sticky top-0">
                      <tr>
                          <th className="p-3 cursor-pointer whitespace-nowrap" onClick={() => requestSort('nuclideName')}>Nuclide {getSortIndicator('nuclideName')}</th>
                          <th className="p-3 cursor-pointer whitespace-nowrap" onClick={() => requestSort('energyMeV')}>Energy {getSortIndicator('energyMeV')}</th>
                          <th className="p-3 cursor-pointer whitespace-nowrap" onClick={() => requestSort('category')}>Category {getSortIndicator('category')}</th>
                      </tr>
                  </thead>
                  <tbody className="divide-y divide-slate-200 dark:divide-slate-700">
                      {sortedAndFilteredData.map((item, index) => {
                          const categoryStyle = CATEGORY_STYLES[item.category] || CATEGORY_STYLES['default'];
                          const bgColor = categoryStyle.border.replace('border-l-', 'bg-').replace('-400', '-100').replace('-600', '-900/50');
                          const textColor = categoryStyle.border.replace('border-l-', 'text-').replace('-400', '-700').replace('-600', '-300');
            
                          return (
                              <tr key={`${item.nuclideSymbol}-${item.displayEnergy}-${index}`} className="hover:bg-slate-50 dark:hover:bg-slate-800/50">
                                  <td className="p-3 font-medium">
                                      <button onClick={() => { const nuclideToFind = radionuclides.find(n => n.symbol === item.nuclideSymbol); if (nuclideToFind) onNuclideClick(nuclideToFind);}} className="text-sky-600 dark:text-sky-400 hover:underline">
                                          {item.nuclideName}
                                      </button>
                                  </td>
                                  <td className="p-3 font-mono">{item.displayEnergy}</td>
                                  <td className="p-3"><span className={`px-2 py-0.5 text-xs font-semibold rounded-full ${bgColor} ${textColor}`}>{item.category || 'N/A'}</span></td>
                              </tr>
                          );
                      })}
                  </tbody>
              </table>
            </div>
            </div>
            );
            };
            
            /**
            * @description Integrated Peak Identifier module. Combines a smart search tool (with fingerprinting) and data tables.
            */
            const PeakIdentifier = ({ radionuclides, onNuclideClick }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            const [peakIdMode, setPeakIdMode] = React.useState('search');
            
            // Search Tool State
            const [searchEnergy, setSearchEnergy] = React.useState('');
            const [resolution, setResolution] = React.useState('low'); // 'high' (HPGe) or 'low' (NaI)
            const [minYield, setMinYield] = React.useState('1');
            const [matches, setMatches] = React.useState([]);
            const [analysis, setAnalysis] = React.useState(null);
            
            // --- LIBRARY GENERATION (Integrated) ---
            const PEAK_LIBRARY = React.useMemo(() => {
                const lib = [];
                
                // 1. Ingest from DB
                if (radionuclides) {
                    radionuclides.forEach(n => {
                        // Parse Gamma
                        if (n.emissionEnergies && n.emissionEnergies.gamma) {
                            n.emissionEnergies.gamma.forEach(eStr => {
                                // Regex to pull number: "0.662 MeV" -> 0.662
                                const match = eStr.match(/([\d.]+)/);
                                if (match) {
                                    let energy = parseFloat(match[1]);
                                    // Convert MeV to keV for peak search consistency
                                    if (eStr.includes('MeV')) energy *= 1000; 
                                    
                                    lib.push({ 
                                        symbol: n.symbol, 
                                        name: n.name, 
                                        energy: energy, 
                                        yield: 0, // Default to 0 (Unknown)
                                        confirm: null,
                                        isUnknownYield: true // Flag to track source
                                    });
                                }
                            });
                        }
                    });
                }
            
                // 2. Fallback/Enrichment with High Quality Data
                const COMMON_ISOTOPES = [
                    { symbol: 'Cs-137', name: 'Cesium-137', energy: 661.7, yield: 85.1, confirm: 'Single Peak' },
                    { symbol: 'Co-60', name: 'Cobalt-60', energy: 1173.2, yield: 99.8, confirm: 'Look for 1332.5 keV' },
                    { symbol: 'Co-60', name: 'Cobalt-60', energy: 1332.5, yield: 99.9, confirm: 'Look for 1173.2 keV' },
                    { symbol: 'Am-241', name: 'Americium-241', energy: 59.5, yield: 35.9, confirm: 'Check for Alpha' },
                    { symbol: 'I-131', name: 'Iodine-131', energy: 364.5, yield: 81.2, confirm: 'Look for 284, 637 keV' },
                    { symbol: 'Tc-99m', name: 'Technetium-99m', energy: 140.5, yield: 89.0, confirm: 'Medical Short-lived' },
                    { symbol: 'K-40', name: 'Potassium-40', energy: 1460.8, yield: 10.7, confirm: 'Background NORM' },
                    { symbol: 'Ra-226', name: 'Radium-226', energy: 186.2, yield: 3.6, confirm: 'Check for 351, 609 keV' },
                    { symbol: 'U-235', name: 'Uranium-235', energy: 185.7, yield: 57.2, confirm: 'Look for 143, 163, 205 keV' },
                    { symbol: 'Ir-192', name: 'Iridium-192', energy: 316.5, yield: 82.7, confirm: 'Look for 468, 308 keV' },
                    { symbol: 'Ir-192', name: 'Iridium-192', energy: 468.1, yield: 47.8, confirm: 'Look for 316, 308 keV' },
                ];
                
                COMMON_ISOTOPES.forEach(iso => {
                    // Check if this peak exists in the DB-generated list (approximate match)
                    const existingIndex = lib.findIndex(l => l.symbol === iso.symbol && Math.abs(l.energy - iso.energy) < 2);
                    
                    if (existingIndex > -1) {
                        // FIX: Overwrite the DB entry with the high-quality data (better energy precision + known yield)
                        lib[existingIndex] = { ...lib[existingIndex], ...iso, isUnknownYield: false };
                    } else {
                        // If not in DB, add it
                        lib.push({ ...iso, isUnknownYield: false });
                    }
                });
                
                return lib;
            }, [radionuclides]);
            
            const LEAD_XRAYS = [
                { name: 'Pb K-α2', energy: 72.80 },
                { name: 'Pb K-α1', energy: 74.97 },
                { name: 'Pb K-β3', energy: 84.45 },
                { name: 'Pb K-β1', energy: 84.94 },
                { name: 'Pb K-β2', energy: 87.36 },
            ];
            
            // --- SEARCH LOGIC ---
            React.useEffect(() => {
                const energyVal = parseFloat(searchEnergy);
                if (!searchEnergy || isNaN(energyVal)) { setMatches([]); setAnalysis(null); return; }
                
                // FIX: Tighter tolerance for High Res (0.3% or 1 keV), looser for Low Res (7% or 20 keV)
                let tolerance = resolution === 'high' 
                   ? Math.max(1.0, energyVal * 0.003) 
                   : Math.max(20.0, energyVal * 0.07);
                
                const yieldCutoff = parseFloat(minYield) || 0;
                
                const results = PEAK_LIBRARY.filter(iso => {
                    const delta = Math.abs(iso.energy - energyVal);
                    // FIX: Allow if within tolerance AND (Yield is high enough OR Yield is Unknown)
                    const yieldPass = iso.isUnknownYield ? true : (iso.yield >= yieldCutoff);
                    return delta <= tolerance && yieldPass;
                });
                
                results.sort((a, b) => {
                    // Sort priority: Exact Energy match first, then Yield
                    const deltaA = Math.abs(a.energy - energyVal);
                    const deltaB = Math.abs(b.energy - energyVal);
                    if (Math.abs(deltaA - deltaB) > 1.0) return deltaA - deltaB;
                    return b.yield - a.yield;
                });
                
                setMatches(results);
                
                // Analyze artifacts
                const targetMeV = energyVal / 1000;
                const mc2 = 0.511;
                const comptonEdge = targetMeV / (1 + (mc2 / (2 * targetMeV)));
                const singleEscape = targetMeV > 1.022 ? targetMeV - 0.511 : null;
                const doubleEscape = targetMeV > 1.022 ? targetMeV - 1.022 : null;
                const leadXrayMatch = LEAD_XRAYS.find(xray => Math.abs(xray.energy - energyVal) <= tolerance);
                
                setAnalysis({
                    comptonEdge: (comptonEdge * 1000).toFixed(1),
                    singleEscape: singleEscape ? (singleEscape * 1000).toFixed(1) : null,
                    doubleEscape: doubleEscape ? (doubleEscape * 1000).toFixed(1) : null,
                    isLeadXray: leadXrayMatch ? leadXrayMatch.name : null,
                });
                
            }, [searchEnergy, resolution, minYield, PEAK_LIBRARY]);
            
            const handleSave = () => {
                if (matches.length > 0) {
                    addHistory({ id: Date.now(), type: 'Peak ID', icon: ICONS.gammaSpec, inputs: `${searchEnergy} keV (${resolution})`, result: `Match: ${matches[0].symbol}`, view: VIEWS.PEAK_ID });
                    addToast("Saved!");
                }
            };
            
            const handleClearInputs = () => {
                setSearchEnergy(''); setResolution('low'); setMinYield('1'); setMatches([]); setAnalysis(null);
            };
            
            return (
                <div className="p-4 animate-fade-in">
                    <div className="max-w-2xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-bold text-slate-800 dark:text-white">Peak Identifier</h2>
                            <button onClick={handleClearInputs} className="text-xs text-sky-600 dark:text-sky-400 hover:underline font-semibold flex items-center gap-1">
                                <Icon path={ICONS.clear} className="w-3 h-3"/> Clear
                            </button>
                        </div>
                    
                        <div className="flex w-full p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-4">
                            <button onClick={() => setPeakIdMode('search')} className={`w-1/2 p-2 rounded-md text-sm font-semibold transition-colors ${peakIdMode === 'search' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Search</button>
                            <button onClick={() => setPeakIdMode('tables')} className={`w-1/2 p-2 rounded-md text-sm font-semibold transition-colors ${peakIdMode === 'tables' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Data Tables</button>
                        </div>
                    
                        {peakIdMode === 'search' ? (
                            <div className="animate-fade-in">
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                    <div><label className="block text-sm font-medium">Peak Energy (keV)</label><input type="number" value={searchEnergy} onChange={e => setSearchEnergy(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-bold text-lg" autoFocus/></div>
                                    <div className="grid grid-cols-2 gap-2">
                                        <div><label className="block text-sm font-medium">Min Yield %</label><input type="number" value={minYield} onChange={e => setMinYield(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                                        <div><label className="block text-sm font-medium">Detector</label><select value={resolution} onChange={e => setResolution(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"><option value="low">NaI (Low)</option><option value="high">HPGe (High)</option></select></div>
                                    </div>
                                </div>
                    
                                {analysis && (
                                    <div className="mb-6 p-4 bg-slate-100 dark:bg-slate-700/50 rounded-lg">
                                        <h3 className="text-xs font-bold text-slate-500 uppercase mb-2">Artifact Analysis</h3>
                                        <div className="grid grid-cols-3 gap-2 text-center text-sm">
                                            <div><p className="text-xs text-slate-400">Compton Edge</p><p className="font-mono">{analysis.comptonEdge} keV</p></div>
                                            {analysis.singleEscape && <div><p className="text-xs text-slate-400">Single Esc.</p><p className="font-mono">{analysis.singleEscape} keV</p></div>}
                                            {analysis.doubleEscape && <div><p className="text-xs text-slate-400">Double Esc.</p><p className="font-mono">{analysis.doubleEscape} keV</p></div>}
                                        </div>
                                        {analysis.isLeadXray && <p className="mt-2 text-xs font-bold text-amber-600 text-center">Consistent with {analysis.isLeadXray} X-ray (Shielding)</p>}
                                    </div>
                                )}
                    
                                <div className="space-y-2 max-h-[300px] overflow-y-auto">
                                    {matches.length > 0 ? (
                                        matches.map((m, idx) => (
                                            <div key={idx} onClick={() => { if(m.symbol) { const n = radionuclides.find(r => r.symbol === m.symbol); if(n) onNuclideClick(n); } }} className="p-3 bg-slate-50 dark:bg-slate-800/50 rounded-lg hover:bg-white dark:hover:bg-slate-800 border border-transparent hover:border-sky-200 cursor-pointer transition-all">
                                                <div className="flex justify-between items-start">
                                                    <div>
                                                        <p className="font-bold text-sky-600 dark:text-sky-400">{m.name} ({m.symbol})</p>
                                                        <div className="flex gap-2 text-xs mt-1">
                                                            <span className="font-mono font-semibold text-slate-700 dark:text-slate-200">{m.energy.toFixed(1)} keV</span>
                                                            {m.isUnknownYield ? (
                                                                <span className="bg-slate-200 dark:bg-slate-600 px-1 rounded text-slate-500 dark:text-slate-400 italic">Yield: N/A</span>
                                                            ) : (
                                                                <span className="bg-slate-200 dark:bg-slate-600 px-1 rounded text-slate-600 dark:text-slate-300">Y: {m.yield}%</span>
                                                            )}
                                                        </div>
                                                        {m.confirm && <p className="text-xs text-amber-600 mt-1 italic"><Icon path={ICONS.gammaSpec} className="w-3 h-3 inline mr-1"/>{m.confirm}</p>}
                                                    </div>
                                                    <span className={`text-xs px-2 py-1 rounded-full font-bold ${Math.abs(m.energy - parseFloat(searchEnergy)) < 1 ? 'bg-green-100 text-green-700' : 'bg-slate-100 text-slate-500'}`}>Δ {Math.abs(m.energy - parseFloat(searchEnergy)).toFixed(1)}</span>
                                                </div>
                                            </div>
                                        ))
                                    ) : (
                                        <p className="text-center text-slate-400 py-4">{searchEnergy ? "No matches found." : "Enter energy to search."}</p>
                                    )}
                                </div>
                                {matches.length > 0 && <div className="mt-4 flex justify-center"><button onClick={handleSave} className="text-sm font-bold text-sky-600 hover:text-sky-700 flex items-center gap-1"><Icon path={ICONS.notepad} className="w-4 h-4"/> Save Top Match</button></div>}
                            </div>
                        ) : (
                            <PeakDataTables radionuclides={radionuclides} onNuclideClick={onNuclideClick} />
                        )}
                    </div>
                </div>
            );
            };
            
            /**
            * @description A calculator that uses the Bateman equations to model the activity of every
            * nuclide in a full decay series over time. Now supports Mass input and Sub-Chain selection.
            * @param {{radionuclides: Array<object>, decaySeriesData: Array<object>}} props
            */
           
            const DecaySeriesCalculator = ({ radionuclides, decaySeriesData, theme, onNuclideClick }) => {
                const { settings } = React.useContext(SettingsContext);
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                
                // --- 1. DYNAMIC SUB-CHAINS ---
                const availableSeries = React.useMemo(() => {
                    const list = [];
                    decaySeriesData.forEach(series => {
                        // Add the main series
                        list.push({ label: series.name, value: `${series.id}|0`, chain: series.chain });
                        
                        // Add useful sub-chains
                        if (series.id === 'U-238-series') {
                            const raIndex = series.chain.findIndex(s => s.nuclide === 'Radium-226');
                            if (raIndex > -1) list.push({ label: 'Radium-226 (Sub-chain of U-238)', value: `${series.id}|${raIndex}`, chain: series.chain.slice(raIndex) });
                        }
                        if (series.id === 'Th-232-series') {
                            const th228Index = series.chain.findIndex(s => s.nuclide === 'Thorium-228');
                            if (th228Index > -1) list.push({ label: 'Thorium-228 (Sub-chain of Th-232)', value: `${series.id}|${th228Index}`, chain: series.chain.slice(th228Index) });
                        }
                    });
                    return list;
                }, [decaySeriesData]);
                
                // --- STATE ---
                const [selectedSeriesValue, setSelectedSeriesValue] = React.useState(availableSeries[0].value);
                
                // Input Mode: Activity vs Mass
                const [inputMode, setInputMode] = React.useState('activity'); // 'activity' or 'mass'
                const [inputValue, setInputValue] = React.useState('100'); 
                const [inputUnit, setInputUnit] = React.useState('µCi'); 
                
                // Time
                const [timeElapsed, setTimeElapsed] = React.useState('100');
                const [timeUnit, setTimeUnit] = React.useState('years');
                
                const [results, setResults] = React.useState([]);
                const [chartData, setChartData] = React.useState(null);
                const [rawDataForExport, setRawDataForExport] = React.useState(null); 
                const [error, setError] = React.useState('');
                const [isLoading, setIsLoading] = React.useState(false);
                
                // Persist log scale preference
                const [useLogScale, setUseLogScale] = React.useState(() => {
                    const saved = localStorage.getItem('series_useLogScale');
                    return saved ? JSON.parse(saved) : (settings.chartScale === 'Logarithmic');
                });
                
                React.useEffect(() => {
                    localStorage.setItem('series_useLogScale', JSON.stringify(useLogScale));
                }, [useLogScale]);
                
                // Units lists
                const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci'], [settings.unitSystem]);
                const massUnitsList = ['µg', 'mg', 'g', 'kg'];
                const timeUnitsList = ['seconds', 'minutes', 'hours', 'days', 'years', 'kiloyears', 'megayears', 'gigayears'];
                
                // Factors
                const activityFactorsBq = { 'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'TBq': 1e12, 'µCi': 3.7e4, 'mCi': 3.7e7, 'Ci': 3.7e10 };
                const massFactorsG = { 'µg': 1e-6, 'mg': 1e-3, 'g': 1, 'kg': 1000 };
                const unitConversionsTime = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600, 'kiloyears': 31557600 * 1e3, 'megayears': 31557600 * 1e6, 'gigayears': 31557600 * 1e9 };
                
                // Get active chain based on selection
                const activeSeriesObj = React.useMemo(() => availableSeries.find(s => s.value === selectedSeriesValue), [selectedSeriesValue, availableSeries]);
                
                const handleRowClick = (nuclideName) => {
                    // Clean the name in case the click comes from a complex label
                    const cleanName = nuclideName.split('(')[0].trim();
                    const found = radionuclides.find(n => n.name === cleanName || n.symbol === cleanName);
                    if (found && onNuclideClick) {
                        onNuclideClick(found);
                    }
                };
                
                const handleCalculate = () => {
                    if (!activeSeriesObj) { setError('Please select a decay series.'); return; }
                    const val = parseFloat(inputValue);
                    const t_input = parseFloat(timeElapsed);
                    
                    if (isNaN(val) || val <= 0 || isNaN(t_input) || t_input < 0) {
                        setError('Inputs must be non-negative numbers.');
                        setResults([]); setChartData(null); return;
                    }
                    setError(''); setIsLoading(true);
                    
                    setTimeout(() => {
                        try {
                            // 1. Determine Initial Activity (A0) in Bq
                            let A0_Bq = 0;
                        
                            if (inputMode === 'activity') {
                                A0_Bq = val * activityFactorsBq[inputUnit];
                            } else { // Mass to Activity Calculation
                                // Helper to get clean parent name
                                const rawParentName = activeSeriesObj.chain[0].nuclide;
                                const parentName = rawParentName.split('(')[0].trim(); // CLEANING STEP
                                
                                const parentNuclide = radionuclides.find(n => n.name === parentName || n.symbol === parentName);
                        
                                if (!parentNuclide) {
                                    throw new Error(`Data for parent nuclide ${parentName} not found.`);
                                }
                                if (parentNuclide.halfLife === 'Stable') {
                                    throw new Error(`Cannot calculate activity from mass for a stable nuclide.`);
                                }
                        
                                let sa_Bq_g = parseSpecificActivity(parentNuclide.specificActivity);
                        
                                // If specific activity is not pre-calculated in the database, calculate it.
                                if (!sa_Bq_g || sa_Bq_g === 0) {
                                    const hl_seconds = parseHalfLifeToSeconds(parentNuclide.halfLife);
                                    const match = parentNuclide.symbol.match(/-(\d+)/);
                        
                                    if (!match || !match[1]) {
                                        throw new Error(`Could not determine atomic mass for ${parentNuclide.name}.`);
                                    }
                                    const atomicMass = parseInt(match[1], 10);
                                    const AVOGADRO = 6.02214076e23;
                        
                                    if (hl_seconds === Infinity || hl_seconds === 0) {
                                        throw new Error(`Invalid half-life for ${parentNuclide.name}.`);
                                    }
                        
                                    sa_Bq_g = (Math.log(2) * AVOGADRO) / (hl_seconds * atomicMass);
                                }
                        
                                const mass_g = val * massFactorsG[inputUnit];
                                A0_Bq = mass_g * sa_Bq_g;
                            }
                        
                            const t_seconds = t_input * unitConversionsTime[timeUnit];
                            const flatChain = flattenChainForCalculator(activeSeriesObj.chain);
                        
                            // 2. Calculate Final State (Single Point)
                            const calculatedActivities_Bq = runBatemanWithBranching(flatChain, A0_Bq, t_seconds);
                        
                            let displayFactor;
                            let displayUnit;
                        
                            if (inputMode === 'activity') {
                                displayUnit = inputUnit;
                                displayFactor = 1 / activityFactorsBq[inputUnit];
                            } else {
                                displayFactor = settings.unitSystem === 'si' ? 1 : 1 / 3.7e10;
                                displayUnit = settings.unitSystem === 'si' ? 'Bq' : 'Ci';
                            }
                        
                            const finalResults = flatChain.map((step, i) => {
                                const act = calculatedActivities_Bq[i] * displayFactor;
                                return {
                                    name: step.nuclide,
                                    activity: act,
                                    halfLifeSeconds: parseHalfLifeToSeconds(step.halfLife)
                                };
                            });
                        
                            const totalActivityNow = finalResults.reduce((a, b) => a + b.activity, 0);
                            setResults({ items: finalResults, total: totalActivityNow, displayUnit });
                        
                            // 3. Calculate Chart Data
                            const chartLabels = [];
                            const steps = 100;
                            
                            const datasets = flatChain.map((step, i) => {
                                const hl = parseHalfLifeToSeconds(step.halfLife);
                                const isImportant = i === 0 || i === flatChain.length - 1 || hl > 86400;
                                return {
                                    label: step.nuclide,
                                    data: [],
                                    borderColor: `hsl(${(i * 360 / Math.min(activeSeriesObj.chain.length, 15)) % 360}, 70%, 50%)`,
                                    borderWidth: 2,
                                    pointRadius: 0,
                                    tension: 0.4,
                                    hidden: !isImportant
                                };
                            });
                            const totalData = [];
                        
                            // CSV Prep
                            const rawCsvRows = [];
                            rawCsvRows.push(['Time (' + timeUnit + ')', 'Total Activity', ...flatChain.map(s => s.nuclide)].join(','));
                        
                            for (let i = 0; i <= steps; i++) {
                                const timePoint = (t_input / steps) * i;
                        
                                if (t_input > 10) chartLabels.push(Math.round(timePoint).toString());
                                else chartLabels.push(timePoint.toPrecision(2));
                        
                                const timePoint_seconds = timePoint * unitConversionsTime[timeUnit];
                        
                                const actsAtT_Bq = runBatemanWithBranching(flatChain, A0_Bq, timePoint_seconds);
                        
                                let sum = 0;
                                const rowValues = [timePoint]; // For CSV
                        
                                actsAtT_Bq.forEach((act_Bq, j) => {
                                    const val = act_Bq * displayFactor;
                                    datasets[j].data.push(val);
                                    sum += val;
                                    rowValues.push(val); 
                                });
                        
                                totalData.push(sum);
                                rawCsvRows.push([timePoint, sum, ...actsAtT_Bq.map(v => v * displayFactor)].join(','));
                            }
                        
                            datasets.push({
                                label: 'Total Activity',
                                data: totalData,
                                borderColor: theme === 'dark' ? '#ffffff' : '#000000', 
                                borderWidth: 3,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                tension: 0.4,
                                order: 0 
                            });
                        
                            setChartData({ labels: chartLabels, datasets, timeUnit });
                            setRawDataForExport(rawCsvRows.join('\n'));
                        
                        } catch (e) {
                            setError('Calculation error: ' + e.message);
                            console.error(e);
                        } finally {
                            setIsLoading(false);
                        }
                    }, 50);
                };
                
                // Auto-calc on chain change or unit system change
                React.useEffect(() => {
                    if (selectedSeriesValue) handleCalculate();
                }, [selectedSeriesValue, settings.unitSystem]);
                
                const handleExportCSV = () => {
                    if (!rawDataForExport) return;
                    const blob = new Blob([rawDataForExport], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = `Decay_Series_Data.csv`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                };
                
                const handleClearInputs = () => {
                    setSelectedSeriesValue(availableSeries[0].value);
                    setInputValue('100');
                    setInputMode('activity');
                    setTimeElapsed('100');
                    setTimeUnit('years');
                    setResults([]);
                    setChartData(null);
                    setError('');
                    setIsLoading(false);
                };
                
                return (
                    <div className="p-4 animate-fade-in">
                        <div className="max-w-4xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-bold text-slate-800 dark:text-slate-100">Decay Series Calculator</h2>
                                <button onClick={handleClearInputs} className="text-xs text-sky-600 dark:text-sky-400 hover:underline font-semibold flex items-center gap-1">
                                    <Icon path={ICONS.clear} className="w-3 h-3" /> Clear Inputs
                                </button>
                            </div>
                        
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
                                <div className="md:col-span-2">
                                    <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Decay Chain</label>
                                    <select value={selectedSeriesValue} onChange={e => setSelectedSeriesValue(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600">
                                        {availableSeries.map(s => <option key={s.value} value={s.value}>{s.label}</option>)}
                                    </select>
                                </div>
                        
                                {/* Initial Quantity Input (Mass or Activity) */}
                                <div>
                                    <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Initial Quantity</label>
                                    <div className="flex">
                                        <input type="number" value={inputValue} onChange={e => setInputValue(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                        <select
                                            value={inputUnit}
                                            onChange={e => {
                                                const u = e.target.value;
                                                setInputUnit(u);
                                                if (massUnitsList.includes(u)) setInputMode('mass');
                                                else setInputMode('activity');
                                            }}
                                            className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 border border-slate-300 dark:border-slate-600 text-sm font-bold w-24"
                                        >
                                            <optgroup label="Activity">
                                                {activityUnits.map(u => <option key={u} value={u}>{u}</option>)}
                                            </optgroup>
                                            <optgroup label="Mass">
                                                {massUnitsList.map(u => <option key={u} value={u}>{u}</option>)}
                                            </optgroup>
                                        </select>
                                    </div>
                                </div>
                        
                                <div>
                                    <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Time Elapsed</label>
                                    <div className="flex gap-2 mt-1">
                                        <input type="number" value={timeElapsed} onChange={e => setTimeElapsed(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                        <select value={timeUnit} onChange={e => setTimeUnit(e.target.value)} className="p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600">
                                            {timeUnitsList.map(u => <option key={u} value={u}>{u}</option>)}
                                        </select>
                                    </div>
                                </div>
                        
                                <button onClick={handleCalculate} disabled={isLoading} className="w-full md:col-span-4 py-3 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition disabled:bg-sky-800 disabled:cursor-wait shadow-md">
                                    {isLoading ? 'Running Bateman Simulation...' : 'Calculate Chain'}
                                </button>
                            </div>
                        
                            {error && <p className="text-red-500 text-sm text-center mt-4">{error}</p>}
                        
                            <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                                {/* Chart Section */}
                                <div className="min-h-[300px]">
                                    {chartData ? (
                                        <>
                                            <div className="flex justify-between items-center mb-2">
                                                <button onClick={handleExportCSV} className="text-xs font-bold text-sky-600 hover:underline flex items-center gap-1"><Icon path={ICONS.database} className="w-3 h-3" /> Download Data (CSV)</button>
                                                <label className="flex items-center gap-2 text-sm cursor-pointer">
                                                    <input type="checkbox" checked={useLogScale} onChange={() => setUseLogScale(!useLogScale)} className="form-checkbox h-4 w-4 rounded text-sky-600" />
                                                    Use Log Scale
                                                </label>
                                            </div>
                                            <SeriesDecayChart chartData={chartData} useLogScale={useLogScale} theme={theme} />
                                        </>
                                    ) : (
                                        <div className="flex items-center justify-center h-full bg-slate-100 dark:bg-slate-800/50 rounded-lg border border-dashed border-slate-300 dark:border-slate-700">
                                            <p className="text-slate-500">Chart will display here</p>
                                        </div>
                                    )}
                                </div>
                        
                                {/* Results Table Section */}
                                <div className="max-h-[400px] overflow-y-auto pr-2 custom-scrollbar">
                                    <h3 className="text-lg font-semibold mb-2">Results at {timeElapsed} {timeUnit}</h3>
                                    {results.items && results.items.length > 0 ? (
                                        <table className="w-full text-sm text-left">
                                            <thead className="bg-slate-100 dark:bg-slate-700 sticky top-0 z-10">
                                                <tr><th className="p-2">Nuclide</th><th className="p-2 text-right">Activity ({results.displayUnit})</th></tr>
                                            </thead>
                                            <tbody>
                                                <tr className="bg-sky-50 dark:bg-sky-900/30 font-bold border-b border-sky-200 dark:border-sky-800">
                                                    <td className="p-2">TOTAL ACTIVITY</td>
                                                    <td className="p-2 text-right">{results.total.toExponential(3)}</td>
                                                </tr>
                                                {results.items.map(r => (
                                                    <tr key={r.name} className="border-b border-slate-200 dark:border-slate-700 hover:bg-slate-50 dark:hover:bg-slate-700/50">
                                                        <td className="p-2 font-medium">
                                                            <button
                                                                onClick={() => handleRowClick(r.name)}
                                                                className="text-sky-600 dark:text-sky-400 hover:underline text-left"
                                                            >
                                                                {r.name}
                                                            </button>
                                                        </td>
                                                        <td className="p-2 text-right font-mono text-slate-700 dark:text-slate-300">{r.activity.toExponential(3)}</td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    ) : <p className="text-center text-slate-500 dark:text-slate-400 py-4">No results to display.</p>}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };
            
            /**
            * @description A React component that renders a line chart for a decay series using Chart.js.
            */
            const SeriesDecayChart = ({ chartData, useLogScale, theme }) => {
            const chartRef = React.useRef(null);
            const chartInstance = React.useRef(null);
            
            React.useEffect(() => {
            if (chartInstance.current) {
                chartInstance.current.destroy();
            }
            
            if (chartRef.current && chartData) {
            
                const isDarkMode = theme === 'dark';
                const textColor = isDarkMode ? '#cbd5e1' : '#334155';
                const gridColor = isDarkMode ? '#334155' : '#e2e8f0';
            
                const ctx = chartRef.current.getContext('2d');
            
                let safeMin = undefined;
                if (useLogScale && chartData.datasets) {
                    const allValues = chartData.datasets.flatMap(d => d.data);
                    const maxVal = Math.max(...allValues);
                    
                    if (maxVal > 0) {
                        // Use 5 orders of magnitude (standard 5-cycle log paper)
                        safeMin = maxVal * 1e-5; 
                    } else {
                        safeMin = 1e-5;
                    }
                }
            
                if (chartData.datasets && chartData.datasets.length > 0) {
                    // Assuming Total Activity is always index 0 (unshifted in parent)
                    if (chartData.datasets[0].label === 'Total Activity') {
                        chartData.datasets[0].borderColor = theme === 'dark' ? '#ffffff' : '#000000';
                    }
                }
            
                chartInstance.current = new Chart(ctx, {
                    type: 'line',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: { boxWidth: 20, font: { size: 10 }, color: textColor }
                            },
                            title: {
                                display: true,
                                text: 'Decay Series Activity Over Time',
                                color: textColor
                            },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: `Time (${chartData.timeUnit})`, color: textColor },
                                ticks: { maxRotation: 0, autoSkip: true, autoSkipPadding: 20, color: textColor },
                                grid: { color: gridColor }
                            },
                            y: {
                                type: useLogScale ? 'logarithmic' : 'linear',
                                title: { display: true, text: `Activity (${useLogScale ? 'Log Scale' : 'Linear Scale'})`, color: textColor },
                                min: safeMin,
                                beginAtZero: !useLogScale,
                                ticks: {
                                    color: textColor,
                                    callback: function(value) {
                                        if (value !== 0 && (Math.abs(value) < 1e-3 || Math.abs(value) >= 1e4)) {
                                            return value.toExponential(1);
                                        }
                                        return value.toLocaleString();
                                    }
                                },
                                grid: { color: gridColor }
                            }
                        },
                        elements: {
                            line: { tension: 0 } // Disable curves to prevent wavy artifacts
                        }
                    }
                });
            }
            
            return () => {
                if (chartInstance.current) { chartInstance.current.destroy(); }
            };
            }, [chartData, useLogScale, theme]);
            
            const handleExport = () => {
            if (chartInstance.current) {
                const link = document.createElement('a');
                link.href = chartInstance.current.toBase64Image();
                link.download = 'decay-chart.png';
                link.click();
            }
            };
            
            return (
            <div className="mt-4">
                <div className="h-64">
                    <canvas ref={chartRef}></canvas>
                </div>
                <div className="text-center mt-2">
                    <button
                        onClick={handleExport}
                        className="px-3 py-1 text-xs bg-slate-200 dark:bg-slate-700 rounded-md hover:bg-sky-100 dark:hover:bg-sky-800 transition font-semibold"
                    >
                        Export as PNG
                    </button>
                </div>
            </div>
            );
            };
            
            /**
            * @description A combined calculator for mass-to-activity conversions and for calculating
            * specific activity from first principles.
            */
            
            // --- 1. Specific Activity Calculator (Child Component) ---
            const SpecificActivityModule = ({ radionuclides, atomicWeight, setAtomicWeight, halfLifeValue, setHalfLifeValue, halfLifeUnit, setHalfLifeUnit, result, setResult, error, setError }) => {
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                const { settings } = React.useContext(SettingsContext);
                
                const AVOGADRO = 6.02214076e23;
                const timeUnits = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600 };
                
                const handleNuclideSelect = (symbol) => {
                    const n = radionuclides.find(r => r.symbol === symbol);
                    if (n && n.halfLife !== 'Stable') {
                        const match = n.symbol.match(/-(\d+)/);
                        if (match) setAtomicWeight(match[1]);
                        const hlSec = parseHalfLifeToSeconds(n.halfLife);
                        const bestUnit = getBestHalfLifeUnit(hlSec);
                        setHalfLifeUnit(bestUnit);
                        setHalfLifeValue((hlSec / timeUnits[bestUnit]).toPrecision(4));
                    }
                };
                
                React.useEffect(() => {
                    try {
                        setError('');
                        const aw = parseFloat(atomicWeight);
                        const t_val = parseFloat(halfLifeValue);
                        
                        if (isNaN(aw) || isNaN(t_val) || aw <= 0 || t_val <= 0) {
                            setResult(null); return;
                        }
                        
                        const t_seconds = t_val * timeUnits[halfLifeUnit];
                        const sa_Bq_g = (Math.log(2) * AVOGADRO) / (t_seconds * aw);
                        
                        const valToFormat = settings.unitSystem === 'si' ? sa_Bq_g : sa_Bq_g / 3.7e10;
                        const configKey = settings.unitSystem === 'si' ? 'activity_si' : 'activity_conventional';
                        
                        const formatted = formatSensibleUnit(valToFormat, configKey);
            
                        setResult({
                            sa_Bq_g: sa_Bq_g,
                            display: `${formatted.value} ${formatted.unit}/g`
                        });
                    
                    } catch (e) { setError(e.message); setResult(null); }
                }, [atomicWeight, halfLifeValue, halfLifeUnit, settings.unitSystem]);
                
                const handleSave = () => {
                    if(result) {
                        addHistory({ id: Date.now(), type: 'Specific Activity', icon: ICONS.activity, inputs: `AW: ${atomicWeight}, T½: ${halfLifeValue} ${halfLifeUnit}`, result: result.display, view: VIEWS.ACTIVITY_MASS });
                        addToast("Saved!");
                    }
                };
                
                return (
                    <div className="space-y-4 animate-fade-in">
                        <div className="flex justify-end mb-2">
                            <div className="w-full sm:w-1/2">
                                <SearchableSelect options={radionuclides} onSelect={handleNuclideSelect} placeholder="Auto-fill from DB..." />
                            </div>
                        </div>
                        
                        <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                            <div>
                                <label className="block text-sm font-medium">Atomic Weight (g/mol)</label>
                                <input type="number" value={atomicWeight} onChange={e => setAtomicWeight(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" placeholder="e.g. 238" />
                            </div>
                            <div>
                                <label className="block text-sm font-medium">Half-Life</label>
                                <div className="flex">
                                    <input type="number" value={halfLifeValue} onChange={e => setHalfLifeValue(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" />
                                    <select value={halfLifeUnit} onChange={e => setHalfLifeUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-sm">
                                        {Object.keys(timeUnits).map(u => <option key={u} value={u}>{u}</option>)}
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        {result && (
                            <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in shadow-sm relative">
                                <div className="absolute top-2 right-2"><button onClick={handleSave}><Icon path={ICONS.notepad} className="w-5 h-5 text-slate-400 hover:text-sky-600"/></button></div>
                                <p className="text-xs uppercase font-bold text-slate-500 mb-2">Theoretical Specific Activity</p>
                                <div className="flex items-center justify-center gap-2">
                                    <p className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.display}</p>
                                    <CopyButton textToCopy={result.display} />
                                </div>
                            </div>
                        )}
                    </div>
                );
            };
            
            // --- 2. Mass <-> Activity Converter (Child Component) ---
            const MassActivityModule = ({ radionuclides, selectedNuclide, setSelectedNuclide, mass, setMass, massUnit, setMassUnit, activity, setActivity, activityUnit, setActivityUnit, error, setError, activityUnits }) => {
                const { settings } = React.useContext(SettingsContext);
                
                const [useManualSA, setUseManualSA] = React.useState(false);
                const [manualSA, setManualSA] = React.useState('');
                const [manualSAUnit, setManualSAUnit] = React.useState(settings.unitSystem === 'si' ? 'Bq/g' : 'Ci/g');
                
                // New State to track which field was last edited by the user
                const [lastEdited, setLastEdited] = React.useState('mass'); // 'mass' or 'activity'
                
                const massUnits = { 'µg': 1e-6, 'mg': 1e-3, 'g': 1, 'kg': 1000, 'lb': 453.592 };
                const activityFactorsBq = { 'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'TBq': 1e12, 'Ci': 3.7e10, 'mCi': 3.7e7, 'µCi': 3.7e4, 'kCi': 3.7e13 };
                const saUnitFactors = { 'Bq/g': 1, 'kBq/g': 1e3, 'MBq/g': 1e6, 'GBq/g': 1e9, 'Ci/g': 3.7e10, 'mCi/g': 3.7e7, 'µCi/g': 37000 };
                
                const getOrCalculateSA = (nuclide) => {
                    if (useManualSA) {
                        const val = parseFloat(manualSA);
                        if (isNaN(val) || val <= 0) return { value: 0 };
                        return { value: val * saUnitFactors[manualSAUnit] };
                    }
                    if (!nuclide) return { value: 0 };
                    const parsedSA = parseSpecificActivity(nuclide.specificActivity);
                    if (parsedSA > 0) return { value: parsedSA };
                    
                    const seconds = parseHalfLifeToSeconds(nuclide.halfLife);
                    if (seconds === 0 || seconds === Infinity) return { value: 0 };
                    const match = nuclide.symbol.match(/-(\d+)/);
                    if (!match) return { value: 0 };
                    const atomicMass = parseInt(match[1], 10);
                    const avogadro = 6.02214076e23;
                    return { value: (Math.log(2) * avogadro) / (seconds * atomicMass) };
                };
                
                const nuclidesWithSA = React.useMemo(() => radionuclides.filter(r => r.halfLife !== 'Stable').sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
                const [activeSA, setActiveSA] = React.useState(0);
                const [moles, setMoles] = React.useState(null);
                
                React.useEffect(() => {
                    const { value } = getOrCalculateSA(selectedNuclide);
                    setActiveSA(value);
                    
                    // If value is 0, we can't calculate anything
                    if (value <= 0) return;
            
                    // Recalculate the dependent field based on what the user last touched
                    if (lastEdited === 'mass' && mass) {
                        calculateActivity(parseFloat(mass), massUnit, activityUnit, value);
                    } else if (lastEdited === 'activity' && activity) {
                        calculateMass(parseFloat(activity), activityUnit, massUnit, value);
                    }
                    
                }, [selectedNuclide, useManualSA, manualSA, manualSAUnit]); // Keep dependency array clean
                
                const calculateActivity = (massVal, mUnit, aUnit, saVal = activeSA) => {
                    if (isNaN(massVal) || massVal < 0) { setActivity(''); setMoles(null); return; }
                    const massInG = massVal * massUnits[mUnit];
                    if (selectedNuclide) {
                        const match = selectedNuclide.symbol.match(/-(\d+)/);
                        if (match) { const aw = parseInt(match[1]); setMoles(massInG / aw); }
                    }
                    if (saVal > 0) {
                        const activityInBq = massInG * saVal;
                        setActivity((activityInBq / activityFactorsBq[aUnit]).toPrecision(4));
                    }
                };
                
                const calculateMass = (actVal, aUnit, mUnit, saVal = activeSA) => {
                    if (isNaN(actVal) || actVal < 0) { setMass(''); setMoles(null); return; }
                    if (saVal > 0) {
                        const activityInBq = actVal * activityFactorsBq[aUnit];
                        const massInG = activityInBq / saVal;
                        setMass((massInG / massUnits[mUnit]).toPrecision(4));
                        if (selectedNuclide) {
                            const match = selectedNuclide.symbol.match(/-(\d+)/);
                            if (match) { const aw = parseInt(match[1]); setMoles(massInG / aw); }
                        }
                    }
                };
                
                return (
                    <div className="space-y-4 animate-fade-in">
                        <div className="flex justify-between items-center">
                            <p className="text-sm text-slate-600 dark:text-slate-400">Convert between mass and activity.</p>
                            <label className="flex items-center gap-2 text-xs font-semibold cursor-pointer text-sky-600 dark:text-sky-400">
                                <input type="checkbox" checked={useManualSA} onChange={() => setUseManualSA(!useManualSA)} className="form-checkbox h-3 w-3 rounded text-sky-600" />
                                Manual SA
                            </label>
                        </div>
                        
                        {useManualSA ? (
                            <div className="p-3 bg-slate-50 dark:bg-slate-800/50 rounded border border-slate-200 dark:border-slate-700">
                                <label className="block text-xs font-medium mb-1">Specific Activity</label>
                                <div className="flex">
                                    <input type="number" value={manualSA} onChange={e => setManualSA(e.target.value)} className="w-full p-2 rounded-l-md bg-white dark:bg-slate-700 text-sm" placeholder="e.g. 3.6e10"/>
                                    <select value={manualSAUnit} onChange={e => setManualSAUnit(e.target.value)} className="p-2 rounded-r-md bg-slate-100 dark:bg-slate-600 text-xs">
                                        {Object.keys(saUnitFactors).map(u => <option key={u} value={u}>{u}</option>)}
                                    </select>
                                </div>
                            </div>
                        ) : (
                            <div className="min-h-[42px]">
                                {selectedNuclide ? ( <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setSelectedNuclide(null)} /> ) : ( <SearchableSelect options={nuclidesWithSA} onSelect={(s) => { const n = radionuclides.find(r => r.symbol === s); setSelectedNuclide(n); }} placeholder="Search for a radionuclide..."/> )}
                            </div>
                        )}
                        
                        {/* SA Display */}
                        {!useManualSA && selectedNuclide && activeSA > 0 && (
                            <div className="flex justify-between items-center text-xs text-slate-500 dark:text-slate-400 bg-slate-50 dark:bg-slate-800/50 p-2 rounded border border-slate-200 dark:border-slate-700">
                                <span>Specific Activity: <strong>{formatWithUnitSystem(activeSA, 'activity', settings).value} {formatWithUnitSystem(activeSA, 'activity', settings).unit}/g</strong></span>
                            </div>
                        )}
                        
                        <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                            <div>
                                <label className="block text-sm font-semibold mb-1">Mass</label>
                                <div className="flex">
                                    <input 
                                        type="number" 
                                        value={mass} 
                                        onChange={(e) => { 
                                            setLastEdited('mass'); // Mark Mass as dominant
                                            setMass(e.target.value); 
                                            calculateActivity(parseFloat(e.target.value), massUnit, activityUnit); 
                                        }} 
                                        className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"
                                    />
                                    <select value={massUnit} onChange={(e) => { setMassUnit(e.target.value); calculateActivity(parseFloat(mass), e.target.value, activityUnit); }} className="p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(massUnits).map(u => <option key={u} value={u}>{u}</option>)}</select>
                                </div>
                            </div>
                            <div className="text-center text-xl text-slate-400">⇅</div>
                            <div>
                                <label className="block text-sm font-semibold mb-1">Activity</label>
                                <div className="flex">
                                    <input 
                                        type="number" 
                                        value={activity} 
                                        onChange={(e) => { 
                                            setLastEdited('activity'); // Mark Activity as dominant
                                            setActivity(e.target.value); 
                                            calculateMass(parseFloat(e.target.value), activityUnit, massUnit); 
                                        }} 
                                        className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"
                                    />
                                    <select value={activityUnit} onChange={(e) => { setActivityUnit(e.target.value); calculateMass(parseFloat(activity), e.target.value, massUnit); }} className="p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                                </div>
                            </div>
                        </div>
                        {moles !== null && ( <div className="mt-2 text-center"><p className="text-xs font-mono text-slate-500 dark:text-slate-400">Substance Amount: <strong>{moles.toExponential(4)} mol</strong></p></div> )}
                    </div>
                );
            };
            
            // --- 3. Dose Rate <-> Activity Calculator (Child Component) ---
            const ActivityFromDoseRate = ({ radionuclides, nuclideSymbol, setNuclideSymbol, doseRate, setDoseRate, doseRateUnit, setDoseRateUnit, distance, setDistance, distanceUnit, setDistanceUnit, result, setResult, error, setError, doseRateUnits, distanceUnits }) => {
                const { settings } = React.useContext(SettingsContext);
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                
                const [useManualGamma, setUseManualGamma] = React.useState(false);
                const [manualGamma, setManualGamma] = React.useState('');
                const [transmission, setTransmission] = React.useState('1.0');
                const [usedGamma, setUsedGamma] = React.useState(null);
                
                const gammaNuclides = React.useMemo(() => radionuclides.filter(n => n.gammaConstant).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
                const selectedNuclide = React.useMemo(() => gammaNuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, gammaNuclides]);
                
                const doseRateFactors_mrem_hr = { 'µrem/hr': 0.001, 'mrem/hr': 1, 'rem/hr': 1000, 'µSv/hr': 0.1, 'mSv/hr': 100, 'Sv/hr': 100000 };
                const distanceFactors_m = { 'mm': 0.001, 'cm': 0.01, 'm': 1, 'in': 0.0254, 'ft': 0.3048 };
                
                React.useEffect(() => {
                    try {
                        setError('');
                        let gammaConstant = 0;
                        if (useManualGamma) {
                            gammaConstant = parseFloat(manualGamma);
                            if (isNaN(gammaConstant) || gammaConstant <= 0) { setResult(null); return; }
                        } else {
                            if (!selectedNuclide) { setResult(null); return; }
                            gammaConstant = parseFloat(selectedNuclide.gammaConstant);
                        }
                        setUsedGamma(gammaConstant);
                        
                        const doseRateVal = parseFloat(doseRate);
                        const distanceVal = parseFloat(distance);
                        const transVal = parseFloat(transmission);
                        
                        if (isNaN(doseRateVal) || isNaN(distanceVal) || isNaN(transVal) || doseRateVal <= 0 || distanceVal <= 0 || transVal <= 0) {
                            setResult(null); return;
                        }
                        
                        const doseRate_R_hr = (doseRateVal * doseRateFactors_mrem_hr[doseRateUnit]) / 1000;
                        const distance_m = distanceVal * distanceFactors_m[distanceUnit];
                        const activity_Ci = (doseRate_R_hr * Math.pow(distance_m, 2)) / (gammaConstant * transVal);
                        
                        setResult({ rawActivity_Ci: activity_Ci });
                    } catch (e) { setError(e.message); setResult(null); }
                }, [selectedNuclide, useManualGamma, manualGamma, doseRate, doseRateUnit, distance, distanceUnit, transmission]);
                
                const handleSaveToHistory = () => {
                    if (result) {
                        const activityInBase = settings.unitSystem === 'si' ? result.rawActivity_Ci * 3.7e10 : result.rawActivity_Ci;
                        const configKey = settings.unitSystem === 'si' ? 'activity_si' : 'activity_conventional';
                        const formattedResult = formatSensibleUnit(activityInBase, configKey);
                        const sourceName = useManualGamma ? `Γ=${manualGamma}` : selectedNuclide.symbol;
                        addHistory({ id: Date.now(), type: 'Activity from Dose', icon: ICONS.activity, inputs: `${doseRate} ${doseRateUnit} @ ${distance} ${distanceUnit}`, result: `${formattedResult.value} ${formattedResult.unit} (${sourceName})`, view: VIEWS.ACTIVITY_MASS });
                        addToast("Saved!");
                    }
                };
                
                return (
                    <div className="space-y-4 animate-fade-in">
                        <div className="flex justify-between items-center">
                            <p className="text-sm text-slate-600 dark:text-slate-400">Calculates activity from gamma dose rate.</p>
                            <label className="flex items-center gap-2 text-xs font-semibold cursor-pointer text-sky-600 dark:text-sky-400">
                                <input type="checkbox" checked={useManualGamma} onChange={() => setUseManualGamma(!useManualGamma)} className="form-checkbox h-3 w-3 rounded text-sky-600" />
                                Manual Gamma
                            </label>
                        </div>
                        
                        <div>
                            {useManualGamma ? (
                                <div className="animate-fade-in p-3 bg-slate-50 dark:bg-slate-800/50 rounded border border-slate-200 dark:border-slate-700">
                                    <label className="block text-xs font-medium mb-1">Gamma Constant (Γ)</label>
                                    <div className="relative">
                                        <input type="number" value={manualGamma} onChange={e => setManualGamma(e.target.value)} className="w-full p-2 rounded bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600 text-sm" placeholder="R·m²/hr·Ci" />
                                    </div>
                                </div>
                            ) : (
                                <div className="mt-1">
                                    {selectedNuclide ? ( <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> ) : ( <SearchableSelect options={gammaNuclides} onSelect={setNuclideSymbol} placeholder="Select a gamma emitter..." /> )}
                                </div>
                            )}
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label className="block text-sm font-medium">Dose Rate</label>
                                <div className="flex">
                                    <input type="number" value={doseRate} onChange={e => setDoseRate(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                                    <select value={doseRateUnit} onChange={e => setDoseRateUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{doseRateUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                                </div>
                            </div>
                            <div>
                                <label className="block text-sm font-medium">Distance</label>
                                <div className="flex">
                                    <input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                                    <select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                                </div>
                            </div>
                            <div className="md:col-span-2">
                                <label className="block text-sm font-medium mb-1">Transmission (0-1)</label>
                                <input type="number" step="0.1" min="0" max="1" value={transmission} onChange={e => setTransmission(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm" placeholder="e.g., 0.5 for 1 HVL"/>
                            </div>
                        </div>
                        
                        {result && (() => {
                            const activityInBase = settings.unitSystem === 'si' ? result.rawActivity_Ci * 3.7e10 : result.rawActivity_Ci;
                            const configKey = settings.unitSystem === 'si' ? 'activity_si' : 'activity_conventional';
                            const formattedResult = formatSensibleUnit(activityInBase, configKey);
                            return (
                                <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in shadow-sm relative">
                                    <div className="flex justify-end absolute top-2 right-2"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5" /></button></div>
                                    <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Calculated Source Activity</p>
                                    <div className="flex items-center justify-center mt-2">
                                        <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{formattedResult.value}</p>
                                        <CopyButton textToCopy={formattedResult.value} />
                                    </div>
                                    <p className="text-md font-medium text-slate-600 dark:text-slate-300">{formattedResult.unit}</p>
                                    <div className="mt-3 pt-3 border-t border-slate-200 dark:border-slate-600 text-xs text-slate-500 dark:text-slate-400">Used Γ: <strong>{usedGamma}</strong> R·m²/hr·Ci</div>
                                </div>
                            );
                        })()}
                    </div>
                );
            };
            
            // --- 4. Main Container: Activity & Mass Tools ---
            const ActivityAndMassTools = ({ radionuclides }) => {
                const { settings } = React.useContext(SettingsContext);
                
                // --- State: Calculator Selection ---
                const MODE_MASS_ACTIVITY = 'massActivity';
                const MODE_SPECIFIC_ACTIVITY = 'specificActivity';
                const MODE_FROM_DOSE = 'fromDose';
                const [activeTool, setActiveTool] = React.useState(MODE_MASS_ACTIVITY);
                
                // --- State: Mass/Activity Converter ---
                const [ma_selectedNuclide, setMa_selectedNuclide] = React.useState(null);
                const [ma_mass, setMa_mass] = React.useState('1');
                const [ma_massUnit, setMa_massUnit] = React.useState('g');
                const [ma_activity, setMa_activity] = React.useState('');
                const [ma_activityUnit, setMa_activityUnit] = React.useState(settings.unitSystem === 'si' ? 'Bq' : 'Ci');
                const [ma_error, setMa_error] = React.useState('');
                
                // --- State: Specific Activity ---
                const [sa_atomicWeight, setSa_atomicWeight] = React.useState('238');
                const [sa_halfLife, setSa_halfLife] = React.useState('4.468e9');
                const [sa_halfLifeUnit, setSa_halfLifeUnit] = React.useState('years');
                const [sa_result, setSa_result] = React.useState(null);
                const [sa_error, setSa_error] = React.useState('');
                
                // --- State: Activity from Dose ---
                const [ad_symbol, setAd_symbol] = React.useState('');
                const [ad_doseRate, setAd_doseRate] = React.useState('10');
                const [ad_doseRateUnit, setAd_doseRateUnit] = React.useState('mrem/hr');
                const [ad_distance, setAd_distance] = React.useState('1');
                const [ad_distanceUnit, setAd_distanceUnit] = React.useState('ft');
                const [ad_result, setAd_result] = React.useState(null);
                const [ad_error, setAd_error] = React.useState('');
                
                // Unit Lists
                const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci', 'kCi'], [settings.unitSystem]);
                const doseRateUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['µSv/hr', 'mSv/hr', 'Sv/hr'] : ['µrem/hr', 'mrem/hr', 'rem/hr', 'mR/hr', 'R/hr'], [settings.unitSystem]);
                const distanceUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['cm', 'm'] : ['in', 'ft', 'm'], [settings.unitSystem]);
                
                // Cleanup on unmount
                const handleClear = () => {
                    if(activeTool === MODE_MASS_ACTIVITY) { setMa_mass('1'); setMa_activity(''); setMa_selectedNuclide(null); }
                    else if(activeTool === MODE_SPECIFIC_ACTIVITY) { setSa_atomicWeight('238'); setSa_halfLife('4.468e9'); setSa_result(null); }
                    else { setAd_doseRate('10'); setAd_distance('1'); setAd_result(null); setAd_symbol(''); }
                };
                
                return (
                    <div className="p-4 animate-fade-in">
                        <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-bold text-slate-800 dark:text-white">Activity & Mass Tools</h2>
                                <ClearButton onClick={handleClear} />
                            </div>
                            
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-4">
                                <button 
                                    onClick={() => setActiveTool(MODE_MASS_ACTIVITY)} 
                                    className={`p-2 rounded-md text-sm font-semibold transition-colors ${
                                        activeTool === MODE_MASS_ACTIVITY 
                                        ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' 
                                        : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300/50 dark:hover:bg-slate-600'
                                    }`}
                                >
                                    Mass ↔ Activity
                                </button>
                                <button 
                                    onClick={() => setActiveTool(MODE_SPECIFIC_ACTIVITY)} 
                                    className={`p-2 rounded-md text-sm font-semibold transition-colors ${
                                        activeTool === MODE_SPECIFIC_ACTIVITY 
                                        ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' 
                                        : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300/50 dark:hover:bg-slate-600'
                                    }`}
                                >
                                    Specific Activity
                                </button>
                                <button 
                                    onClick={() => setActiveTool(MODE_FROM_DOSE)} 
                                    className={`p-2 rounded-md text-sm font-semibold transition-colors ${
                                        activeTool === MODE_FROM_DOSE 
                                        ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' 
                                        : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300/50 dark:hover:bg-slate-600'
                                    }`}
                                >
                                    Find Source Activity
                                </button>
                            </div>
                            
                            {activeTool === MODE_MASS_ACTIVITY && (
                                <MassActivityModule
                                    radionuclides={radionuclides}
                                    selectedNuclide={ma_selectedNuclide} setSelectedNuclide={setMa_selectedNuclide}
                                    mass={ma_mass} setMass={setMa_mass}
                                    massUnit={ma_massUnit} setMassUnit={setMa_massUnit}
                                    activity={ma_activity} setActivity={setMa_activity}
                                    activityUnit={ma_activityUnit} setActivityUnit={setMa_activityUnit}
                                    error={ma_error} setError={setMa_error}
                                    activityUnits={activityUnits}
                                />
                            )}
                            
                            {activeTool === MODE_SPECIFIC_ACTIVITY && (
                                <SpecificActivityModule
                                    radionuclides={radionuclides}
                                    atomicWeight={sa_atomicWeight} setAtomicWeight={setSa_atomicWeight}
                                    halfLifeValue={sa_halfLife} setHalfLifeValue={setSa_halfLife}
                                    halfLifeUnit={sa_halfLifeUnit} setHalfLifeUnit={setSa_halfLifeUnit}
                                    result={sa_result} setResult={setSa_result}
                                    error={sa_error} setError={setSa_error}
                                />
                            )}
                            
                            {activeTool === MODE_FROM_DOSE && (
                                <ActivityFromDoseRate
                                    radionuclides={radionuclides}
                                    nuclideSymbol={ad_symbol} setNuclideSymbol={setAd_symbol}
                                    doseRate={ad_doseRate} setDoseRate={setAd_doseRate}
                                    doseRateUnit={ad_doseRateUnit} setDoseRateUnit={setAd_doseRateUnit}
                                    distance={ad_distance} setDistance={setAd_distance}
                                    distanceUnit={ad_distanceUnit} setDistanceUnit={setAd_distanceUnit}
                                    result={ad_result} setResult={setAd_result}
                                    error={ad_error} setError={setAd_error}
                                    doseRateUnits={doseRateUnits} distanceUnits={distanceUnits}
                                />
                            )}
                        </div>
                    </div>
                );
            };
            
            /**
            * @description A calculator to determine the activities of a parent-daughter pair over time,
            * and to analyze the type of equilibrium present based on their half-lives.
            * Now includes Auto-Branching logic and Secular Equilibrium shortcuts.
            */

            const EquilibriumCalculator = ({ radionuclides, theme }) => {
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                const { settings } = React.useContext(SettingsContext);
                
                // --- STATE ---
                const [parentNuclide, setParentNuclide] = React.useState(() => {
                    const savedSymbol = localStorage.getItem('equilibrium_parentSymbol');
                    if (!savedSymbol) return null;
                    return radionuclides.find(n => n.symbol === savedSymbol) || null;
                });
                
                // NEW: Branching State
                const [decayPaths, setDecayPaths] = React.useState([]);
                const [selectedPathIndex, setSelectedPathIndex] = React.useState(0);
                const [daughterNuclide, setDaughterNuclide] = React.useState(null);
                
                const [initialActivity, setInitialActivity] = React.useState(() => localStorage.getItem('equilibrium_initialActivity') || '100');
                const [initialDaughterActivity, setInitialDaughterActivity] = React.useState(() => localStorage.getItem('equilibrium_initialDaughterActivity') || '0');
                const [branchingFraction, setBranchingFraction] = React.useState(() => localStorage.getItem('equilibrium_branchingFraction') || '1.0');
                
                const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['MBq', 'GBq', 'TBq', 'Bq'] : ['mCi', 'Ci', 'µCi'], [settings.unitSystem]);
                const [activityUnit, setActivityUnit] = React.useState(() => localStorage.getItem('equilibrium_activityUnit') || activityUnits[0]);
                
                const [timeElapsed, setTimeElapsed] = React.useState(() => localStorage.getItem('equilibrium_timeElapsed') || '10');
                const [timeUnit, setTimeUnit] = React.useState(() => localStorage.getItem('equilibrium_timeUnit') || 'days');

                const [result, setResult] = React.useState(null);
                const [chartData, setChartData] = React.useState(null);
                const [error, setError] = React.useState('');
                const [analysis, setAnalysis] = React.useState(null);
                const [useLogScale, setUseLogScale] = React.useState(() => JSON.parse(localStorage.getItem('equilibrium_useLogScale')) || false);
                
                const timeUnitsOrdered = ['minutes', 'hours', 'days', 'years'];

                // --- EFFECTS ---
                React.useEffect(() => {
                    localStorage.setItem('equilibrium_parentSymbol', parentNuclide ? parentNuclide.symbol : '');
                    localStorage.setItem('equilibrium_initialActivity', initialActivity);
                    localStorage.setItem('equilibrium_initialDaughterActivity', initialDaughterActivity);
                    localStorage.setItem('equilibrium_branchingFraction', branchingFraction);
                    localStorage.setItem('equilibrium_activityUnit', activityUnit);
                    localStorage.setItem('equilibrium_timeElapsed', timeElapsed);
                    localStorage.setItem('equilibrium_timeUnit', timeUnit);
                    localStorage.setItem('equilibrium_useLogScale', JSON.stringify(useLogScale));
                }, [parentNuclide, initialActivity, initialDaughterActivity, branchingFraction, activityUnit, timeElapsed, timeUnit, useLogScale]);
                
                React.useEffect(() => {
                    if (!activityUnits.includes(activityUnit)) setActivityUnit(activityUnits[0]);
                }, [settings.unitSystem]);
                
                // Filter for Parents
                const parentNuclides = React.useMemo(() => {
                    return radionuclides.filter(parent => {
                        if (!parent.daughter || parent.halfLife === 'Stable') return false;
                        const daughterName = parent.daughter.split('(')[0].split('/')[0].split(' or ')[0].trim();
                        const normDaughter = normalizeString(daughterName);
                        const daughter = radionuclides.find(n => normalizeString(n.name) === normDaughter || normalizeString(n.symbol) === normDaughter);
                        return daughter && daughter.halfLife !== 'Stable';
                    }).sort((a, b) => a.name.localeCompare(b.name));
                }, [radionuclides]);
                
                // --- 1. HANDLE PARENT CHANGE & PARSE PATHS ---
                const handleParentChange = (symbol) => {
                    const parent = parentNuclides.find(p => p.symbol === symbol);
                    setResult(null); setChartData(null); setError(''); setParentNuclide(parent || null);
                };

                React.useEffect(() => {
                    if (parentNuclide) {
                        const dStr = parentNuclide.daughter || '';
                        const rawFraction = parentNuclide.branchingFraction || 1.0;
                        let newPaths = [];

                        if (dStr.includes(' or ')) {
                            const parts = dStr.split(' or ');
                            const path1Name = parts[0].split('(')[0].trim();
                            const path2Name = parts[1].split('(')[0].trim();

                            newPaths.push({ name: path1Name, fraction: rawFraction, label: parts[0].trim() });
                            const remainder = rawFraction < 1.0 ? (1.0 - rawFraction) : 0;
                            newPaths.push({ name: path2Name, fraction: parseFloat(remainder.toFixed(4)), label: parts[1].trim() });
                            
                            setDecayPaths(newPaths);
                            setSelectedPathIndex(0);
                            setBranchingFraction(newPaths[0].fraction.toString());
                        } 
                        else {
                            const cleanName = dStr.split('(')[0].trim();
                            newPaths.push({ name: cleanName, fraction: rawFraction, label: dStr });
                            setDecayPaths(newPaths);
                            setSelectedPathIndex(0);
                            
                            // Legacy overrides
                            if (parentNuclide.symbol === 'Mo-99' && !parentNuclide.branchingFraction) {
                                setBranchingFraction('0.875');
                            } else {
                                setBranchingFraction(rawFraction.toString());
                            }
                        }
                    } else {
                        setDecayPaths([]);
                        setDaughterNuclide(null);
                    }
                }, [parentNuclide]);

                // --- 2. HANDLE PATH CHANGE ---
                const handlePathChange = (e) => {
                    const idx = parseInt(e.target.value);
                    setSelectedPathIndex(idx);
                    if (decayPaths[idx]) {
                        setBranchingFraction(decayPaths[idx].fraction.toString());
                    }
                };

                // --- 3. RESOLVE DAUGHTER DATA & ANALYZE ---
                React.useEffect(() => {
                    if (!parentNuclide || decayPaths.length === 0) {
                        setAnalysis(null); setDaughterNuclide(null); return;
                    }
                    
                    const activePath = decayPaths[selectedPathIndex];
                    if(!activePath) return;

                    const normDaughter = normalizeString(activePath.name);
                    const foundDaughter = radionuclides.find(n => normalizeString(n.name) === normDaughter || normalizeString(n.symbol) === normDaughter);
                    
                    if (!foundDaughter) {
                        setAnalysis({ type: 'Analysis Error', message: `Data for ${activePath.name} not found in database.` });
                        setDaughterNuclide(null);
                        return;
                    }
                    setDaughterNuclide(foundDaughter);
                    
                    const T1_seconds = parseHalfLifeToSeconds(parentNuclide.halfLife);
                    const T2_seconds = parseHalfLifeToSeconds(foundDaughter.halfLife);
                    
                    let type, message, theoreticalRatio = null, timeToEq = null, timeToMax = null;
                    
                    if (T1_seconds < T2_seconds) {
                        type = 'No Equilibrium';
                        message = `Parent half-life (${parentNuclide.halfLife}) is shorter than daughter half-life (${foundDaughter.halfLife}). No equilibrium will occur.`;
                    } else if (T1_seconds > 100 * T2_seconds) {
                        type = 'Secular Equilibrium';
                        theoreticalRatio = 1.0;
                        timeToEq = (7 * T2_seconds); // ~99% saturation
                        message = `Parent half-life is much longer than daughter's. Daughter activity will eventually equal parent activity (adjusted for branching).`;
                    } else {
                        type = 'Transient Equilibrium';
                        const lambda1 = Math.log(2) / T1_seconds;
                        const lambda2 = Math.log(2) / T2_seconds;
                        theoreticalRatio = lambda2 / (lambda2 - lambda1);
                        timeToMax = Math.log(lambda2 / lambda1) / (lambda2 - lambda1);
                        timeToEq = timeToMax * 2; 
                        message = `Half-lives are comparable. Daughter will rise, exceed parent, then decay in lock-step.`;
                    }
                    
                    setAnalysis({ type, message, theoreticalRatio, timeToEq, timeToMax });
                    
                }, [parentNuclide, decayPaths, selectedPathIndex, radionuclides]);
                
                // --- CALCULATION ---
                const handleCalculate = () => {
                    if (!parentNuclide || !daughterNuclide) return;
                    
                    const N0_parent = parseFloat(initialActivity);
                    const N0_daughter = parseFloat(initialDaughterActivity);
                    const br = parseFloat(branchingFraction);
                    const t_input = parseFloat(timeElapsed);
                    
                    if ([N0_parent, N0_daughter, br, t_input].some(isNaN) || N0_parent < 0 || N0_daughter < 0 || br < 0 || br > 1 || t_input < 0) {
                        setError('Please enter valid inputs.'); return;
                    }
                    setError('');
                    
                    const T1_seconds = parseHalfLifeToSeconds(parentNuclide.halfLife);
                    const T2_seconds = parseHalfLifeToSeconds(daughterNuclide.halfLife);
                    const unitConversions = { 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600 };
                    const t_seconds = t_input * unitConversions[timeUnit];
                    const lambda1 = Math.log(2) / T1_seconds;
                    const lambda2 = Math.log(2) / T2_seconds;
                    
                    // Bateman Calculation
                    const A_parent = N0_parent * Math.exp(-lambda1 * t_seconds);
                    const initialDaughterDecay = N0_daughter * Math.exp(-lambda2 * t_seconds);
                    let daughterIngrowth;
                    
                    if (Math.abs(lambda1 - lambda2) < 1e-12) {
                        daughterIngrowth = br * N0_parent * lambda1 * t_seconds * Math.exp(-lambda1 * t_seconds);
                    } else {
                        daughterIngrowth = br * (lambda2 / (lambda2 - lambda1)) * N0_parent * (Math.exp(-lambda1 * t_seconds) - Math.exp(-lambda2 * t_seconds));
                    }
                    
                    const A_daughter = initialDaughterDecay + daughterIngrowth;
                    const currentRatio = A_parent > 0 ? (A_daughter / A_parent) : 0;
                    
                    setResult({
                        parent: { name: parentNuclide.name, activity: A_parent.toPrecision(4) },
                        daughter: { name: daughterNuclide.name, activity: A_daughter.toPrecision(4) },
                        currentRatio: currentRatio.toFixed(4)
                    });
                    
                    // --- Chart Generation ---
                    const labels = [], parentData = [], daughterData = [];
                    const plotTime = t_seconds;
                    const steps = 100;
                    
                    for (let i = 0; i <= steps; i++) {
                        const timePoint = (plotTime / steps) * i;
                        const displayTimeVal = timePoint / unitConversions[timeUnit];
                        labels.push(displayTimeVal < 10 ? displayTimeVal.toPrecision(2) : Math.round(displayTimeVal).toString());
                        
                        const curr_A_parent = N0_parent * Math.exp(-lambda1 * timePoint);
                        parentData.push(curr_A_parent);
                        
                        const curr_initD_decay = N0_daughter * Math.exp(-lambda2 * timePoint);
                        let curr_D_ingrowth;
                        if (Math.abs(lambda1 - lambda2) < 1e-12) {
                            curr_D_ingrowth = br * N0_parent * lambda1 * timePoint * Math.exp(-lambda1 * timePoint);
                        } else {
                            curr_D_ingrowth = br * (lambda2 / (lambda2 - lambda1)) * N0_parent * (Math.exp(-lambda1 * timePoint) - Math.exp(-lambda2 * timePoint));
                        }
                        daughterData.push(curr_initD_decay + curr_D_ingrowth);
                    }
                    
                    setChartData({ labels, parentData, daughterData, parentName: parentNuclide.name, daughterName: daughterNuclide.name, timeUnit });
                };
                
                // Auto-calculate
                React.useEffect(() => {
                    if (parentNuclide && daughterNuclide) handleCalculate();
                }, [parentNuclide, daughterNuclide, initialActivity, initialDaughterActivity, branchingFraction, timeElapsed, timeUnit]);
                
                const handleSaveToHistory = () => {
                    if (result && parentNuclide) {
                        addHistory({
                            id: Date.now(),
                            type: 'Equilibrium',
                            icon: ICONS.activity,
                            inputs: `${initialActivity} ${activityUnit} ${parentNuclide.symbol} (t=${timeElapsed} ${timeUnit})`,
                            result: `D: ${result.daughter.activity}, Ratio: ${result.currentRatio}`,
                            view: VIEWS.EQUILIBRIUM
                        });
                        addToast("Calculation saved to history!");
                    }
                };
                
                const setTimeTarget = (targetSeconds) => {
                    const unitConv = { 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600 };
                    const bestUnit = getBestHalfLifeUnit(targetSeconds);
                    setTimeUnit(bestUnit === 'seconds' ? 'minutes' : bestUnit);
                    setTimeElapsed((targetSeconds / unitConv[bestUnit === 'seconds' ? 'minutes' : bestUnit]).toPrecision(4));
                };
                
                const handleClearInputs = () => {
                    setParentNuclide(null); setDaughterNuclide(null);
                    setInitialActivity('100'); setInitialDaughterActivity('0');
                    setBranchingFraction('1.0');
                    setTimeElapsed('10'); setTimeUnit('days');
                    setResult(null); setChartData(null); setError(''); setAnalysis(null);
                };
                
                return (
                    <div className="p-4 animate-fade-in">
                        <div className="max-w-2xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                            <div className="flex justify-between items-center mb-4">
                                <h2 className="text-xl font-bold text-slate-800 dark:text-white">Equilibrium Analyzer</h2>
                                <ClearButton onClick={handleClearInputs} />
                            </div>
                            
                            <div className="space-y-4">
                                <div>
                                    <label className="text-sm font-medium text-slate-700 dark:text-slate-300">Parent Nuclide</label>
                                    <div className="mt-1 min-h-[42px]">
                                        {parentNuclide ?
                                            <CalculatorNuclideInfo nuclide={parentNuclide} onClear={() => setParentNuclide(null)} />
                                            : <SearchableSelect options={parentNuclides} onSelect={handleParentChange} placeholder="Search for a parent nuclide..."/>}
                                    </div>
                                </div>

                                {/* --- PATH SELECTOR --- */}
                                {decayPaths.length > 1 && (
                                    <div className="p-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-lg">
                                        <label className="block text-xs font-bold text-amber-800 dark:text-amber-200 mb-1">Select Decay Path</label>
                                        <select 
                                            value={selectedPathIndex} 
                                            onChange={handlePathChange}
                                            className="w-full p-2 text-sm rounded border-amber-300 bg-white dark:bg-slate-800 focus:ring-amber-500"
                                        >
                                            {decayPaths.map((path, idx) => (
                                                <option key={idx} value={idx}>
                                                    {path.label} ({(path.fraction * 100).toFixed(2)}%)
                                                </option>
                                            ))}
                                        </select>
                                    </div>
                                )}
                                
                                {analysis && (
                                    <div className="p-4 bg-sky-50 dark:bg-sky-900/20 rounded-lg animate-fade-in border border-sky-100 dark:border-sky-800">
                                        <h3 className="text-lg font-bold text-sky-600 dark:text-sky-400 mb-2">{analysis.type}</h3>
                                        <p className="text-sm text-slate-600 dark:text-slate-300 mb-3">{analysis.message}</p>
                                
                                        {(analysis.theoreticalRatio || analysis.timeToMax || analysis.timeToEq) && (
                                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2 text-sm border-t border-sky-200 dark:border-sky-800 pt-3">
                                                {analysis.theoreticalRatio && (
                                                    <div><p className="font-semibold text-slate-500 dark:text-slate-400">Equilibrium Ratio (A₂/A₁):</p><p className="font-mono">{(analysis.theoreticalRatio * parseFloat(branchingFraction)).toFixed(4)}</p></div>
                                                )}
                                                {analysis.timeToEq && (
                                                    <div className="flex justify-between items-center bg-white dark:bg-slate-800 p-2 rounded shadow-sm">
                                                        <div>
                                                            <p className="font-semibold text-slate-500 dark:text-slate-400">Time to ~Equilibrium (99%):</p>
                                                            <p className="font-mono font-bold">{formatHalfLife(analysis.timeToEq.toString() + ' seconds', getBestHalfLifeUnit(analysis.timeToEq))}</p>
                                                        </div>
                                                        <button onClick={() => setTimeTarget(analysis.timeToEq)} className="text-xs px-3 py-1.5 bg-emerald-600 text-white font-bold rounded hover:bg-emerald-700 transition">Jump to Eq</button>
                                                    </div>
                                                )}
                                                {analysis.timeToMax && (
                                                    <div className="col-span-1 sm:col-span-2 flex items-center justify-between mt-2 bg-white dark:bg-slate-800 p-2 rounded shadow-sm">
                                                        <div>
                                                            <p className="font-semibold text-sky-600 dark:text-sky-400">Time to Peak Daughter Activity:</p>
                                                            <p className="font-mono font-bold">{formatHalfLife(analysis.timeToMax.toString() + ' seconds', getBestHalfLifeUnit(analysis.timeToMax))}</p>
                                                        </div>
                                                        <button onClick={() => setTimeTarget(analysis.timeToMax)} className="text-xs px-3 py-1.5 bg-sky-600 text-white font-bold rounded hover:bg-sky-700 transition">Jump to Peak</button>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                {parentNuclide && (
                                    <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium">Initial Parent Activity</label>
                                                <div className="flex">
                                                    <input type="number" value={initialActivity} onChange={e => setInitialActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" />
                                                    <select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-sm">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                                                </div>
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium">Initial Daughter Activity</label>
                                                <div className="flex">
                                                    <input type="number" value={initialDaughterActivity} onChange={e => setInitialDaughterActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" />
                                                    <div className="flex items-center justify-center px-3 bg-slate-200 dark:bg-slate-600 rounded-r-md text-sm text-slate-500 dark:text-slate-300">{activityUnit}</div>
                                                </div>
                                            </div>
                                        </div>
                                
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium">Time Elapsed</label>
                                                <div className="flex gap-2 mt-1">
                                                    <input type="number" value={timeElapsed} onChange={e => setTimeElapsed(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600" />
                                                    <select value={timeUnit} onChange={e => setTimeUnit(e.target.value)} className="p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600">
                                                        {timeUnitsOrdered.map(u => <option key={u} value={u}>{u}</option>)}
                                                    </select>
                                                </div>
                                            </div>
                                            <div>
                                                <Tooltip text="The fraction of parent decays that result in this daughter. Example: Mo-99 -> Tc-99m is ~0.875.">
                                                    <label className="block text-sm font-medium cursor-help underline decoration-dotted">Branching Fraction (0-1)</label>
                                                </Tooltip>
                                                <input type="number" value={branchingFraction} onChange={e => setBranchingFraction(e.target.value)} step="0.01" min="0" max="1" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700" />
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                                
                                {result && (
                                    <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg space-y-2">
                                        <div className="flex justify-between items-center mb-2">
                                            <p className="font-semibold text-center text-sm flex-grow">Activity at {timeElapsed} {timeUnit}</p>
                                            <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                                                <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors -mr-2">
                                                    <Icon path={ICONS.notepad} className="w-5 h-5" />
                                                </button>
                                            </Tooltip>
                                        </div>
                                
                                        <div className="grid grid-cols-2 gap-4">
                                            <div className="p-2 bg-white dark:bg-slate-800 rounded shadow-sm text-center">
                                                <p className="text-xs text-slate-500">Parent ({result.parent.name})</p>
                                                <p className="font-bold text-sky-600 dark:text-sky-400">{result.parent.activity}</p>
                                            </div>
                                            <div className="p-2 bg-white dark:bg-slate-800 rounded shadow-sm text-center border-b-2 border-rose-500">
                                                <p className="text-xs text-slate-500">Daughter ({result.daughter.name})</p>
                                                <p className="font-bold text-rose-600 dark:text-rose-400">{result.daughter.activity}</p>
                                            </div>
                                        </div>
                                
                                        <div className="text-center pt-2">
                                            <span className="text-sm font-medium text-slate-600 dark:text-slate-300">Current Ratio (A₂/A₁): <span className="font-bold font-mono">{result.currentRatio}</span></span>
                                        </div>
                                    </div>
                                )}
                                
                                {chartData && (
                                    <>
                                        <div className="flex justify-end mt-4">
                                            <label className="flex items-center gap-2 text-sm cursor-pointer">
                                                <input type="checkbox" checked={useLogScale} onChange={() => setUseLogScale(!useLogScale)} className="form-checkbox h-4 w-4 rounded text-sky-600" />
                                                Use Logarithmic Scale
                                            </label>
                                        </div>
                                        <DecayChart chartData={chartData} useLogScale={useLogScale} theme={theme} />
                                    </>
                                )}
                            </div>
                        </div>
                    </div>
                );
            };
            
            /**
            * @description Updated Radon Concentration Calculator with EPA Context Bar and Occupancy Presets.
            */
            const ConcentrationDoseModule = ({ calcMode, setCalcMode, concentration, setConcentration, unit, setUnit, equilibriumFactor, setEquilibriumFactor, workingLevel, setWorkingLevel, occupancyFactor, setOccupancyFactor, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const { settings } = React.useContext(SettingsContext);
            
            const Bq_per_m3_in_pCi_per_L = 37;
            const PAEC_J_per_m3_in_WL = 2.08e-5;
            const dose_conversion_mrem_per_WLM = 1250;
            
            React.useEffect(() => {
            localStorage.setItem('radon_calcMode', calcMode);
            localStorage.setItem('radon_concentration', concentration);
            localStorage.setItem('radon_unit', unit);
            localStorage.setItem('radon_equilibriumFactor', equilibriumFactor);
            localStorage.setItem('radon_workingLevel', workingLevel);
            localStorage.setItem('radon_occupancyFactor', occupancyFactor);
            }, [calcMode, concentration, unit, equilibriumFactor, workingLevel, occupancyFactor]);
            
            React.useEffect(() => {
            try {
            setError('');
            const conc_val = parseFloat(concentration);
            const ef_val = parseFloat(equilibriumFactor);
            const wl_val = parseFloat(workingLevel);
            const of_val = parseFloat(occupancyFactor);
            
            let final_pCi_L, final_Bq_m3, final_WL, final_EF;
            
            switch(calcMode) {
            case 'doseFromConc':
            if (isNaN(conc_val) || isNaN(ef_val)) throw new Error('Concentration and Equilibrium Factor must be numbers.');
            final_pCi_L = unit === 'pCi/L' ? conc_val : conc_val / Bq_per_m3_in_pCi_per_L;
            final_EF = ef_val;
            final_WL = (final_pCi_L / 100) * final_EF;
            if (workingLevel !== final_WL.toPrecision(3)) setWorkingLevel(final_WL.toPrecision(3));
            break;
            case 'findWL':
            if (isNaN(conc_val) || isNaN(ef_val)) throw new Error('Concentration and Equilibrium Factor must be numbers.');
            final_pCi_L = unit === 'pCi/L' ? conc_val : conc_val / Bq_per_m3_in_pCi_per_L;
            final_EF = ef_val;
            final_WL = (final_pCi_L / 100) * final_EF;
            setWorkingLevel(final_WL.toPrecision(3));
            break;
            case 'findConc':
            if (isNaN(wl_val) || isNaN(ef_val)) throw new Error('Working Level and Equilibrium Factor must be numbers.');
            if (ef_val <= 0) throw new Error('Equilibrium Factor must be greater than zero.');
            final_WL = wl_val;
            final_EF = ef_val;
            final_pCi_L = (final_WL * 100) / final_EF;
            const final_conc_display = unit === 'pCi/L' ? final_pCi_L : final_pCi_L * Bq_per_m3_in_pCi_per_L;
            setConcentration(final_conc_display.toPrecision(3));
            break;
            case 'findEF':
             if (isNaN(wl_val) || isNaN(conc_val)) throw new Error('Working Level and Concentration must be numbers.');
             final_pCi_L = unit === 'pCi/L' ? conc_val : conc_val / Bq_per_m3_in_pCi_per_L;
             if (final_pCi_L <= 0) throw new Error('Concentration must be greater than zero.');
             final_WL = wl_val;
             final_EF = (final_WL * 100) / final_pCi_L;
             setEquilibriumFactor(final_EF.toPrecision(3));
             break;
            default: break;
            }
            
            if (isNaN(of_val)) throw new Error('Occupancy Factor must be a number.');
            
            final_Bq_m3 = final_pCi_L * Bq_per_m3_in_pCi_per_L;
            const paec_J_m3 = final_WL * PAEC_J_per_m3_in_WL;
            
            // WLM = (WL * Hours) / 170
            const hours_per_year = 8760 * of_val;
            const wlm_per_year = (final_WL * hours_per_year) / 170;
            const annualDose_mrem = wlm_per_year * dose_conversion_mrem_per_WLM;
            
            setResult({
            pCi_L: final_pCi_L.toPrecision(3),
            Bq_m3: final_Bq_m3.toPrecision(3),
            workingLevels: final_WL.toPrecision(3),
            equilibriumFactor: final_EF.toPrecision(3),
            paec_J_m3: paec_J_m3.toExponential(2),
            wlm_year: wlm_per_year.toPrecision(3),
            annualDose: formatDoseValue(annualDose_mrem, 'dose', settings)
            });
            
            } catch (e) { setError(e.message); setResult(null); }
            }, [concentration, unit, equilibriumFactor, workingLevel, occupancyFactor, calcMode, setConcentration, setEquilibriumFactor, setWorkingLevel, setResult, setError, settings]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({
            id: Date.now(),
            type: 'Radon Dose',
            icon: ICONS.radon,
            inputs: `${result.pCi_L} pCi/L, F=${result.equilibriumFactor}`,
            result: `${result.annualDose.value} ${result.annualDose.unit}/yr`,
            view: VIEWS.RADON
            });
            addToast("Calculation saved to history!");
            }
            };
            
            const getHeroMetric = () => {
            if (!result) return null;
            switch (calcMode) {
            case 'findWL': return { label: 'Calculated Working Level', value: result.workingLevels, unit: 'WL' };
            case 'findConc': return unit === 'pCi/L' ? { label: 'Calculated Concentration', value: result.pCi_L, unit: 'pCi/L' } : { label: 'Calculated Concentration', value: result.Bq_m3, unit: 'Bq/m³' };
            case 'findEF': return { label: 'Calculated Equilibrium Factor', value: result.equilibriumFactor, unit: 'F' };
            case 'doseFromConc': default: return { label: 'Estimated Annual Dose', value: result.annualDose.value, unit: result.annualDose.unit, subtext: `(${result.wlm_year} WLM/year)` };
            }
            };
            
            const hero = getHeroMetric();
            
            // --- VISUAL CONTEXT LOGIC (EPA Action Level) ---
            
            const getSafetyContext = (pCiL_str) => {
            const val = parseFloat(pCiL_str);
            if (val < 2.0) return { color: 'bg-green-500', width: '25%', label: 'Normal (< 2.0)' };
            if (val < 4.0) return { color: 'bg-yellow-400', width: '50%', label: 'Warning (2.0 - 4.0)' };
            if (val < 8.0) return { color: 'bg-orange-500', width: '75%', label: 'Action Level (> 4.0)' };
            return { color: 'bg-red-500', width: '100%', label: 'High (> 8.0)' };
            };
            
            const safety = result ? getSafetyContext(result.pCi_L) : null;
            
            return (
            <div className="space-y-4">
            <div className="grid grid-cols-2 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg">
            <button onClick={() => setCalcMode('doseFromConc')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${calcMode === 'doseFromConc' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Dose from Conc.</button>
            <button onClick={() => setCalcMode('findWL')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${calcMode === 'findWL' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Find WL</button>
            <button onClick={() => setCalcMode('findConc')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${calcMode === 'findConc' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Find Concentration</button>
            <button onClick={() => setCalcMode('findEF')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${calcMode === 'findEF' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Find Equilibrium</button>
            </div>
            
            <div className="space-y-4 p-4 border border-slate-200 dark:border-slate-700 rounded-lg">
            <div>
            <label className="block text-sm font-medium">Radon Concentration</label>
            <div className="flex">
               <input type="number" value={concentration} onChange={e => setConcentration(e.target.value)} disabled={calcMode === 'findConc'} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 disabled:bg-slate-200 dark:disabled:bg-slate-800" />
               <select value={unit} onChange={e => setUnit(e.target.value)} disabled={calcMode === 'findConc'} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 disabled:opacity-50"><option>pCi/L</option><option>Bq/m³</option></select>
            </div>
            </div>
            <div>
            <Tooltip text="The fraction of radon progeny in equilibrium with the parent radon gas. 0.4 is a standard assumption for homes; 0.5-0.7 for clean rooms/labs.">
               <label className="block text-sm font-medium cursor-help underline decoration-dotted">Equilibrium Factor (F)</label>
            </Tooltip>
            <input type="number" value={equilibriumFactor} onChange={e => setEquilibriumFactor(e.target.value)} step="0.05" min="0" max="1" disabled={calcMode === 'findEF'} placeholder="e.g., 0.4" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 disabled:bg-slate-200 dark:disabled:bg-slate-800" />
            </div>
            <div>
            <label className="block text-sm font-medium">Working Level (WL)</label>
            <input type="number" value={workingLevel} onChange={e => setWorkingLevel(e.target.value)} disabled={calcMode === 'findWL' || calcMode === 'doseFromConc'} placeholder="e.g., 0.02" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 disabled:bg-slate-200 dark:disabled:bg-slate-800" />
            </div>
            
            {/* Occupancy Section with Presets */}
            <div className="pt-2 border-t border-slate-200 dark:border-slate-700">
            <div className="flex justify-between items-end mb-1">
                <label className="block text-sm font-medium">Occupancy Factor (0-1)</label>
                <div className="flex gap-2">
                     <button onClick={() => setOccupancyFactor('0.75')} className="px-2 py-0.5 text-xs bg-slate-200 dark:bg-slate-600 rounded hover:bg-slate-300 dark:hover:bg-slate-500 transition">Home (75%)</button>
                     <button onClick={() => setOccupancyFactor('0.228')} className="px-2 py-0.5 text-xs bg-slate-200 dark:bg-slate-600 rounded hover:bg-slate-300 dark:hover:bg-slate-500 transition">Work (2k hr)</button>
                </div>
            </div>
            <input type="number" value={occupancyFactor} onChange={e => setOccupancyFactor(e.target.value)} step="0.05" min="0" max="1" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700" />
            </div>
            </div>
            
            {error && <p className="text-red-500 text-sm text-center mt-4">{error}</p>}
            
            {result && (
            <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 animate-fade-in">
            <div className="text-center pb-4 mb-4 border-b border-slate-300 dark:border-slate-600">
               <div className="flex justify-between items-center -mt-2 -mb-2">
                   <div></div>
                   <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">{hero.label}</p>
                   <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                      <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                          <Icon path={ICONS.notepad} className="w-5 h-5" />
                      </button>
                   </Tooltip>
               </div>
               <div className="flex items-center justify-center mt-2">
                   <p className="text-4xl font-bold text-sky-600 dark:text-sky-400">{hero.value} <span className="text-2xl opacity-75">{hero.unit}</span></p>
                   <CopyButton textToCopy={hero.value} />
               </div>
               {hero.subtext && <p className="text-xs text-slate-500 dark:text-slate-400 mt-1">{hero.subtext}</p>}
            </div>
            
            {/* VISUAL CONTEXT BAR */}
            <div className="mb-4">
               <div className="flex justify-between text-xs font-semibold mb-1 text-slate-500 dark:text-slate-400">
                   <span>EPA Context</span>
                   <span>{safety.label}</span>
               </div>
               <div className="h-4 w-full bg-slate-200 dark:bg-slate-600 rounded-full overflow-hidden relative border border-slate-300 dark:border-slate-500">
                   <div className={`h-full ${safety.color} transition-all duration-500`} style={{ width: safety.width }}></div>
                   {/* Marker line at 4 pCi/L (Warning/Action threshold) */}
                   <div className="absolute top-0 bottom-0 w-0.5 bg-black/50 dark:bg-white/50" style={{ left: '50%' }} title="Action Level (4.0 pCi/L)"></div>
               </div>
               <div className="flex justify-between text-[10px] text-slate-400 mt-1">
                   <span>0</span>
                   <span className="font-bold">4.0 pCi/L</span>
                   <span>8.0+</span>
               </div>
            </div>
            
            <h3 className="text-sm font-bold text-slate-700 dark:text-slate-300 mb-2">Calculation Details</h3>
            <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
               {calcMode !== 'findConc' && ( <><span className="font-semibold text-slate-500 dark:text-slate-400">Concentration:</span><p className="font-mono text-right">{result.pCi_L} pCi/L</p></> )}
               {calcMode !== 'findEF' && ( <><span className="font-semibold text-slate-500 dark:text-slate-400">Equilibrium (F):</span><p className="font-mono text-right">{result.equilibriumFactor}</p></> )}
               {calcMode !== 'findWL' && calcMode !== 'doseFromConc' && ( <><span className="font-semibold text-slate-500 dark:text-slate-400">Working Level:</span><p className="font-mono text-right">{result.workingLevels}</p></> )}
               <span className="font-semibold text-slate-500 dark:text-slate-400">PAEC:</span><p className="font-mono text-right">{result.paec_J_m3} J/m³</p>
            </div>
            </div>
            )}
            </div>
            );
            };
            
            // 2. Updated RadonIngrowthCalculator (Added Leakage Note)
            const RadonIngrowthCalculator = ({ result, setResult, error, setError, amount, setAmount, unit, setUnit, time, setTime, timeUnit, setTimeUnit }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const { settings } = React.useContext(SettingsContext);
            
            const RA226_SPECIFIC_ACTIVITY_BQ_PER_G = 3.66e10;
            const RN222_HALFLIFE_SECONDS = 3.8235 * 24 * 3600;
            const RN222_LAMBDA_PER_SECOND = Math.log(2) / RN222_HALFLIFE_SECONDS;
            
            const massFactors_g = { 'ng': 1e-9, 'µg': 1e-6, 'mg': 1e-3, 'g': 1 };
            const activityFactors_Bq = { 'Bq': 1, 'kBq': 1e3, 'MBq': 1e6, 'GBq': 1e9, 'µCi': 37000, 'mCi': 3.7e7, 'Ci': 3.7e10 };
            const timeUnits = { 'minutes': 60, 'hours': 3600, 'days': 86400, 'weeks': 604800 };
            
            React.useEffect(() => {
            try {
            setError('');
            const val = parseFloat(amount);
            const t_val = parseFloat(time);
            
            if (isNaN(val) || val <= 0 || isNaN(t_val) || t_val < 0) {
              if(amount && time) setError("Inputs must be positive numbers.");
              setResult(null); return;
            }
            
            let ra226_activity_Bq = 0;
            const isMass = Object.keys(massFactors_g).includes(unit);
            
            if (isMass) {
              const mass_g = val * massFactors_g[unit];
              ra226_activity_Bq = mass_g * RA226_SPECIFIC_ACTIVITY_BQ_PER_G;
            } else {
              ra226_activity_Bq = val * (activityFactors_Bq[unit] || 0);
            }
            
            const time_s = t_val * (timeUnits[timeUnit] || 0);
            
            const rn222_activity_Bq = ra226_activity_Bq * (1 - Math.exp(-RN222_LAMBDA_PER_SECOND * time_s));
            const percentEquilibrium = (rn222_activity_Bq / ra226_activity_Bq) * 100;
            
            const configKey = settings.unitSystem === 'si' ? 'activity_si' : 'activity_conventional';
            
            const ra226_base = settings.unitSystem === 'si' ? ra226_activity_Bq : ra226_activity_Bq / 3.7e10;
            const rn222_base = settings.unitSystem === 'si' ? rn222_activity_Bq : rn222_activity_Bq / 3.7e10;
            
            setResult({
              ra226_activity: formatSensibleUnit(ra226_base, configKey),
              rn222_activity: formatSensibleUnit(rn222_base, configKey),
              percentEquilibrium: percentEquilibrium.toFixed(2)
            });
            
            } catch (e) { setError("Calculation failed."); setResult(null); }
            }, [amount, unit, time, timeUnit, settings.unitSystem]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Radon Ingrowth', icon: ICONS.radon, inputs: `${amount} ${unit} Ra-226, ${time} ${timeUnit}`, result: `${result.rn222_activity.value} ${result.rn222_activity.unit} Rn-222`, view: VIEWS.RADON });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="space-y-4">
            <ContextualNote type="info">
              <strong>Assumptions:</strong> Calculates theoretical max ingrowth in a hermetically sealed container. Actual levels will be lower if the container leaks Rn-222 gas.
            </ContextualNote>
            
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
              <div>
                  <label className="block text-sm font-medium">Source Quantity</label>
                  <div className="flex">
                      <input type="number" value={amount} onChange={e => setAmount(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" />
                      <select value={unit} onChange={e => setUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">
                          <optgroup label="Mass">{Object.keys(massFactors_g).map(u => <option key={u} value={u}>{u}</option>)}</optgroup>
                          <optgroup label="Activity">{(settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq'] : ['µCi', 'mCi', 'Ci']).map(u => <option key={u} value={u}>{u}</option>)}</optgroup>
                      </select>
                  </div>
              </div>
              <div>
                  <label className="block text-sm font-medium">Ingrowth Time</label>
                  <div className="flex">
                      <input type="number" value={time} onChange={e => setTime(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" />
                      <select value={timeUnit} onChange={e => setTimeUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(timeUnits).map(u => <option key={u} value={u}>{u}</option>)}</select>
                  </div>
              </div>
            </div>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (
              <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 text-center animate-fade-in">
                    <div className="flex justify-between items-center -mt-2 -mb-2">
                      <div></div>
                      <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Resulting Rn-222 Activity</p>
                      <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                         <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                             <Icon path={ICONS.notepad} className="w-5 h-5" />
                         </button>
                      </Tooltip>
                    </div>
                  <div className="flex items-center justify-center mt-2">
                      <p className="text-4xl font-bold text-sky-600 dark:text-sky-400">{result.rn222_activity.value} <span className="text-2xl opacity-75">{result.rn222_activity.unit}</span></p>
                      <CopyButton textToCopy={result.rn222_activity.value} />
                  </div>
                  <p className="text-sm font-medium text-slate-600 dark:text-slate-300 mt-2">Parent Activity: {result.ra226_activity.value} {result.ra226_activity.unit}</p>
                  <p className="text-xs text-slate-500 dark:text-slate-400 mt-1">({result.percentEquilibrium}% of secular equilibrium)</p>
              </div>
            )}
            </div>
            );
            };
            
            // 3. Updated KusnetzCalculator (Hard Validation)
            const KusnetzCalculator = ({ flowRate, setFlowRate, sampleTime, setSampleTime, delayTime, setDelayTime, grossCounts, setGrossCounts, countDuration, setCountDuration, backgroundCpm, setBackgroundCpm, efficiency, setEfficiency, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const KUSNETZ_FACTORS = { 40: 150, 45: 138, 50: 128, 55: 119, 60: 112, 65: 105, 70: 100, 75: 95, 80: 90, 85: 86, 90: 82 };
            
            React.useEffect(() => {
            localStorage.setItem('kusnetz_flowRate', flowRate); localStorage.setItem('kusnetz_sampleTime', sampleTime); localStorage.setItem('kusnetz_delayTime', delayTime);
            localStorage.setItem('kusnetz_grossCounts', grossCounts); localStorage.setItem('kusnetz_countDuration', countDuration);
            localStorage.setItem('kusnetz_backgroundCpm', backgroundCpm); localStorage.setItem('kusnetz_efficiency', efficiency);
            }, [flowRate, sampleTime, delayTime, grossCounts, countDuration, backgroundCpm, efficiency]);
            
            const interpolate = (x, points) => {
            const keys = Object.keys(points).map(Number).sort((a, b) => a - b);
            if (x <= keys[0]) return points[keys[0]]; if (x >= keys[keys.length - 1]) return points[keys[keys.length - 1]];
            const x1 = Math.max(...keys.filter(k => k <= x)); const x2 = Math.min(...keys.filter(k => k > x));
            const y1 = points[x1]; const y2 = points[x2];
            return y1 + (y2 - y1) * (x - x1) / (x2 - x1);
            };
            
            React.useEffect(() => {
            try {
            setError('');
            const params = { V_flow: parseFloat(flowRate), T_sample: parseFloat(sampleTime), T_delay: parseFloat(delayTime), C_gross: parseFloat(grossCounts), T_count: parseFloat(countDuration), cpm_bkg: parseFloat(backgroundCpm), eff: parseFloat(efficiency) };
            
            if (Object.values(params).some(isNaN) || params.V_flow <= 0 || params.T_sample <= 0 || params.T_delay <= 0 || params.eff <= 0) {
             if (Object.values(params).every(p => p || p === 0)) setError("Please enter valid positive numbers.");
             setResult(null); return;
            }
            
            // --- VALIDATION: Hard Stop for Invalid Time ---
            if (params.T_delay < 40 || params.T_delay > 90) {
             setError("Delay time must be between 40 and 90 minutes for the Kusnetz Method.");
             setResult(null);
             return;
            }
            
            const totalVolume_L = params.V_flow * params.T_sample;
            const gross_cpm = params.C_gross / params.T_count;
            const net_cpm = gross_cpm - params.cpm_bkg;
            const k_factor = interpolate(params.T_delay, KUSNETZ_FACTORS);
            const workingLevel = net_cpm / (k_factor * (params.eff / 100) * totalVolume_L);
            
            setResult({ workingLevel: workingLevel.toPrecision(3), k_factor: k_factor.toFixed(1), totalVolume_L: totalVolume_L.toPrecision(3), net_cpm: net_cpm.toPrecision(3) });
            } catch (e) { setError("Calculation error."); setResult(null); }
            }, [flowRate, sampleTime, delayTime, grossCounts, countDuration, backgroundCpm, efficiency, setResult, setError]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Kusnetz Method (WL)', icon: ICONS.radon, inputs: `Delay: ${delayTime} min, Vol: ${result.totalVolume_L} L`, result: `${result.workingLevel} WL`, view: VIEWS.RADON });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="space-y-4">
            <p className="text-sm text-slate-600 dark:text-slate-400">Determine the Working Level (WL) of radon progeny.</p>
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
             <div className="grid grid-cols-2 gap-4">
                 <div><label className="block text-sm font-medium">Flow Rate (LPM)</label><input type="number" value={flowRate} onChange={e => setFlowRate(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                 <div><label className="block text-sm font-medium">Sample Time (min)</label><input type="number" value={sampleTime} onChange={e => setSampleTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                 <div><label className="block text-sm font-medium">Gross Counts</label><input type="number" value={grossCounts} onChange={e => setGrossCounts(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                 <div><label className="block text-sm font-medium">Count Duration (min)</label><input type="number" value={countDuration} onChange={e => setCountDuration(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                 <div><label className="block text-sm font-medium">Background (cpm)</label><input type="number" value={backgroundCpm} onChange={e => setBackgroundCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                 <div><label className="block text-sm font-medium">Alpha Efficiency (%)</label><input type="number" value={efficiency} onChange={e => setEfficiency(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
             </div>
             <div><Tooltip text="Time between end-of-sampling and start-of-count. Standard method requires 40-90 mins."><label className="block text-sm font-medium">Delay Time (minutes)</label></Tooltip><input type="number" value={delayTime} onChange={e => setDelayTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
            </div>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (
             <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg animate-fade-in space-y-3">
                 <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                     <span className="font-semibold text-slate-600 dark:text-slate-300">Net Count Rate:</span><span className="font-mono text-right">{result.net_cpm} cpm</span>
                     <span className="font-semibold text-slate-600 dark:text-slate-300">Total Air Volume:</span><span className="font-mono text-right">{result.totalVolume_L} L</span>
                     <span className="font-semibold text-slate-600 dark:text-slate-300">Interpolated K Factor:</span><span className="font-mono text-right">{result.k_factor}</span>
                 </div>
                 <div className="text-center pt-3 border-t border-slate-300 dark:border-slate-600">
                     <div className="flex justify-between items-center -mt-2 -mb-2">
                         <div></div>
                         <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">Calculated Progeny Concentration</p>
                         <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                            <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                                <Icon path={ICONS.notepad} className="w-5 h-5" />
                            </button>
                         </Tooltip>
                     </div>
                     <p className="text-3xl font-bold text-sky-600 dark:text-sky-400">{result.workingLevel}</p>
                     <p className="text-md font-medium text-slate-600 dark:text-slate-300">Working Levels (WL)</p>
                 </div>
             </div>
            )}
            </div>
            );
            };
            
            /**
            * @description The main container for the Radon Tools suite.
            * It manages the shared state for the sub-calculators and handles tab navigation.
            */
            const RadonCalculator = ({ onNavClick }) => {
            const { settings } = React.useContext(SettingsContext);
            const [activeTab, setActiveTab] = React.useState('concentration');
            
            const isSI = settings.unitSystem === 'si';
            
            // --- 1. Concentration Tab State ---
            const [conc_calcMode, setConc_calcMode] = React.useState(() => localStorage.getItem('radon_calcMode') || 'doseFromConc');
            const [conc_concentration, setConc_concentration] = React.useState(() => localStorage.getItem('radon_concentration') || '4');
            const [conc_unit, setConc_unit] = React.useState(() => {
            const saved = localStorage.getItem('radon_unit');
            return saved || (isSI ? 'Bq/m³' : 'pCi/L');
            });
            const [conc_equilibriumFactor, setConc_equilibriumFactor] = React.useState(() => localStorage.getItem('radon_equilibriumFactor') || '0.4');
            const [conc_workingLevel, setConc_workingLevel] = React.useState(() => localStorage.getItem('radon_workingLevel') || '0.02');
            const [conc_occupancyFactor, setConc_occupancyFactor] = React.useState(() => localStorage.getItem('radon_occupancyFactor') || '1');
            const [conc_result, setConc_result] = React.useState(null);
            const [conc_error, setConc_error] = React.useState('');
            
            // --- 2. Ingrowth Tab State ---
            const [ingrowth_amount, setIngrowth_amount] = React.useState('1');
            const [ingrowth_unit, setIngrowth_unit] = React.useState('µg');
            const [ingrowth_time, setIngrowth_time] = React.useState('30');
            const [ingrowth_timeUnit, setIngrowth_timeUnit] = React.useState('days');
            const [ingrowth_result, setIngrowth_result] = React.useState(null);
            const [ingrowth_error, setIngrowth_error] = React.useState('');
            
            // --- 3. Kusnetz Tab State ---
            const [kusnetz_flowRate, setKusnetz_flowRate] = React.useState(() => localStorage.getItem('kusnetz_flowRate') || '2');
            const [kusnetz_sampleTime, setKusnetz_sampleTime] = React.useState(() => localStorage.getItem('kusnetz_sampleTime') || '5');
            const [kusnetz_delayTime, setKusnetz_delayTime] = React.useState(() => localStorage.getItem('kusnetz_delayTime') || '40');
            const [kusnetz_grossCounts, setKusnetz_grossCounts] = React.useState(() => localStorage.getItem('kusnetz_grossCounts') || '100');
            const [kusnetz_countDuration, setKusnetz_countDuration] = React.useState(() => localStorage.getItem('kusnetz_countDuration') || '1');
            const [kusnetz_backgroundCpm, setKusnetz_backgroundCpm] = React.useState(() => localStorage.getItem('kusnetz_backgroundCpm') || '0');
            const [kusnetz_efficiency, setKusnetz_efficiency] = React.useState(() => localStorage.getItem('kusnetz_efficiency') || '30');
            const [kusnetz_result, setKusnetz_result] = React.useState(null);
            const [kusnetz_error, setKusnetz_error] = React.useState('');
            
            // Auto-switch units if system setting changes
                      React.useEffect(() => {
                 if (isSI) {
                     if (conc_unit === 'pCi/L') {
                         setConc_unit('Bq/m³');
                         setConc_concentration('148'); // Approx 4 pCi/L
                     }
                     if (['µCi', 'mCi', 'Ci'].includes(ingrowth_unit)) {
                         setIngrowth_unit('kBq');
                         setIngrowth_amount('1');
                     }
                 } else {
                     if (conc_unit === 'Bq/m³') {
                         setConc_unit('pCi/L');
                         setConc_concentration('4'); // EPA Action Level
                     }
                     if (['Bq', 'kBq', 'MBq', 'GBq'].includes(ingrowth_unit)) {
                         setIngrowth_unit('µCi');
                         setIngrowth_amount('1');
                     }
                 }
             }, [isSI]);
            
            const handleClearActiveCalculator = () => {
            if (activeTab === 'concentration') {
            setConc_concentration('4'); setConc_unit(isSI ? 'Bq/m³' : 'pCi/L');
            setConc_equilibriumFactor('0.4'); setConc_workingLevel('0.02');
            setConc_occupancyFactor('1'); setConc_result(null); setConc_error('');
            } else if (activeTab === 'ingrowth') {
            setIngrowth_amount('1'); setIngrowth_unit('µg'); setIngrowth_time('30');
            setIngrowth_result(null); setIngrowth_error('');
            } else {
            setKusnetz_flowRate('2'); setKusnetz_sampleTime('5'); setKusnetz_delayTime('40');
            setKusnetz_grossCounts('100'); setKusnetz_countDuration('1'); setKusnetz_backgroundCpm('0');
            setKusnetz_efficiency('30'); setKusnetz_result(null); setKusnetz_error('');
            }
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
            <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold text-slate-800 dark:text-white">Radon Tools</h2>
                <button onClick={handleClearActiveCalculator} className="text-xs text-sky-600 dark:text-sky-400 hover:underline font-semibold flex items-center gap-1">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-3 h-3"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                    Clear Inputs
                </button>
            </div>
            <div className="flex w-full p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-4">
                <button onClick={() => setActiveTab('concentration')} className={`w-1/3 p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'concentration' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Concentration</button>
                <button onClick={() => setActiveTab('ingrowth')} className={`w-1/3 p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'ingrowth' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Ingrowth</button>
                <button onClick={() => setActiveTab('kusnetz')} className={`w-1/3 p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'kusnetz' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Kusnetz (WL)</button>
            </div>
            
            {activeTab === 'concentration' &&
                <ConcentrationDoseModule
                    calcMode={conc_calcMode} setCalcMode={setConc_calcMode}
                    concentration={conc_concentration} setConcentration={setConc_concentration}
                    unit={conc_unit} setUnit={setConc_unit}
                    equilibriumFactor={conc_equilibriumFactor} setEquilibriumFactor={setConc_equilibriumFactor}
                    workingLevel={conc_workingLevel} setWorkingLevel={setConc_workingLevel}
                    occupancyFactor={conc_occupancyFactor} setOccupancyFactor={setConc_occupancyFactor}
                    result={conc_result} setResult={setConc_result}
                    error={conc_error} setError={setConc_error}
                />
            }
            
            {activeTab === 'ingrowth' &&
                <RadonIngrowthCalculator
                    amount={ingrowth_amount} setAmount={setIngrowth_amount}
                    unit={ingrowth_unit} setUnit={setIngrowth_unit}
                    time={ingrowth_time} setTime={setIngrowth_time}
                    timeUnit={ingrowth_timeUnit} setTimeUnit={setIngrowth_timeUnit}
                    result={ingrowth_result} setResult={setIngrowth_result}
                    error={ingrowth_error} setError={setIngrowth_error}
                />
            }
            
            {activeTab === 'kusnetz' &&
                <KusnetzCalculator
                    flowRate={kusnetz_flowRate} setFlowRate={setKusnetz_flowRate}
                    sampleTime={kusnetz_sampleTime} setSampleTime={setKusnetz_sampleTime}
                    delayTime={kusnetz_delayTime} setDelayTime={setKusnetz_delayTime}
                    grossCounts={kusnetz_grossCounts} setGrossCounts={setKusnetz_grossCounts}
                    countDuration={kusnetz_countDuration} setCountDuration={setKusnetz_countDuration}
                    backgroundCpm={kusnetz_backgroundCpm} setBackgroundCpm={setKusnetz_backgroundCpm}
                    efficiency={kusnetz_efficiency} setEfficiency={setKusnetz_efficiency}
                    result={kusnetz_result} setResult={setKusnetz_result}
                    error={kusnetz_error} setError={setKusnetz_error}
                />
            }
            </div>
            </div>
            );
            };
            
            /**
            * @description React component for displaying the application's user manual, FAQ, and technical reference.
            * This component functions as a modal dialog that presents static, detailed information about the
            * "Health Physics Toolbox" application.
            *
            * The manual content is an in-depth guide covering:
            * - **Getting Started:** How to search for and view radionuclide data.
            * - **Core Features:** A comprehensive breakdown of each major section of the app (Database, Compare, Calculators).
            * - **Settings & Customization:** How to configure user preferences.
            * - **Formulas & Equations:** A reference section detailing the key mathematical formulas used in various calculators.
            * - **Contact & Copyright:** Information for user feedback and legal disclaimers.
            * - **FAQ:** Answers to common questions, such as the source of the data and why certain nuclides may not appear in specific calculators.
            *
            * This component is purely for display and serves as the primary source of documentation for the user.
            *
            * @prop {boolean} isOpen - Boolean to control the visibility of the modal.
            * @prop {function} onClose - A callback function to close the modal.
            */
            
            const ManualModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            
            // Internal component for the static content of the manual
            const ManualContent = () => {
            return (
            <div className="prose prose-slate dark:prose-invert max-w-none p-6 text-slate-700 dark:text-slate-300">
              <h1 className="text-slate-900 dark:text-slate-100"><strong>User Manual & FAQ</strong></h1>
              <p>
                  Welcome to the Health Physics Toolbox! This application is designed to be a comprehensive, all-in-one resource for students, health physicists, and nuclear professionals. Our philosophy is to centralize the essential data and calculations you need, removing the reliance on scattered spreadsheets, outdated software, or manual lookups. This guide will walk you through the various features to help you get the most out of the tool.
              </p>
            
              <hr className="my-4" />
            
              <h2 className="text-slate-900 dark:text-slate-100"><strong>Getting Started: Finding a Nuclide</strong></h2>
              <p>
                  The primary function of the tool is to look up detailed information on a specific radionuclide. The search bar at the top of the page is your main entry point.
              </p>
              <h4 className="italic mt-4">Searching</h4>
              <p>
                  You can search by either the nuclide's full name (e.g., <code>"Cesium-137"</code>) or its symbol (e.g., <code>"Cs-137"</code>). The search is flexible and ignores spaces or hyphens, so <code>"cs137"</code> will also work. As you type, a list of the top 10 suggestions will appear, prioritized by how common the nuclide is, to help you find what you're looking for faster.
              </p>
              <h4 className="italic mt-4">The Nuclide Card</h4>
              <p>
                  Once you select a nuclide, its detailed information card is displayed. This card is a comprehensive summary, containing key data points grouped into logical sections like **Decay Properties**, **Physical Properties**, **Genealogy**, **Transportation Limits**, **Internal Dosimetry**, and **Principal Emissions**. You can add a nuclide to your persistent <strong>Favorites</strong> list by clicking the star icon in the top right, making it easily accessible from the home page.
              </p>
            
              <hr className="my-4" />
            
              <h2 className="text-slate-900 dark:text-slate-100"><strong>Core Features</strong></h2>
              <p>The main navigation bar provides access to all the specialized tools and views within the application.</p>
            
              <h3 className="mt-6"><strong>Database & Compare</strong></h3>
              <ul>
                  <li><strong>Database:</strong> This view is for discovery and exploration. It allows you to browse and sort the entire collection of radionuclides. The sidebar on the left provides a powerful set of filters to help you find nuclides with specific properties, such as category, emission type, half-life, and energy ranges. This is perfect for finding the right nuclide for a specific application.</li>
                  <li><strong>Compare:</strong> This tool is designed for nuanced analysis, allowing you to view multiple nuclides in a side-by-side table. This is especially useful for comparing similar candidates for a task, such as different isotopes for brachytherapy or medical imaging. The table automatically highlights the minimum and maximum values in each numerical row and displays in-cell data bars to provide an immediate visual sense of magnitude. This view also includes an <strong>Export to CSV</strong> function.</li>
              </ul>
            
              <h3 className="mt-6"><strong>Calculators</strong></h3>
              <p>The application includes a comprehensive suite of calculators for a wide range of radiological scenarios.</p>
            
              <h4 className="italic mt-4">Decay Calculators</h4>
              <p>This group of tools handles the physics of radioactive decay over time.</p>
              <ul>
                  <li><strong>Decay Tools:</strong> A multi-tool for fundamental decay calculations. The <strong>Standard</strong> tab solves the fundamental decay equation for any one variable (initial activity, remaining activity, or time). The <strong>Correction</strong> tab is a specialized tool for correcting a source's activity from its calibration date to a new date. The <strong>To Limit</strong> tab calculates the time required for a source to decay to a specific activity level, which is useful for waste management.</li>
                  <li><strong>Series Decay:</strong> This advanced tool uses the full Bateman equations to model the activity of <em>every</em> nuclide in a long decay chain (like the Uranium or Thorium series) over time. It provides both a final activity table and an interactive chart showing the in-growth and decay of each progeny, which is essential for understanding complex decay dynamics.</li>
                  <li><strong>Equilibrium:</strong> This calculator specifically analyzes a parent-daughter pair to determine their equilibrium relationship. It will automatically classify the relationship as <strong>Secular</strong> (parent half-life is much longer than daughter's) or <strong>Transient</strong> (parent half-life is longer, but not by a huge margin) and calculates important metrics like the time to maximum daughter activity.</li>
              </ul>
            
              <h4 className="italic mt-4">Dose & Shielding Calculators</h4>
              <p>These tools are for external dosimetry, helping to estimate radiation dose and the shielding required to reduce it.</p>
              <ul>
                  <li><strong>Dose & Dose Rate:</strong> A versatile tool with multiple modes. <strong>Gamma</strong> mode models dose from Point, Line, and Area (Disk) geometries. <strong>Beta</strong> mode includes two sub-calculators: Skin Dose from surface contamination and Dose in Air from a point source. <strong>Bremsstrahlung</strong> mode estimates the secondary X-ray dose produced when beta particles are stopped by shielding. <strong>Internal</strong> mode calculates the Committed Effective Dose Equivalent (CEDE) from an intake using 10 CFR 20 ALI values.</li>
                  <li><strong>Shielding:</strong> This calculator models the attenuation of radiation. The <strong>Gamma</strong> modes calculate the final dose rate after passing through a shield or the required shield thickness to reach a target dose rate. It includes an optional Buildup Factor correction for a more accurate result in broad beam geometries. The <strong>Beta Range</strong> mode calculates the thickness of low-Z material required to completely stop beta particles.</li>
                  <li><strong>Stay Time:</strong> A practical tool for ALARA planning. It calculates the maximum time a person can stay in an area with a known dose rate before accumulating a specific dose limit.</li>
              </ul>
            
              <h4 className="italic mt-4">Operational HP Tools</h4>
              <p>A suite of calculators designed for day-to-day radiation safety tasks and survey analysis.</p>
              <ul>
                 <li><strong>Surface Contamination:</strong> A comprehensive tool that calculates both removable contamination (from a wipe test) and total contamination (from a static probe survey). It automatically compares the results against the standard limits found in both NRC Regulatory Guide 1.86 and ANSI N13.12.</li>
                 <li><strong>Leak Test:</strong> A specialized version of the wipe survey calculator for evaluating sealed sources against the common 0.005 µCi regulatory limit for removable contamination.</li>
                 <li><strong>Airborne Release:</strong> This tool models a theoretical airborne release in a room to calculate the initial concentration in DAC (Derived Air Concentration) units. It also estimates the time required for the room's ventilation system (in Air Changes per Hour) to reduce the concentration back down to 1 DAC.</li>
                 <li><strong>Detector Response:</strong> Estimates the count rate (cpm) a detector would see from a source, accounting for geometry, efficiency, and shielding. Includes models for NaI(Tl) and GM probes.</li>
              </ul>
            
              {/* --- NEW SECTION: Medical Physics --- */}
              <h4 className="italic mt-4">Medical Physics Tools</h4>
              <p>Calculators tailored to scenarios commonly found in a medical or hospital environment.</p>
              <ul>
                 <li><strong>X-Ray Shielding:</strong> A screening tool to calculate the required thickness of lead, concrete, or drywall for diagnostic X-ray rooms. It is based on the NCRP Report No. 147 methodology, accounting for workload, use factor, occupancy, and distance.</li>
                 <li><strong>Patient Release:</strong> This tool helps determine if a patient administered with a radiopharmaceutical can be released from the hospital based on the criteria in 10 CFR 35.75. It checks against activity-based limits, dose-rate limits, or a full public dose calculation (TEDE) based on occupancy scenarios.</li>
              </ul>
            
              {/* --- NEW SECTION: Neutron Tools --- */}
              <h4 className="italic mt-4">Neutron Tools</h4>
              <p>A set of specialized calculators for dealing with neutron radiation, a common consideration in reactor and accelerator facilities.</p>
              <ul>
                 <li><strong>Fluence/Dose:</strong> Converts between neutron fluence (n/cm²) and dose equivalent (rem or Sv) for a given neutron energy. The conversion is performed using a log-log interpolation of the quality factors and fluence-per-rem data specified in 10 CFR 20.</li>
                 <li><strong>Activation:</strong> Calculates the activity of a product nuclide created by irradiating a specific target material in a known thermal neutron flux for a given amount of time. It includes both a database of common (n,γ) reactions and a manual input mode for custom scenarios.</li>
                 <li><strong>Composite Activation:</strong> Estimates the principal activation products from irradiating common composite materials like concrete or steel, which contain trace elements that can become significant activation products.</li>
                 <li><strong>Shielding:</strong> Estimates the attenuation of fast or thermal neutrons through various common shielding materials using approximate Half-Value Layer (HVL) data.</li>
              </ul>
            
              {/* --- NEW SECTION: MARSSIM --- */}
              <h4 className="italic mt-4">MARSSIM Tools</h4>
              <p>A suite of tools dedicated to planning and evaluating final status surveys according to the Multi-Agency Radiation Survey and Site Investigation Manual.</p>
              <ul>
                  <li><strong>MDA/MDC:</strong> Calculates key decision values for radiation counting instrumentation. It includes a mode for <strong>Static Count MDA</strong> (based on NUREG-1507) and <strong>Scan Survey MDC</strong> (based on MARSSIM formulas) to ensure your survey methods can detect contamination at the required levels.</li>
                  <li><strong>Sample Design:</strong> A two-part suite. The <strong>Calculator</strong> determines the required number of statistical samples for a survey unit using the Wilcoxon Rank Sum (WRS) test methodology. The <strong>Drawing Tool</strong> provides an interactive map to draw survey unit boundaries and automatically generate sample locations in a square grid, triangular grid, or random pattern.</li>
                  <li><strong>Statistical Tests:</strong> Performs the two primary MARSSIM statistical tests on a set of data. The <strong>WRS Test</strong> is used to compare a survey unit to a reference area to determine if it meets the release criteria. The <strong>EMC Sign Test</strong> is used for evaluating localized areas of elevated activity to ensure they are not a significant risk.</li>
              </ul>
            
              {/* --- NEW SECTION: Lab Stats --- */}
              <h4 className="italic mt-4">Lab Statistics & QA/QC</h4>
              <p>Tools for quality assurance and control of radiation counting equipment and laboratory processes.</p>
              <ul>
                 <li><strong>Chi-Squared (χ²) Test:</strong> This is a key performance test for a counting system. It performs a chi-squared test on a set of repeated counts of a stable source to check if the observed variance is consistent with a random Poisson distribution, ensuring the detector is functioning properly.</li>
                 <li><strong>Dead Time Correction:</strong> Corrects an observed count rate for counts that were missed due to detector dead time—the brief period after detecting a particle when the system is busy and cannot register another. This is crucial for accurate measurements at high count rates.</li>
                 <li><strong>RPD:</strong> Calculates the Relative Percent Difference between two duplicate samples to evaluate measurement precision and the reproducibility of your lab processes.</li>
                 <li><strong>FWHM / Resolution:</strong> Calculates a detector's Full Width at Half Maximum (FWHM) and energy resolution from a photopeak's properties (centroid and half-max energies). This is a fundamental measure of a gamma spectroscopy system's performance.</li>
              </ul>
            
              <h4 className="italic mt-4">Utility Tools</h4>
              <p>A collection of helpful tools to streamline your workflow.</p>
              <ul>
                  <li><strong>Peak Identifier:</strong> An essential tool for spectroscopy. The <strong>Search</strong> tab finds matching radionuclides for a given peak energy and tolerance. It also analyzes for common spectral artifacts like Compton Edges, escape peaks, and lead X-rays. The <strong>Data Tables</strong> tab provides a comprehensive, sortable, and filterable list of all alpha, beta, and gamma emissions in the database.</li>
                  <li><strong>Activity/Mass Tools:</strong> A three-in-one module. <strong>Mass ↔ Activity</strong> converts between a nuclide's mass and its activity using its specific activity. <strong>Activity from Dose</strong> calculates a source's activity based on a gamma dose rate measurement. <strong>Specific Activity</strong> is a first-principles calculator for determining a nuclide's SA (Bq/g) from its atomic weight and half-life.</li>
                  <li><strong>Radon Tools:</strong> A three-part suite for radon analysis. <strong>Concentration</strong> converts between radon concentration units (e.g., pCi/L and Bq/m³) and estimates annual dose. <strong>Ingrowth</strong> calculates the Rn-222 activity from a given mass of its parent, Ra-226. <strong>Kusnetz (WL)</strong> determines the Working Level of radon progeny from air sampling data.</li>
                  <li><strong>Transportation:</strong> Determines the required shipping package type (Excepted, Type A, or Type B) for a given radionuclide and activity, based on its IAEA A₁ (special form) and A₂ (normal form) values.</li>
                  <li><strong>Converter:</strong> A general-purpose unit converter for activity, dose, dose rate, energy, concentration, and other common physical units.</li>
                  <li><strong>Scratchpad:</strong> A persistent text area for jotting down notes or intermediate results. Notes are saved to your browser's local storage.</li>
                  <li><strong>Scientific Calculator:</strong> A professional-grade calculator with "Smart Start" (operators apply to previous answer), memory functions, scientific notation (`EXP`), and quick-insert buttons for physics constants.</li>
              </ul>
            
              <hr className="my-4" />
            
              <h2 className="text-slate-900 dark:text-slate-100"><strong>Formulas & Equations Reference</strong></h2>
            
              <h3 className="mt-6"><b>Decay & Activity Formulas</b></h3>
              <h4 className="italic mt-4">Radioactive Decay</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>A(t) = A₀ · e<sup>-λt</sup></pre>
              </div>
              <ul>
                  <li><code>A(t)</code> = Activity at time t</li>
                  <li><code>A₀</code> = Initial activity at t=0</li>
                  <li><code>λ</code> = Decay constant (ln(2) / T<sub>1/2</sub>)</li>
                  <li><code>t</code> = Elapsed time</li>
              </ul>
            
              <h4 className="italic mt-4">Series (Bateman) Decay for a 2-step chain (A → B)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>A₂(t) = [A₁(0)·λ₂/(λ₂-λ₁)]·[e<sup>-λ₁t</sup> - e<sup>-λ₂t</sup>] + A₂(0)e<sup>-λ₂t</sup></pre>
              </div>
               <ul>
                  <li><code>A₂(t)</code> = Activity of the daughter at time t</li>
                  <li><code>A₁(0)</code> = Initial activity of the parent</li>
                  <li><code>A₂(0)</code> = Initial activity of the daughter</li>
                  <li><code>λ₁</code>, <code>λ₂</code> = Decay constants for parent and daughter, respectively</li>
              </ul>
            
              <h4 className="italic mt-4">Specific Activity (SA)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>SA (Bq/g) = (Nₐ · λ) / Mₐ</pre>
              </div>
              <ul>
                  <li><code>Nₐ</code> = Avogadro's Number (6.022 x 10²³ atoms/mol)</li>
                  <li><code>Mₐ</code> = Molar mass of the radionuclide (g/mol)</li>
                  <li><code>λ</code> = Decay constant in seconds⁻¹</li>
              </ul>
            
              <h3 className="mt-6"><b>Dose & Shielding Formulas</b></h3>
              <h4 className="italic mt-4">Gamma Dose Rate (Point Source)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>Dose Rate = (Γ · A) / d²</pre>
              </div>
              <ul>
                  <li><code>Γ</code> = Specific gamma-ray constant (e.g., in R·m²/hr·Ci)</li>
                  <li><code>A</code> = Source activity (in Ci)</li>
                  <li><code>d</code> = Distance from the source (in m)</li>
              </ul>
            
              <h4 className="italic mt-4">Gamma Shielding</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>D(x) = D₀ · B · (0.5)<sup>(x / HVL)</sup></pre>
              </div>
              <ul>
                  <li><code>D(x)</code> = Dose rate after shielding</li>
                  <li><code>D₀</code> = Initial dose rate</li>
                  <li><code>B</code> = Buildup Factor, for scattered photons</li>
                  <li><code>x</code> = Shield thickness</li>
                  <li><code>HVL</code> = Half-Value Layer thickness for the material</li>
              </ul>
            
              {/* --- NEW FORMULA: Patient Release --- */}
              <h4 className="italic mt-4">Patient Release TEDE (10 CFR 35.75)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>TEDE (rem) ≈ 1.443 · Γ · A₀ · T<sub>eff</sub> · Σ(tᵢ / dᵢ²)</pre>
              </div>
              <ul>
                  <li><code>Γ</code> = Gamma constant (R·m²/hr·mCi)</li>
                  <li><code>A₀</code> = Initial activity (mCi)</li>
                  <li><code>T<sub>eff</sub></code> = Effective half-life (hours)</li>
                  <li><code>tᵢ</code> = Occupancy time fraction for scenario i (hours/24)</li>
                  <li><code>dᵢ</code> = Distance for scenario i (m)</li>
              </ul>
            
              <h3 className="mt-6"><b>Operational HP Formulas</b></h3>
              <h4 className="italic mt-4">Wipe / Leak Test Activity</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>Activity (µCi) = (CPM<sub>net</sub>) / (ε<sub>inst</sub> · ε<sub>smear</sub> · 2.22x10⁶)</pre>
              </div>
              <ul>
                  <li><code>CPM<sub>net</sub></code> = Gross CPM - Background CPM</li>
                  <li><code>ε<sub>inst</sub></code> = Instrument efficiency (as a fraction)</li>
                  <li><code>ε<sub>smear</sub></code> = Smear/wipe efficiency (typically 0.1)</li>
                  <li><code>2.22x10⁶</code> = DPM per µCi</li>
              </ul>
            
              <h4 className="italic mt-4">Airborne Concentration</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>C(t) = (A / V) · e<sup>(-ACH · t)</sup></pre>
              </div>
              <ul>
                  <li><code>C(t)</code> = Concentration at time t</li>
                  <li><code>A</code> = Released activity</li>
                  <li><code>V</code> = Room volume</li>
                  <li><code>ACH</code> = Air Changes per Hour</li>
                  <li><code>t</code> = Time in hours</li>
              </ul>
            
              {/* --- Neutron Formulas --- */}
              <h3 className="mt-6"><b>Neutron Formulas</b></h3>
              <h4 className="italic mt-4">Thermal Neutron Activation</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>A(t) = N · σ · φ · (1 - e<sup>-λt</sup>)</pre>
              </div>
              <ul>
                  <li><code>A(t)</code> = Activity of product at time t (Bq)</li>
                  <li><code>N</code> = Number of target atoms</li>
                  <li><code>σ</code> = Thermal neutron cross-section (cm²)</li>
                  <li><code>φ</code> = Neutron flux (n/cm²·s)</li>
                  <li><code>λ</code> = Decay constant of the product nuclide</li>
                  <li><code>t</code> = Irradiation time (s)</li>
              </ul>
            
              {/* --- MARSSIM Formulas --- */}
              <h3 className="mt-6"><b>MARSSIM Formulas</b></h3>
              <h4 className="italic mt-4">Static Count MDA (NUREG-1507)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>LLD (counts) = 2.71 + 4.65 · √(R<sub>b</sub> · t<sub>s</sub>)</pre>
              </div>
              <ul>
                  <li><code>LLD</code> = Lower Limit of Detection (net counts)</li>
                  <li><code>R<sub>b</sub></code> = Background count rate (cpm)</li>
                  <li><code>t<sub>s</sub></code> = Sample count time (min)</li>
              </ul>
            
              <h4 className="italic mt-4">Scan MDC</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>Scan MDC = MDCR / (√(p) · ε<sub>total</sub>)</pre>
              </div>
              <ul>
                  <li><code>MDCR</code> = Minimum Detectable Count Rate</li>
                  <li><code>p</code> = Surveyor efficiency</li>
                  <li><code>ε<sub>total</sub></code> = Total efficiency (instrument * surface)</li>
              </ul>
            
              <h4 className="italic mt-4">Number of Samples (WRS Test)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>N = (Z₁<sub>-α</sub> + Z₁<sub>-β</sub>)² / (3 · (Pᵣ - 0.5)²)</pre>
              </div>
               <ul>
                  <li><code>Z₁<sub>-α</sub></code>, <code>Z₁<sub>-β</sub></code> = Z-scores for Type I/II error rates</li>
                  <li><code>Pᵣ</code> = Probability value from MARSSIM Table 5.2 based on Relative Shift</li>
              </ul>
            
              {/* --- NEW SECTION: Lab Stats Formulas --- */}
              <h3 className="mt-6"><b>Lab Statistics Formulas</b></h3>
              <h4 className="italic mt-4">Chi-Squared (χ²) Test</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>χ² = Σ((xᵢ - x̄)²) / x̄</pre>
              </div>
               <ul>
                  <li><code>xᵢ</code> = Individual count value</li>
                  <li><code>x̄</code> = Mean of all count values</li>
              </ul>
            
              <h4 className="italic mt-4">Dead Time Correction</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>N = R / (1 - Rτ)</pre>
              </div>
               <ul>
                  <li><code>N</code> = True count rate (cps)</li>
                  <li><code>R</code> = Observed count rate (cps)</li>
                  <li><code>τ</code> = Detector dead time (seconds)</li>
              </ul>
            
              <h4 className="italic mt-4">Relative Percent Difference (RPD)</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>RPD (%) = |S₁ - S₂| / ((S₁ + S₂) / 2) · 100</pre>
              </div>
              <ul>
                  <li><code>S₁</code>, <code>S₂</code> = Values for the two duplicate samples</li>
              </ul>
            
              <h4 className="italic mt-4">Energy Resolution</h4>
              <div className="my-2 p-3 text-center text-lg font-mono rounded-md bg-slate-100 dark:bg-slate-800 overflow-x-auto">
                  <pre>Resolution (%) = (FWHM / E) · 100</pre>
              </div>
               <ul>
                  <li><code>FWHM</code> = Full Width at Half Maximum of the peak (keV)</li>
                  <li><code>E</code> = Peak centroid energy (keV)</li>
              </ul>
            
              <hr className="my-4" />
            
              <h2 className="text-slate-900 dark:text-slate-100"><strong>Frequently Asked Questions (FAQ)</strong></h2>
              <h4 className="italic mt-4">Where does the data come from?</h4>
              <p>The data is aggregated from highly reliable, standard industry sources:</p>
              <ul>
                  <li><strong>Nuclear Data (Half-life, emissions, etc.):</strong> National Nuclear Data Center's (NNDC) NuDat 3 database.</li>
                  <li><strong>Dosimetry Data (ALI, DAC):</strong> U.S. Nuclear Regulatory Commission, 10 CFR 20, Appendix B.</li>
                  <li><strong>Gamma Constants & HVL Data:</strong> Standard, commonly-cited values from health physics texts (e.g. Radiological Health Handbook, Plexus-NSD).</li>
                  <li><strong>MARSSIM Formulas:</strong> NUREG-1575 (MARSSIM), NUREG-1507.</li>
              </ul>
            
              <h4 className="italic mt-4">Why doesn't a specific nuclide appear in a calculator?</h4>
              <p>Calculators are populated only with nuclides that have the necessary data for that specific calculation. For example, the <strong>Dose Rate</strong>, <strong>Shielding</strong>, and <strong>Stay Time</strong> calculators all require a nuclide to have a defined "Gamma Constant" (Γ). Therefore, pure beta emitters (like Tritium or Carbon-14) or pure alpha emitters will not be available in those specific tools. Similarly, the **Activation Calculator** only lists target nuclides known to produce common activation products.</p>
            
              {/* --- NEW CONTACT SECTION --- */}
              <hr className="my-4" />
              <h2 className="text-slate-900 dark:text-slate-100"><strong>Contact & Bug Reports</strong></h2>
              <div className="bg-slate-100 dark:bg-slate-800 p-4 rounded-lg border border-slate-200 dark:border-slate-700">
                  <p className="mb-2"><strong>Found a bug or have a feature request?</strong></p>
                  <p className="text-sm">
                      This tool is actively maintained. Your feedback helps improve accuracy and usability.
                      Please include the <strong>Browser/OS version</strong> and a <strong>description</strong> of the issue.
                  </p>
                  <div className="mt-4">
                      <a
                          href="mailto:jough.donakowski@gmail.com?subject=Health Physics Toolbox - Bug Report"
                          className="inline-flex items-center gap-2 px-4 py-2 bg-sky-600 text-white font-bold rounded-lg hover:bg-sky-700 transition-colors"
                      >
                          <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                          </svg>
                          Send Bug Report
                      </a>
                      <p className="text-xs text-slate-500 mt-2">
                          Or email directly: <strong>jough.donakowski@gmail.com</strong>
                      </p>
                  </div>
              </div>
            
              <h4 className="italic mt-4">Disclaimer</h4>
              <p><strong>This tool is for informational and educational purposes only.</strong> The data and calculations have not been independently peer-reviewed or validated and may contain errors. It should not be used for radiation protection, safety-critical applications, operational decision-making, or for demonstrating regulatory compliance. All use of this tool is at your own risk.</p>
            </div>
            );
            };
            
            return (
            <div className="fixed inset-0 bg-black/60 z-[5000] flex justify-center items-start p-4" onClick={onClose}>
            <div className="bg-white dark:bg-slate-900 w-full max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col" onClick={e => e.stopPropagation()}>
              <div className="p-4 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
                  <h2 className="text-xl font-bold">User Manual & FAQ</h2>
                  <button onClick={onClose} className="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">
                      <Icon path={ICONS.clear} className="w-6 h-6" />
                  </button>
              </div>
              <div className="overflow-y-auto">
                  <ManualContent />
              </div>
            </div>
            </div>
            );
            };
            
            /**
            * @description React component for managing user settings and preferences.
            * This panel provides a user interface to configure various default units and modes
            * for the application's calculators, tailoring the user experience to their specific
            * needs and regional standards.
            *
            * Key functionalities include:
            * - **Unit Selection:** Users can set their preferred default units for common
            * quantities like Activity, Dose Rate, and Distance.
            * - **Mode Selection:** Users can choose the default calculator mode for multi-mode tools,
            * such as the Dose Calculator.
            * - **Data Management:** A "Reset to Defaults" button allows users to clear all locally
            * saved data, including their custom settings, favorites list, and calculator inputs,
            * via a confirmation modal. This ensures a clean slate, if needed.
            *
            * This component utilizes a global `SettingsContext` to persist and retrieve user preferences
            * across the application's various tools.
            */
            
            const SettingsPanel = () => {
            const { settings, updateSettings } = React.useContext(SettingsContext);
            const theme = settings.theme; 
            const [isResetModalOpen, setIsResetModalOpen] = React.useState(false);
            
            const handleSettingChange = (key, value) => {
            updateSettings({ [key]: value });
            };
            
            const handleResetDefaults = () => {
            localStorage.clear();
            sessionStorage.setItem('showResetToast', 'true');
            window.location.reload();
            };
            
            return (
            <>
               <div className="p-4 animate-fade-in">
                   <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                       <h2 className="text-xl font-bold text-slate-800 dark:text-white">Settings</h2>
                       <p className="text-sm text-slate-600 dark:text-slate-300 mb-6">
                           Manage application theme and saved data.
                       </p>
            
                       {/* --- Theme Section --- */}
                       <div className="space-y-4">
                           <div>
                               <label className="block text-sm font-medium mb-2">Theme</label>
                               <div className="grid grid-cols-3 gap-2 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg">
                                    <button onClick={() => handleSettingChange('theme', 'light')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${settings.theme === 'light' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Light</button>
                                    <button onClick={() => handleSettingChange('theme', 'dark')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${settings.theme === 'dark' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Dark</button>
                                    <button onClick={() => handleSettingChange('theme', 'system')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${settings.theme === 'system' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>System</button>
                               </div>
                           </div>
            
            <div>
                                   <label className="block text-sm font-medium mb-2">Unit System</label>
                                   <div className="grid grid-cols-2 gap-2 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg">
                                        <button onClick={() => handleSettingChange('unitSystem', 'conventional')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${settings.unitSystem === 'conventional' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Conventional (Ci, rem)</button>
                                        <button onClick={() => handleSettingChange('unitSystem', 'si')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${settings.unitSystem === 'si' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>SI (Bq, Sv)</button>
                                   </div>
                               </div>
            
                       </div>
            
                       {/* --- About Section --- */}
                       <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700 space-y-2 text-center text-xs text-slate-500 dark:text-slate-400">
                            <p><strong>Health Physics Toolbox</strong> Version {VERSION}</p>
                            <p>Last Updated: {LAST_UPDATED}</p>
                            <p>Created by Jough Donakowski</p>
                       </div>
            
                       {/* --- Reset Section --- */}
                       <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
                           <h3 className="text-lg font-semibold text-slate-700 dark:text-slate-200">Application Data</h3>
                            <p className="text-sm text-slate-600 dark:text-slate-300 mb-4">This will clear all saved calculator inputs, favorites, search history, and settings.</p>
                           <button onClick={() => setIsResetModalOpen(true)} className="w-full py-2 bg-red-100 dark:bg-red-900/50 text-red-600 dark:text-red-400 font-semibold rounded-lg hover:bg-red-200 dark:hover:bg-red-900 transition">Reset All Saved Data</button>
                       </div>
                   </div>
               </div>
               <ConfirmationModal isOpen={isResetModalOpen} onClose={() => setIsResetModalOpen(false)} onConfirm={handleResetDefaults} title="Reset All Settings & Saved Data?"><p>Are you sure? This will clear <strong>all</strong> saved calculator inputs, favorites, search history, and default settings. The application will reload with its original defaults. This action cannot be undone.</p></ConfirmationModal>
            </>
            );
            };
            
            
            const PopoutWindow = ({ children, title, onClose, width = 450, height = 750 }) => {
                const [container, setContainer] = React.useState(null);
                const newWindow = React.useRef(null);
            
                React.useEffect(() => {
                    newWindow.current = window.open('', title, `width=${width},height=${height},resizable=yes`);
            
                    // --- THIS LINE IS UPDATED to include text colors ---
                    newWindow.current.document.body.className = "bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200";
            
                    const popoutRoot = newWindow.current.document.createElement('div');
                    newWindow.current.document.body.appendChild(popoutRoot);
            
            const reactScript = newWindow.current.document.createElement('script');
            reactScript.src = "https://unpkg.com/react@18/umd/react.development.js";
            reactScript.crossOrigin = true;
            newWindow.current.document.head.appendChild(reactScript);
            
            const reactDomScript = newWindow.current.document.createElement('script');
            reactDomScript.src = "https://unpkg.com/react-dom@18/umd/react-dom.development.js";
            reactDomScript.crossOrigin = true;
            newWindow.current.document.head.appendChild(reactDomScript);
            
            const babelScript = newWindow.current.document.createElement('script');
            babelScript.src = "https://unpkg.com/@babel/standalone/babel.min.js";
            newWindow.current.document.head.appendChild(babelScript);
            
                    document.head.querySelectorAll('link[rel="stylesheet"], style').forEach(node => {
                        newWindow.current.document.head.appendChild(node.cloneNode(true));
                    });
            
                    const tailwindScript = newWindow.current.document.createElement('script');
                    tailwindScript.src = "https://cdn.tailwindcss.com";
                    newWindow.current.document.head.appendChild(tailwindScript);
                    const tailwindConfigScript = newWindow.current.document.createElement('script');
                    tailwindConfigScript.innerHTML = `tailwind.config = { darkMode: 'class' }`;
                    newWindow.current.document.head.appendChild(tailwindConfigScript);
            
                    newWindow.current.document.documentElement.className = document.documentElement.className;
            
                    setContainer(popoutRoot);
            
                    const handleUnload = () => { onClose(); };
                    newWindow.current.addEventListener('beforeunload', handleUnload);
            
                    return () => {
                        newWindow.current.removeEventListener('beforeunload', handleUnload);
                        if (newWindow.current) {
                           newWindow.current.close();
                        }
                        setContainer(null);
                    };
                }, []);
            
                if (!container) return null;
            
                return ReactDOM.createPortal(children, container);
            };
            
            /**
            * @description The root component of the entire application.
            * It manages all primary state, handles routing between views, and orchestrates all user interactions.
            */
            
            const App = () => {
            // --- 1. SETTINGS CONTEXT & THEME RESOLUTION ---
            const { settings, updateSettings } = React.useContext(SettingsContext);
            
            // Resolve 'system' setting to actual 'dark' or 'light' string for charts/icons
            const getEffectiveTheme = () => {
            if (settings.theme === 'system') {
               return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }
            return settings.theme;
            };
            
            // Define 'theme' so it can be passed to Header and Calculators
            const theme = getEffectiveTheme();
            
            const toggleTheme = () => {
            // If current is dark, switch to light, otherwise dark
            updateSettings({ theme: theme === 'dark' ? 'light' : 'dark' });
            };
            
            // --- 2. EXISTING STATE ---
            
            const [activeView, setActiveView] = React.useState(VIEWS.HOME);
            
            const [previousView, setPreviousView] = React.useState(VIEWS.HOME);
            
            const [showCalcPopout, setShowCalcPopout] = React.useState(false);
            const [showScratchpadPopout, setShowScratchpadPopout] = React.useState(false);
            const [detailedNuclide, setDetailedNuclide] = React.useState(null);
            const [errorMessage, setErrorMessage] = React.useState('');
            const [preselectedNuclide, setPreselectedNuclide] = React.useState(null);
            const [comparisonList, setComparisonList] = React.useState(() => { try { return JSON.parse(localStorage.getItem('radionuclideComparisonList') || '[]'); } catch (e) { return []; } });
            const [nuclideName, setNuclideName] = React.useState('');
            const debouncedSearchTerm = useDebounce(nuclideName, 250);
            const [suggestions, setSuggestions] = React.useState([]);
            const [activeSuggestionIndex, setActiveSuggestionIndex] = React.useState(-1);
            const [isManualOpen, setIsManualOpen] = React.useState(false);
            const [isFiltersVisible, setIsFiltersVisible] = React.useState(false);
            const [displayHalfLifeUnit, setDisplayHalfLifeUnit] = React.useState('years');
            const [currentDecaySeriesId, setCurrentDecaySeriesId] = React.useState(null);
            
            const [searchHistory, setSearchHistory] = React.useState(() => { try { return JSON.parse(localStorage.getItem('radionuclideSearchHistory') || '[]'); } catch (e) { return []; } });
            const [favorites, setFavorites] = React.useState(() => { try { return JSON.parse(localStorage.getItem('favoriteNuclides') || '[]'); } catch (e) { return []; } });
            const [randomSuggestions, setRandomSuggestions] = React.useState([]);
            const [isSearchFocused, setIsSearchFocused] = React.useState(false);
            
            const [opHpActiveTab, setOpHpActiveTab] = React.useState('surfaceContam');
            
            const [scientificCalculatorState, setScientificCalculatorState] = React.useState(() => {
            const savedState = localStorage.getItem('scientificCalculatorState');
            return savedState ? JSON.parse(savedState) : { expression: '', result: '', history: [], memory: 0 };
            });
            
            // Add this useEffect to save the state whenever it changes
            React.useEffect(() => {
            localStorage.setItem('scientificCalculatorState', JSON.stringify(scientificCalculatorState));
            }, [scientificCalculatorState]);
            
            const [scratchpadNotes, setScratchpadNotes] = React.useState(
            () => localStorage.getItem('user_scratchpad_notes') || ''
            );
            
            const [sortBy, setSortBy] = React.useState(() => localStorage.getItem('filterSortBy') || 'name');
            const [sortOrder, setSortOrder] = React.useState(() => localStorage.getItem('filterSortOrder') || 'asc');
            const [selectedCategory, setSelectedCategory] = React.useState(() => localStorage.getItem('filterCategory') || 'All');
            const [selectedEmissionType, setSelectedEmissionType] = React.useState(() => localStorage.getItem('filterEmissionType') || 'All');
            const [selectedCommonality, setSelectedCommonality] = React.useState(() => localStorage.getItem('filterCommonality') || 'All');
            const [minAlphaEnergy, setMinAlphaEnergy] = React.useState(() => localStorage.getItem('filterMinAlphaEnergy') || '');
            const [maxAlphaEnergy, setMaxAlphaEnergy] = React.useState(() => localStorage.getItem('filterMaxAlphaEnergy') || '');
            const [minBetaEnergy, setMinBetaEnergy] = React.useState(() => localStorage.getItem('filterMinBetaEnergy') || '');
            const [maxBetaEnergy, setMaxBetaEnergy] = React.useState(() => localStorage.getItem('filterMaxBetaEnergy') || '');
            const [minGammaEnergy, setMinGammaEnergy] = React.useState(() => localStorage.getItem('filterMinGammaEnergy') || '');
            const [maxGammaEnergy, setMaxGammaEnergy] = React.useState(() => localStorage.getItem('filterMaxGammaEnergy') || '');
            const [minHalfLife, setMinHalfLife] = React.useState(() => localStorage.getItem('filterMinHalfLife') || '');
            const [maxHalfLife, setMaxHalfLife] = React.useState(() => localStorage.getItem('filterMaxHalfLife') || '');
            const [halfLifeFilterUnit, setHalfLifeFilterUnit] = React.useState(() => localStorage.getItem('filterHalfLifeUnit') || 'years');
            
            const handleSearchFocus = () => setIsSearchFocused(true);
            const handleSearchBlur = () => {
            setTimeout(() => { setIsSearchFocused(false); }, 150);
            };
            
            const handleGoToDetectorResponse = () => {
            //  Pass 'response' as the second argument so handleNavClick knows to set the tab
            handleNavClick(VIEWS.OPERATIONAL_HP, 'response');
            };
            
            React.useEffect(() => {
            const handleHashChange = () => {
            const hash = window.location.hash.replace('#', '');
            const validViews = Object.values(VIEWS);
            let targetView = VIEWS.HOME;
            if (hash && validViews.includes(hash)) {
              targetView = hash;
            } else {
              history.replaceState(null, '', `#${VIEWS.HOME}`);
            }
            setActiveView(targetView);
            
            if (targetView === VIEWS.HOME) {
              setDetailedNuclide(null);
              setNuclideName('');
              setSuggestions([]);
              setErrorMessage('');
            }
            };
            window.addEventListener('hashchange', handleHashChange);
            handleHashChange();
            return () => window.removeEventListener('hashchange', handleHashChange);
            }, []);
            
            const mainContentRef = React.useRef(null);
            const scrollPositionRef = React.useRef(null);
            const inputRef = React.useRef(null);
            const suggestionsRef = React.useRef(null);
            const { addToast } = useToast();
            
            React.useEffect(() => {
            // Check if the new view is HOME and we are on a desktop (width > 768px)
            if (activeView === VIEWS.HOME && window.innerWidth > 768) {
               // Small timeout ensures the render is complete before focusing
               setTimeout(() => {
                   inputRef.current?.focus();
               }, 50);
            }
            }, [activeView]); // Dependency added here
            
            React.useEffect(() => {
            if (sessionStorage.getItem('showResetToast') === 'true') {
            addToast('All settings and saved data have been reset.');
            sessionStorage.removeItem('showResetToast');
            }
            }, [addToast]);
            
            const scrollToMainContent = () => {
            
            if (mainContentRef.current) {
            mainContentRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            };
            
            const handleNavClick = (view, opHpTab = null) => {
            // Save current view as 'previous' if we are changing views,
            // but ignore if we are just going to the Detail view (handled separately)
            // or if we are already on the References page to prevent circular history.
            if (activeView !== view && view !== VIEWS.DETAIL && view !== VIEWS.REFERENCES) {
               setPreviousView(activeView);
            }
            
            if (view !== VIEWS.DETAIL) {
               setDetailedNuclide(null);
            }
            
            // If opHpTab is passed (deep link), it sets it.
            // If undefined/null (normal nav), it clears it.
            setOpHpActiveTab(opHpTab);
            
            // When navigating manually, clear any pre-selections
            setPreselectedNuclide(null);
            setActiveView(view);
            window.location.hash = view;
            scrollToMainContent();
            };
            
            const handleClearSearch = () => {
            setNuclideName('');
            setSuggestions([]);
            setDetailedNuclide(null);
            handleNavClick(VIEWS.HOME);
            inputRef.current?.focus();
            };
            
            const handleSendToCalculator = (viewId, nuclideSymbol) => {
            // Find the full object so calculators can access .symbol property
            const n = radionuclides.find(r => r.symbol === nuclideSymbol);
            setPreselectedNuclide(n);
            window.location.hash = viewId;
            };
            
            const handleAddToCompare = (nuclideSymbol) => {
                const nuclideToAdd = radionuclides.find(n => n.symbol === nuclideSymbol);
                
                if (nuclideToAdd) {
                    setComparisonList(prevList => {
                        // Check for duplicates before adding
                        if (prevList.some(n => n.symbol === nuclideSymbol)) {
                            addToast(`${nuclideToAdd.name} is already in the comparison.`);
                            return prevList;
                        }
                        addToast(`${nuclideToAdd.name} added to comparison.`);
                        return [...prevList, nuclideToAdd];
                    });
                }
                window.location.hash = VIEWS.COMPARE;
            };
            
            const handleRemoveFromCompare = (nuclideSymbol) => { setComparisonList(prevList => prevList.filter(n => n.symbol !== nuclideSymbol)); };
            const handleClearCompare = () => { setComparisonList([]); addToast('Comparison list cleared.'); };
            
            React.useEffect(() => {
            localStorage.setItem('filterSortBy', sortBy);
            localStorage.setItem('filterSortOrder', sortOrder);
            localStorage.setItem('filterCategory', selectedCategory);
            localStorage.setItem('filterEmissionType', selectedEmissionType);
            localStorage.setItem('filterCommonality', selectedCommonality);
            localStorage.setItem('filterMinAlphaEnergy', minAlphaEnergy);
            localStorage.setItem('filterMaxAlphaEnergy', maxAlphaEnergy);
            localStorage.setItem('filterMinBetaEnergy', minBetaEnergy);
            localStorage.setItem('filterMaxBetaEnergy', maxBetaEnergy);
            localStorage.setItem('filterMinGammaEnergy', minGammaEnergy);
            localStorage.setItem('filterMaxGammaEnergy', maxGammaEnergy);
            localStorage.setItem('filterMinHalfLife', minHalfLife);
            localStorage.setItem('filterMaxHalfLife', maxHalfLife);
            localStorage.setItem('filterHalfLifeUnit', halfLifeFilterUnit);
            }, [sortBy, sortOrder, selectedCategory, selectedEmissionType, selectedCommonality, minAlphaEnergy, maxAlphaEnergy, minBetaEnergy, maxBetaEnergy, minGammaEnergy, maxGammaEnergy, minHalfLife, maxHalfLife, halfLifeFilterUnit]);
            
            React.useEffect(() => {
            localStorage.setItem('radionuclideComparisonList', JSON.stringify(comparisonList));
            }, [comparisonList]);
            
            React.useEffect(() => {
            const handleClickOutside = (e) => {
            if (suggestionsRef.current && !suggestionsRef.current.contains(e.target) && inputRef.current && !inputRef.current.contains(e.target)) {
              setSuggestions([]);
            }
            };
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);
            
            React.useEffect(() => {
            const common = radionuclides.filter(n => n.commonality === 'Common');
            setRandomSuggestions([...common].sort(() => 0.5 - Math.random()).slice(0, 5));
            }, [radionuclides]);
            
            const allCategories = React.useMemo(() => ['All', ...[...new Set(radionuclides.map(n => n.category))].sort()], [radionuclides]);
            const allEmissionTypes = React.useMemo(() => ['All', ...[...new Set(radionuclides.flatMap(n => n.emissionType || []))].sort()], [radionuclides]);
            const allCommonalityCategories = React.useMemo(() => ['All', ...[...new Set(radionuclides.map(n => n.commonality).filter(Boolean))].sort()], [radionuclides]);
            
            const getFilteredAndSortedRadionuclides = React.useCallback(() => {
            let filtered = [...radionuclides];
            if (selectedCategory !== 'All') { filtered = filtered.filter(n => n.category === selectedCategory); }
            if (selectedEmissionType !== 'All') { filtered = filtered.filter(n => n.emissionType?.includes(selectedEmissionType)); }
            if (selectedCommonality !== 'All') { filtered = filtered.filter(n => n.commonality === selectedCommonality); }
            
            const filterByEnergyRange = (nuclide, type, min, max) => {
                // Get all energies for this type (e.g., all gamma lines)
                const energies = nuclide.emissionEnergies?.[type] || [];
                
                // If no energies exist for this type...
                if (energies.length === 0) {
                    // ...but the user requested a specific range, exclude this nuclide.
                    if (min || max) return false;
                    // If user didn't request a range, keep it (neutral).
                    return true; 
                }
            
                const minVal = parseFloat(min);
                const maxVal = parseFloat(max);
            
                // If user inputs are invalid (empty), don't filter out anything based on them.
                const hasMin = !isNaN(minVal);
                const hasMax = !isNaN(maxVal);
                
                if (!hasMin && !hasMax) return true;
            
                // Check if AT LEAST ONE energy in the array meets the criteria
                // Previously, this only checked the first element via parseEnergyToMeV(energies)
                return energies.some(energyStr => {
                    // Use the utility to parse the single string "0.662 MeV" -> 0.662
                    const parts = energyStr.split(' ');
                    let val = parseFloat(parts[0]);
                    if (parts[1]?.toLowerCase().includes('kev')) val /= 1000;
                    
                    if (isNaN(val)) return false;
                    
                    if (hasMin && hasMax) return val >= minVal && val <= maxVal;
                    if (hasMin) return val >= minVal;
                    if (hasMax) return val <= maxVal;
                    return true;
                });
            };
            
            if (minAlphaEnergy || maxAlphaEnergy) filtered = filtered.filter(n => filterByEnergyRange(n, 'alpha', minAlphaEnergy, maxAlphaEnergy));
            if (minBetaEnergy || maxBetaEnergy) filtered = filtered.filter(n => filterByEnergyRange(n, 'beta', minBetaEnergy, maxBetaEnergy));
            if (minGammaEnergy || maxGammaEnergy) filtered = filtered.filter(n => filterByEnergyRange(n, 'gamma', minGammaEnergy, maxGammaEnergy));
            if (minHalfLife || maxHalfLife) {
            const unitConversions = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400, 'years': 31557600 };
            const minSeconds = minHalfLife ? parseFloat(minHalfLife) * unitConversions[halfLifeFilterUnit] : null;
            const maxSeconds = maxHalfLife ? parseFloat(maxHalfLife) * unitConversions[halfLifeFilterUnit] : null;
            filtered = filtered.filter(n => {
              const nuclideSeconds = parseHalfLifeToSeconds(n.halfLife);
              if (nuclideSeconds === Infinity && (minSeconds || maxSeconds)) return false;
              const checkMin = minSeconds ? nuclideSeconds >= minSeconds : true;
              const checkMax = maxSeconds ? nuclideSeconds <= maxSeconds : true;
              return checkMin && checkMax;
            });
            }
            filtered.sort((a, b) => {
            let compare = 0;
            if (sortBy === 'name') compare = a.name.localeCompare(b.name);
            else if (sortBy === 'halfLife') compare = parseHalfLifeToSeconds(a.halfLife) - parseHalfLifeToSeconds(b.halfLife);
            else if (sortBy === 'alphaEnergy') compare = parseEnergyToMeV(a.emissionEnergies?.alpha) - parseEnergyToMeV(b.emissionEnergies?.alpha);
            else if (sortBy === 'betaEnergy') compare = parseEnergyToMeV(a.emissionEnergies?.beta) - parseEnergyToMeV(b.emissionEnergies?.beta);
            else if (sortBy === 'gammaEnergy') compare = parseEnergyToMeV(a.emissionEnergies?.gamma) - parseEnergyToMeV(b.emissionEnergies?.gamma);
            return sortOrder === 'asc' ? compare : -compare;
            });
            return filtered;
            }, [selectedCategory, selectedEmissionType, selectedCommonality, sortBy, sortOrder, minAlphaEnergy, maxAlphaEnergy, minBetaEnergy, maxBetaEnergy, minGammaEnergy, maxGammaEnergy, minHalfLife, maxHalfLife, halfLifeFilterUnit, radionuclides]);
            
            const filteredList = getFilteredAndSortedRadionuclides();
            
            const handleClearHistory = () => { setSearchHistory([]); localStorage.removeItem('radionuclideSearchHistory'); addToast('Search history cleared.'); };
            const handleDecaySeriesClick = (seriesId) => { setCurrentDecaySeriesId(seriesId); window.location.hash = VIEWS.DECAY_SERIES; };
            const toggleFavorite = (symbol) => { const nuclide = radionuclides.find(n => n.symbol === symbol); const isCurrentlyFavorite = favorites.includes(symbol); const newFavorites = isCurrentlyFavorite ? favorites.filter(s => s !== symbol) : [...favorites, symbol]; setFavorites(newFavorites); localStorage.setItem('favoriteNuclides', JSON.stringify(newFavorites)); if (isCurrentlyFavorite) { addToast(`${nuclide ? nuclide.name : symbol} removed from favorites.`); } else { addToast(`${nuclide ? nuclide.name : symbol} added to favorites!`); } };
            const handleClearFavorites = () => { setFavorites([]); localStorage.removeItem('favoriteNuclides'); addToast('Favorites list cleared.'); };
            const updateSearchHistory = (nuclide) => { setSearchHistory(prev => { const newHistory = [nuclide.symbol, ...prev.filter(symbol => symbol !== nuclide.symbol)]; const limitedHistory = newHistory.slice(0, 5); localStorage.setItem('radionuclideSearchHistory', JSON.stringify(limitedHistory)); return limitedHistory; }); }
            
            const handleNuclideSelection = (nuclide, skipHistory = false) => {
               // Save the current view if we are not already in the detail view.
               if (activeView !== VIEWS.DETAIL) {
                   setPreviousView(activeView);
               }
            
               setNuclideName(nuclide.name);
               
               // Only update history if the flag is FALSE (default behavior)
               if (!skipHistory) {
                   updateSearchHistory(nuclide);
               }
            
               setDetailedNuclide(nuclide);
               setSuggestions([]);
               setErrorMessage('');
               setCurrentDecaySeriesId(null);
               handleNavClick(VIEWS.DETAIL);
            };
            
            
            React.useEffect(() => {
            
            if (debouncedSearchTerm.length > 0) {
            // Don't show suggestions if the search term already matches the displayed nuclide
            if (detailedNuclide && debouncedSearchTerm === detailedNuclide.name) {
            setSuggestions([]);
            return;
            }
            const normVal = normalizeString(debouncedSearchTerm);
            const commonalityOrder = { 'Common': 3, 'Moderate': 2, 'Rare': 1 };
            
            const filtered = radionuclides
            .filter(n => normalizeString(n.name).includes(normVal) || normalizeString(n.symbol).includes(normVal))
            .sort((a, b) => {
              const orderA = commonalityOrder[a.commonality] || 0;
              const orderB = commonalityOrder[b.commonality] || 0;
              if (orderB !== orderA) return orderB - orderA; // Sort by commonality first
              return a.name.localeCompare(b.name); // Then alphabetically
            })
            .slice(0, 10);
            
            setSuggestions(filtered);
            } else {
            // If the search term is empty, clear suggestions and the detailed result.
            setSuggestions([]);
            if (detailedNuclide) { // Only change state if there's something to clear
            setDetailedNuclide(null);
            handleNavClick(VIEWS.HOME);
            }
            }
            }, [debouncedSearchTerm, radionuclides]); // Simplified dependencies
            
            const handleNuclideNameChange = (e) => {
            setNuclideName(e.target.value);
            if (e.target.value.length > 0) {
            setSelectedCategory('All');
            setSelectedEmissionType('All');
            setSelectedCommonality('All');
            setMinAlphaEnergy('');
            setMaxAlphaEnergy('');
            setMinBetaEnergy('');
            setMaxBetaEnergy('');
            setMinGammaEnergy('');
            setMaxGammaEnergy('');
            setMinHalfLife('');
            setMaxHalfLife('');
            }
            };
            
            const handleClearFilters = () => { setSortBy('name'); setSortOrder('asc'); setSelectedCategory('All'); setSelectedEmissionType('All'); setSelectedCommonality('All'); setMinAlphaEnergy(''); setMaxAlphaEnergy(''); setMinBetaEnergy(''); setMaxBetaEnergy(''); setMinGammaEnergy(''); setMaxGammaEnergy(''); setMinHalfLife(''); setMaxHalfLife(''); setHalfLifeFilterUnit('years'); };
            
            const handleLookup = () => {
            setSuggestions([]);
            const normInput = normalizeString(nuclideName);
            const found = radionuclides.find(n => normalizeString(n.name) === normInput || normalizeString(n.symbol) === normInput);
            if (found) {
            handleNuclideSelection(found);
            } else {
            setDetailedNuclide(null);
            setErrorMessage(`Nuclide "${nuclideName}" not found.`);
            setActiveView(VIEWS.HOME);
            }
            };
            
            const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
            if (activeSuggestionIndex !== -1 && suggestions.length > 0) {
              handleNuclideSelection(suggestions[activeSuggestionIndex]);
            } else {
              handleLookup();
            }
            } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            setActiveSuggestionIndex(prev => (prev < suggestions.length - 1 ? prev + 1 : 0));
            } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            setActiveSuggestionIndex(prev => (prev > 0 ? prev - 1 : suggestions.length - 1));
            } else if (e.key === 'Escape') {
            setSuggestions([]);
            }
            };
            
            const renderActiveView = () => {
            const filterProps = { sortBy, setSortBy, sortOrder, setSortOrder, selectedCategory, setSelectedCategory, allCategories, selectedEmissionType, setSelectedEmissionType, allEmissionTypes, selectedCommonality, setSelectedCommonality, allCommonalityCategories, minAlphaEnergy, setMinAlphaEnergy, maxAlphaEnergy, setMaxAlphaEnergy, minBetaEnergy, setMinBetaEnergy, maxBetaEnergy, setMaxBetaEnergy, minGammaEnergy, setMinGammaEnergy, maxGammaEnergy, setMaxGammaEnergy, minHalfLife, setMinHalfLife, maxHalfLife, setMaxHalfLife, halfLifeFilterUnit, setHalfLifeFilterUnit, clearFilters: handleClearFilters };
            switch (activeView) {
            case VIEWS.DATABASE: return <DatabaseView filteredList={filteredList} onNuclideClick={handleNuclideSelection} filterProps={filterProps} isFiltersVisible={isFiltersVisible} setIsFiltersVisible={setIsFiltersVisible} scrollPositionRef={scrollPositionRef} handleClearFilters={handleClearFilters} />;
            case VIEWS.CALCULATOR: return <DecayTools radionuclides={radionuclides} preselectedNuclide={preselectedNuclide} theme={theme} />;
            case VIEWS.MDA:
               return <MDACalculator onNavClick={handleNavClick} onDeepLink={handleGoToDetectorResponse} />;
            case VIEWS.MARSSIM_SAMPLES: return <MARSSIM_SampleDesign />;
            case VIEWS.WRS_TEST: return <WRS_Calculator />;
            case VIEWS.EMC_TEST: return <EMC_Calculator />;
            
            case VIEWS.SERIES_CALCULATOR:
            return <DecaySeriesCalculator
            radionuclides={radionuclides}
            decaySeriesData={decaySeriesData}
            theme={theme}
            onNuclideClick={handleNuclideSelection}
            />;
            case VIEWS.EQUILIBRIUM: return <EquilibriumCalculator radionuclides={radionuclides} theme={theme} />;
            case VIEWS.RADON: return <RadonCalculator />;
            case VIEWS.COMPARE: return <ComparisonView radionuclides={radionuclides} onNuclideClick={handleNuclideSelection} comparisonList={comparisonList} onAddToCompare={handleAddToCompare} onRemoveFromCompare={handleRemoveFromCompare} onClearCompare={handleClearCompare} />;
            case VIEWS.ACTIVITY_MASS: return <ActivityAndMassTools radionuclides={radionuclides} />;
            case VIEWS.DOSE_RATE: return <DoseRateCalculator radionuclides={radionuclides} preselectedNuclide={preselectedNuclide} />;
            case VIEWS.SHIELDING: return <ShieldingCalculator radionuclides={radionuclides} preselectedNuclide={preselectedNuclide} />;
            case VIEWS.STAY_TIME: return <StayTimeCalculator radionuclides={radionuclides} preselectedNuclide={preselectedNuclide} />;
            case VIEWS.NEUTRON: return <NeutronCalculator radionuclides={radionuclides} />;
            case VIEWS.OPERATIONAL_HP: return <OperationalHPCalculators radionuclides={radionuclides} initialTab={opHpActiveTab} />;
            case VIEWS.TRANSPORTATION: return <TransportationCalculator radionuclides={radionuclides} preselectedNuclide={preselectedNuclide} />;
            case VIEWS.CONVERTER: return <UnitConverter />;
            case VIEWS.LAB_STATS: return <LabStatistics />;
            case VIEWS.PEAK_ID: return <PeakIdentifier radionuclides={radionuclides} onNuclideClick={handleNuclideSelection} />;
            case VIEWS.SETTINGS: return <SettingsPanel />;
            case VIEWS.MARSSIM_TESTS: return <MARSSIM_Statistical_Tests />;
            case VIEWS.DECAY_SERIES: return <DecaySeriesViewer seriesId={currentDecaySeriesId} onBack={() => { setDetailedNuclide(null); handleNavClick(VIEWS.HOME); }} onNuclideClick={handleNuclideSelection} />;
            case VIEWS.DETAIL:
            
            if (detailedNuclide) {
            return (
            <div className="p-4">
              <NuclideCard
                  nuclide={detailedNuclide}
                  radionuclides={radionuclides}
                  onDecaySeriesClick={handleDecaySeriesClick}
                  displayHalfLifeUnit={displayHalfLifeUnit}
                  favorites={favorites}
                  toggleFavorite={toggleFavorite}
                  onSendToCalculator={handleSendToCalculator}
                  onAddToCompare={handleAddToCompare}
                  onNuclideClick={handleNuclideSelection}
                  showBackButton={true}
                  // Navigates to the stored previous view
                  onBackClick={() => handleNavClick(previousView)}
              />
            </div>
            );
            }
              return <HomePage errorMessage={errorMessage} randomSuggestions={randomSuggestions} searchHistory={searchHistory} handleNuclideSelection={handleNuclideSelection} handleClearHistory={handleClearHistory} favorites={favorites} radionuclides={radionuclides} handleClearFavorites={handleClearFavorites} onNavClick={handleNavClick} />;
            case VIEWS.MEDICAL:return <MedicalCalculator radionuclides={radionuclides} />;
            
            case VIEWS.SCRATCHPAD:
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-4xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col">
            <div className="flex justify-between items-center mb-4">
             <h2 className="text-xl font-bold text-slate-800 dark:text-white">Scratchpad</h2>
             <Tooltip text="Open in New Window" widthClass="w-auto">
                 <button onClick={() => setShowScratchpadPopout(true)} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                     <Icon path={ICONS.popOut} className="w-5 h-5" />
                 </button>
             </Tooltip>
            </div>
            {/* Pass the centralized state down to the Scratchpad component */}
            <Scratchpad notes={scratchpadNotes} setNotes={setScratchpadNotes} />
            </div>
            </div>
            );
            
            case VIEWS.SCIENTIFIC_CALCULATOR: return ( <div className="p-4 animate-fade-in"><div className="max-w-md mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg"><div className="flex justify-between items-center mb-4"><h2 className="text-xl font-bold text-slate-800 dark:text-white">Scientific Calculator</h2><Tooltip text="Open in New Window" widthClass="w-auto"><button onClick={() => setShowCalcPopout(true)} className="p-2 text-slate-400 hover:text-sky-500 transition-colors"><Icon path={ICONS.popOut} className="w-5 h-5" /></button></Tooltip></div><ScientificCalculator calcState={scientificCalculatorState} setCalcState={setScientificCalculatorState} /></div></div> );
            
            case VIEWS.REFERENCES: return <ReferencesPage onNavClick={handleNavClick} previousView={previousView} />;
            
            case VIEWS.HOME:
            default:
              return <HomePage errorMessage={errorMessage} randomSuggestions={randomSuggestions} searchHistory={searchHistory} handleNuclideSelection={handleNuclideSelection} handleClearHistory={handleClearHistory} favorites={favorites} radionuclides={radionuclides} handleClearFavorites={handleClearFavorites} onNavClick={handleNavClick} />;
            }
            };
            
            return (
            <div className="min-h-screen p-0 sm:p-2 md:p-4 text-slate-800 dark:text-slate-200">
            <div className="max-w-7xl mx-auto bg-white dark:bg-slate-900/70 rounded-none sm:rounded-2xl shadow-2xl backdrop-blur-lg border-slate-200 dark:border-slate-800">
              <Header onHelpClick={() => setIsManualOpen(true)} theme={theme} toggleTheme={toggleTheme} onNavClick={handleNavClick} />
              <SearchBar
                  nuclideName={nuclideName}
                  inputRef={inputRef}
                  handleNuclideNameChange={handleNuclideNameChange}
                  handleKeyDown={handleKeyDown}
                  onClear={handleClearSearch}
                  suggestions={suggestions}
                  activeSuggestionIndex={activeSuggestionIndex}
                  suggestionsRef={suggestionsRef}
                  handleNuclideSelection={handleNuclideSelection}
                  onNavClick={handleNavClick}
                  isFocused={isSearchFocused}
                  onFocus={handleSearchFocus}
                  onBlur={handleSearchBlur}
              />
              <MainNav activeView={activeView} onNavClick={handleNavClick} />
              <main ref={mainContentRef} className="min-h-[400px]">{renderActiveView()}</main>
              <footer className="text-center p-6 mt-4 border-t border-slate-200 dark:border-slate-700">
                  <p className="text-xs text-slate-500 dark:text-slate-400"><strong>Disclaimer:</strong> This tool is for informational and educational purposes only. The data and calculations have not been validated and may contain errors. Use of this tool is at your own risk.</p>
                  <div className="mt-4 flex justify-center md:hidden"><a href="https://www.buymeacoffee.com/jough" target="_blank" rel="noopener noreferrer"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-blue.png" alt="Buy Me A Coffee" style={{ height: '36px', width: 'auto' }} /></a></div>
              </footer>
              <ManualModal isOpen={isManualOpen} onClose={() => setIsManualOpen(false)} />
            
              {showCalcPopout && (
                  <PopoutWindow
                      title="Scientific Calculator"
                      onClose={() => setShowCalcPopout(false)}
                      height={850}
                  >
                      <div className={`${theme} bg-slate-100 dark:bg-slate-900 h-full p-4`}>
                          <div className="max-w-md mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                              <h2 className="text-xl font-bold text-slate-800 dark:text-white mb-4">Scientific Calculator</h2>
                              <ScientificCalculator calcState={scientificCalculatorState} setCalcState={setScientificCalculatorState} />
                          </div>
                      </div>
                  </PopoutWindow>
              )}
            
            {showScratchpadPopout && (
            <PopoutWindow
            title="Scratchpad"
            onClose={() => setShowScratchpadPopout(false)}
            width={800}
            height={660}
            >
            <div className={`${theme} bg-slate-100 dark:bg-slate-900 h-full p-4`}>
            <div className="max-w-4xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col h-full">
            <h2 className="text-xl font-bold text-slate-800 dark:text-white mb-4">Scratchpad</h2>
            <div className="flex-grow flex flex-col">
            {/* FIX: Pass the centralized state down to the pop-out component */}
            <Scratchpad notes={scratchpadNotes} setNotes={setScratchpadNotes} />
            </div>
            </div>
            </div>
            </PopoutWindow>
            )}
            </div>
            </div>
            );
            };
            
            /**
            * @description A searchable dropdown component for selecting items from a large list.
            */
            
            const SearchableSelect = ({ options, onSelect, placeholder }) => {
            
            const [inputValue, setInputValue] = React.useState('');
            const [isOpen, setIsOpen] = React.useState(false);
            const [activeIndex, setActiveIndex] = React.useState(-1);
            const containerRef = React.useRef(null);
            const listRef = React.useRef(null);
            const inputRef = React.useRef(null); // Added for auto-focus
            
            const handleClear = () => {
            setInputValue('');
            setIsOpen(false);
            setActiveIndex(-1);
            };
            
            const filteredOptions = React.useMemo(() => {
            if (!inputValue) return [];
            const normInput = normalizeString(inputValue);
            const commonalityOrder = {
            'Common': 3,
            'Moderate': 2,
            'Rare': 1
            };
            
            return options
            .filter(opt => normalizeString(opt.name).includes(normInput) || normalizeString(opt.symbol).includes(normInput))
            .sort((a, b) => {
            const aStartsWith = normalizeString(a.name).startsWith(normInput) || normalizeString(a.symbol).startsWith(normInput);
            const bStartsWith = normalizeString(b.name).startsWith(normInput) || normalizeString(b.symbol).startsWith(normInput);
            if (aStartsWith !== bStartsWith) return aStartsWith ? -1 : 1;
            const orderA = commonalityOrder[a.commonality] || 0;
            const orderB = commonalityOrder[b.commonality] || 0;
            if (orderB !== orderA) return orderB - orderA;
            return a.name.localeCompare(b.name);
            })
            .slice(0, 10);
            }, [inputValue, options]);
            
            React.useEffect(() => {
            const handleClickOutside = (event) => {
            if (containerRef.current && !containerRef.current.contains(event.target)) {
            setIsOpen(false);
            }
            };
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);
            
            const handleKeyDown = (e) => {
            if (filteredOptions.length === 0) return;
            if (e.key === 'ArrowDown') {
            e.preventDefault();
            setActiveIndex(prev => (prev < filteredOptions.length - 1 ? prev + 1 : 0));
            } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            setActiveIndex(prev => (prev > 0 ? prev - 1 : filteredOptions.length - 1));
            } else if (e.key === 'Enter') {
            if (activeIndex > -1 && filteredOptions[activeIndex]) {
            handleSelect(filteredOptions[activeIndex]);
            } else if (filteredOptions.length > 0) {
            handleSelect(filteredOptions[0]);
            }
            } else if (e.key === 'Escape') {
            setIsOpen(false);
            }
            };
            
            React.useEffect(() => {
            if (activeIndex !== -1 && listRef.current?.children[activeIndex]) {
            listRef.current.children[activeIndex].scrollIntoView({
            block: 'nearest'
            });
            }
            }, [activeIndex]);
            
            const handleSelect = (option) => {
            onSelect(option.symbol);
            setInputValue('');
            setIsOpen(false);
            setActiveIndex(-1);
            };
            
            return (
            <div className="relative w-full" ref={containerRef}>
            <div className="relative">
            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <Icon path={ICONS.search} className="w-5 h-5 text-slate-400" />
            </div>
            <input
            ref={inputRef}
            type="text"
            value={inputValue}
            onChange={(e) => {
            setInputValue(e.target.value);
            setIsOpen(true);
            setActiveIndex(-1);
            }}
            onKeyDown={handleKeyDown}
            onFocus={() => { if(inputValue) setIsOpen(true); }}
            placeholder={placeholder}
            className="w-full p-2 pl-10 rounded-md bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500"
            autoComplete="off"
            />
            
            {inputValue && (
            <button
            onClick={handleClear}
            className="absolute inset-y-0 right-0 pr-3 flex items-center text-slate-400 hover:text-sky-500 focus:outline-none"
            >
            <Icon path={ICONS.clear} className="w-5 h-5" />
            </button>
            )}
            </div>
            {isOpen && filteredOptions.length > 0 && (
            <ul ref={listRef} className="absolute z-30 w-full mt-2 bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-600 rounded-md shadow-lg max-h-72 overflow-y-auto">
                {filteredOptions.map((option, index) => {
                    const styles = CATEGORY_STYLES[option.category] || CATEGORY_STYLES['default'];
                    return (
                        <li
                            key={option.symbol}
                            onClick={() => handleSelect(option)}
                            onMouseEnter={() => setActiveIndex(index)}
                            className={`p-3 pl-4 cursor-pointer text-slate-700 dark:text-slate-200 border-l-2 ${styles.border} ${styles.hoverBg} ${
                                index === activeIndex ? 'bg-sky-100 dark:bg-sky-900/50' : ''
                            }`}
                        >
                            {option.name} ({option.symbol})
                        </li>
                    )
                })}
                {filteredOptions.length > 4 && (
                    <div className="sticky bottom-0 bg-slate-50/95 dark:bg-slate-900/95 backdrop-blur-sm p-2 border-t border-slate-200 dark:border-slate-700">
                        <div className="flex flex-wrap justify-center gap-x-3 gap-y-1">
                            {Object.entries(CATEGORY_STYLES).filter(([key]) => key !== 'default').map(([category, styles]) => {
                                const bgColor = styles.border.replace('border-l-', 'bg-');
                                return (
                                    <div key={category} className="flex items-center gap-1.5">
                                        <div className={`w-2.5 h-2.5 rounded-full ${bgColor}`}></div>
                                        <span className="text-xs text-slate-500 dark:text-slate-400">{category.replace('/', '/ ')}</span>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}
            </ul>
            )}
            </div>
            );
            };
            
            /**
            * @description An advanced view for comparing multiple radionuclides side-by-side.
            * Features dynamic highlighting, in-cell data bars, and an integrated
            * percentage difference tag when comparing two nuclides.
            */
            
            const ComparisonView = ({ radionuclides, onNuclideClick, comparisonList, onAddToCompare, onRemoveFromCompare, onClearCompare }) => {
            const [isModalOpen, setIsModalOpen] = React.useState(false);
            const { settings } = React.useContext(SettingsContext);
            
            // Helper for HVL lookup
            const getHVL = (nuclide, material) => {
                // Check if HVL_DATA exists (it might be in a different file scope)
                if (typeof HVL_DATA !== 'undefined' && HVL_DATA[nuclide.symbol] && HVL_DATA[nuclide.symbol][material]) {
                    return HVL_DATA[nuclide.symbol][material];
                }
                return null; // Will render as 'N/A' in the table
            };
            
            const formatGammaSI = (valR) => (valR ? (valR * 0.01) / 3.7e10 : 0);
            const formatTBqToCi = (valTBq) => (valTBq ? valTBq * 27.027 : 0);
            
            // --- REFACTORED CONFIGURATION ---
            const propertiesToCompare = React.useMemo(() => [
            {
            label: 'Half-life',
            key: 'halfLife',
            type: 'numeric',
            highlightMode: 'neutral',
            useLogScale: true,
            getValue: (n) => parseHalfLifeToSeconds(n.halfLife),
            getDisplay: (n) => formatHalfLife(n.halfLife, getBestHalfLifeUnit(parseHalfLifeToSeconds(n.halfLife)))
            },
            { 
            label: 'Primary Decay Mode', 
            type: 'categorical', 
            render: (n) => <span className="font-medium text-slate-700 dark:text-slate-300">{n.emissionType?.[0] || 'N/A'}</span> 
            },
            {
            label: 'Specific Activity',
            key: 'specificActivity',
            type: 'numeric',
            highlightMode: 'highGood',
            useLogScale: true,
            getValue: (n) => parseSpecificActivity(n.specificActivity),
            getDisplay: (n) => {
            const val = parseSpecificActivity(n.specificActivity);
            const fmt = formatWithUnitSystem(val, 'activity', settings);
            return `${fmt.value} ${fmt.unit}`;
            }
            },
            {
            label: settings.unitSystem === 'si' ? 'Gamma Const. (Sv·m²/hr·Bq)' : 'Gamma Const. (R·m²/hr·Ci)',
            key: 'gammaConstant',
            type: 'numeric',
            highlightMode: 'lowGood',
            getValue: (n) => {
            const val = parseFloat(n.gammaConstant);
            return settings.unitSystem === 'si' ? formatGammaSI(val) : val;
            },
            getDisplay: (n) => {
            const val = parseFloat(n.gammaConstant);
            if (!val) return 'N/A';
            if (settings.unitSystem === 'si') return formatGammaSI(val).toExponential(2);
            return val.toFixed(4);
            }
            },
            {
            label: 'Lead HVL (cm)',
            key: 'hvl',
            type: 'numeric',
            highlightMode: 'lowGood',
            getValue: (n) => getHVL(n, 'Lead'),
            getDisplay: (n) => getHVL(n, 'Lead') || 'N/A'
            },
            {
            label: settings.unitSystem === 'si' ? 'Ingestion ALI (Bq)' : 'Ingestion ALI (µCi)',
            key: 'aliIngest',
            type: 'numeric',
            highlightMode: 'highGood',
            useLogScale: true,
            getValue: (n) => n.dosimetry?.ALI?.ingestion,
            getDisplay: (n) => {
            const val = n.dosimetry?.ALI?.ingestion;
            if (!val) return 'N/A';
            const fmt = formatWithUnitSystem(val, 'ali', settings);
            return fmt.value;
            }
            },
            // NEW: Inhalation ALI
            {
            label: settings.unitSystem === 'si' ? 'Inhalation ALI (Bq)' : 'Inhalation ALI (µCi)',
            key: 'aliInhale',
            type: 'numeric',
            highlightMode: 'highGood',
            useLogScale: true,
            getValue: (n) => {
            // Try to find the most conservative (lowest) inhalation limit or default to 'W'
            const d = n.dosimetry?.ALI;
            if(!d) return null;
            return d.inhalation_W || d.inhalation_Y || d.inhalation_D || d.inhalation;
            },
            getDisplay: (n) => {
            const d = n.dosimetry?.ALI;
            if(!d) return 'N/A';
            const val = d.inhalation_W || d.inhalation_Y || d.inhalation_D || d.inhalation;
            const fmt = formatWithUnitSystem(val, 'ali', settings);
            return fmt.value;
            }
            },
            {
            label: settings.unitSystem === 'si' ? 'D-Value (TBq)' : 'D-Value (Ci)',
            key: 'dValue',
            type: 'numeric',
            highlightMode: 'highGood',
            useLogScale: true,
            getValue: (n) => settings.unitSystem === 'si' ? n.dValue : formatTBqToCi(n.dValue),
            getDisplay: (n) => {
            const val = n.dValue;
            if (!val) return 'N/A';
            if (settings.unitSystem === 'si') return val;
            return formatTBqToCi(val).toLocaleString(undefined, { maximumFractionDigits: 1 });
            }
            },
            { label: 'Parent', type: 'categorical', render: (n) => <ClickableNuclide text={n.parent} radionuclides={radionuclides} onNuclideClick={onNuclideClick} /> },
            { label: 'Daughter', type: 'categorical', render: (n) => <ClickableNuclide text={n.daughter} radionuclides={radionuclides} onNuclideClick={onNuclideClick} /> },
            ], [settings.unitSystem, radionuclides]);
            
            const sortedNuclides = React.useMemo(() => [...radionuclides].sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
            const handleAddNuclide = (symbol) => onAddToCompare(symbol);
            
            // Quick Add Handlers
            const addGroup = (symbols) => {
                // 1. Clear existing list first to prevent duplicates
                onClearCompare();
                
                // 2. Filter out invalid symbols before adding
                const validNuclides = symbols
                    .map(s => radionuclides.find(n => n.symbol === s))
                    .filter(n => n !== undefined);
            
                // 3. Use a Set to ensure uniqueness within the group being added
                const uniqueNuclides = [...new Set(validNuclides)];
            
                // 4. Add them in a batch
                setTimeout(() => {
                    uniqueNuclides.forEach(n => onAddToCompare(n.symbol));
                }, 50);
            };
            
            const handleExportToCSV = () => {
            const headers = ['Property', ...comparisonList.map(n => n.name)];
            const rows = propertiesToCompare.map(prop => {
            const rowData = [prop.label];
            comparisonList.forEach(nuclide => {
            let val = 'N/A';
            if (prop.getDisplay) val = prop.getDisplay(nuclide);
            else if (prop.getValue) val = prop.getValue(nuclide);
            else if (prop.render) val = nuclide[prop.key] || 'N/A';
            rowData.push(String(val).replace(/,/g, ' '));
            });
            return rowData.join(',');
            });
            const csvContent = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "radionuclide_comparison.csv";
            link.click();
            };
            
            const handleConfirmClear = () => { onClearCompare(); setIsModalOpen(false); };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-7xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
            <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800 dark:text-white">Compare Radionuclides</h2>
            <div className="flex items-center gap-2">
                {comparisonList.length > 0 && (
                    <>
                        <button onClick={() => setIsModalOpen(true)} className="px-3 py-2 text-sm bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition flex items-center gap-2">
                            <Icon path={ICONS.clear} className="w-4 h-4" /> Clear
                        </button>
                        <button onClick={handleExportToCSV} className="px-3 py-2 text-sm bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition flex items-center gap-2">
                            <Icon path={ICONS.database} className="w-4 h-4" /> Export CSV
                        </button>
                    </>
                )}
            </div>
            </div>
            
            <div className="flex items-center gap-2 mb-6 p-4 bg-slate-100 dark:bg-slate-800/50 rounded-lg">
            <SearchableSelect options={sortedNuclides.filter(n => !comparisonList.find(c => c.symbol === n.symbol))} onSelect={handleAddNuclide} placeholder="Search to add a nuclide..." />
            </div>
            
            {comparisonList.length === 0 ? (
            <div className="text-center p-8 border-2 border-dashed border-slate-300 dark:border-slate-700 rounded-lg">
                <Icon path={ICONS.compare} className="w-12 h-12 text-slate-400 dark:text-slate-500 mx-auto" />
                <h3 className="mt-4 text-lg font-semibold text-slate-600 dark:text-slate-300">The Comparison Table is Empty</h3>
                <p className="mt-1 text-sm text-slate-500 dark:text-slate-400">Add nuclides using the search box above, or try a preset:</p>
                
                {/* Quick Group Buttons */}
                <div className="flex flex-wrap justify-center gap-2 mt-4">
                    <button onClick={() => addGroup(['Tc-99m', 'I-131', 'F-18', 'Lu-177'])} className="px-3 py-1 bg-sky-100 dark:bg-sky-900 text-sky-700 dark:text-sky-300 rounded-full text-xs font-bold hover:bg-sky-200 transition">Medical</button>
                    <button onClick={() => addGroup(['Cs-137', 'Co-60', 'Ir-192', 'Am-241'])} className="px-3 py-1 bg-amber-100 dark:bg-amber-900 text-amber-700 dark:text-amber-300 rounded-full text-xs font-bold hover:bg-amber-200 transition">Industrial</button>
                    <button onClick={() => addGroup(['U-238', 'U-235', 'Pu-239', 'Am-241'])} className="px-3 py-1 bg-emerald-100 dark:bg-emerald-900 text-emerald-700 dark:text-emerald-300 rounded-full text-xs font-bold hover:bg-emerald-200 transition">SNM</button>
                </div>
            </div>
            ) : (
            <div className="overflow-x-auto relative shadow-md rounded-lg">
                <table className="w-full min-w-[600px] text-left border-collapse">
                    <thead>
                        <tr>
                            <th className="sticky left-0 top-0 z-30 bg-slate-50 dark:bg-slate-700 p-3 text-sm font-semibold border-b border-r border-slate-200 dark:border-slate-600 shadow-[2px_0_5px_-2px_rgba(0,0,0,0.1)]">Property</th>
                            {comparisonList.map(nuclide => (
                                <th key={nuclide.symbol} className="sticky top-0 z-20 bg-slate-100 dark:bg-slate-800 p-3 text-sm font-semibold border-b border-slate-200 dark:border-slate-600 min-w-[140px]">
                                    <div className="flex justify-between items-center">
                                        <span className="cursor-pointer hover:text-sky-500" onClick={() => onNuclideClick(nuclide)}>{nuclide.name}</span>
                                        <button onClick={() => onRemoveFromCompare(nuclide.symbol)} className="ml-2 text-slate-400 hover:text-red-500"><Icon path={ICONS.clear} className="w-4 h-4"/></button>
                                    </div>
                                </th>
                            ))}
                        </tr>
                    </thead>
                    <tbody>
                        {propertiesToCompare.map(prop => {
                            let numericValues = [];
                            let maxVal = -Infinity, minVal = Infinity;
            
                            if (prop.type === 'numeric') {
                                           numericValues = comparisonList.map(n => {
                                               const v = prop.getValue ? prop.getValue(n) : null;
                                               return (typeof v === 'number' && !isNaN(v)) ? v : null;
                                           });
            
                                           // Filter out Infinity explicitly when finding Max/Min for scaling
                                           const validFiniteValues = numericValues.filter(v => v !== null && v !== Infinity && v > 0);
                                           
                                           if (validFiniteValues.length > 0) {
                                               maxVal = Math.max(...validFiniteValues);
                                               minVal = Math.min(...validFiniteValues);
                                           } else {
                                               // Fallback if all values are Infinity or 0 (prevents divide by zero)
                                               maxVal = 1;
                                               minVal = 0;
                                           }
                                       }
            
                            return (
                                <tr key={prop.label} className="group hover:bg-slate-50 dark:hover:bg-slate-800/50">
                                    <td className="sticky left-0 z-10 bg-white dark:bg-slate-800 group-hover:bg-slate-50 dark:group-hover:bg-slate-800/50 p-3 font-medium text-slate-500 dark:text-slate-400 border-b border-r border-slate-200 dark:border-slate-600 text-xs uppercase tracking-wide shadow-[2px_0_5px_-2px_rgba(0,0,0,0.1)]">
                                        {prop.label}
                                    </td>
            
                                    {comparisonList.map((nuclide, idx) => {
                                        let cellContent;
                                        let cellClass = 'border-b border-slate-200 dark:border-slate-600 transition-colors duration-200';
            
                                        if (prop.render) {
                                            cellContent = prop.render(nuclide);
                                        } else {
                                            const rawVal = prop.getValue ? prop.getValue(nuclide) : null;
                                            const displayVal = prop.getDisplay ? prop.getDisplay(nuclide) : (rawVal || 'N/A');
            
                                            if (prop.type === 'numeric') {
            const numVal = numericValues[idx];
            let barWidth = 0;
            
            // Check if we have a valid, non-null value to work with
            if (numVal !== null && numVal !== undefined) {
            
            // CASE 1: Infinite Value (e.g., Stable Half-life)
            if (numVal === Infinity) {
            barWidth = 100; // Fill the bar completely for "Stable"
            }
            // CASE 2: Normal Calculation (Must be > 0 for Log Scale safety)
            else if (maxVal > 0) {
            
            // Logarithmic Scale Logic (Used for Half-life, Specific Activity)
            if (prop.useLogScale) {
            // Ensure value is positive (log(0) is -Infinity)
            if (numVal > 0 && minVal > 0 && maxVal / minVal > 100) {
            const logMin = Math.log10(minVal);
            const logMax = Math.log10(maxVal);
            const logVal = Math.log10(numVal);
            
            // Prevent divide-by-zero if all values are the same
            if (logMax === logMin) {
                barWidth = 100;
            } else {
                barWidth = ((logVal - logMin) / (logMax - logMin)) * 100;
            }
            
            // Ensure tiny bars are at least visible (5%)
            barWidth = Math.max(barWidth, 5);
            } 
            // If numVal is 0 but we are in log mode, barWidth stays 0.
            } 
            // Linear Scale Logic (Used for Gamma Constant, etc.)
            else {
            barWidth = (numVal / maxVal) * 100;
            }
            }
            }
            
            // highlightMode logic
            if (prop.highlightMode === 'highGood') {
            if (numVal === maxVal && numVal !== Infinity) cellClass += ' bg-green-50 dark:bg-green-900/20 text-green-700 dark:text-green-300 font-bold';
            if (numVal === minVal) cellClass += ' text-slate-500 dark:text-slate-400';
            } else if (prop.highlightMode === 'lowGood') {
            if (numVal === minVal) cellClass += ' bg-green-50 dark:bg-green-900/20 text-green-700 dark:text-green-300 font-bold';
            if (numVal === maxVal && numVal !== Infinity) cellClass += ' text-slate-500 dark:text-slate-400';
            } else { // Neutral
            if (numVal === maxVal && numVal !== Infinity) cellClass += ' bg-sky-50 dark:bg-sky-900/20 text-sky-700 dark:text-sky-300 font-bold';
            }
            
            // Render the visual bar
            cellContent = (
            <div className="relative h-full w-full flex items-center">
            {barWidth > 0 && (
            <div
            className={`absolute bottom-0 left-0 h-1 transition-all duration-500 ${
                prop.highlightMode === 'highGood' ? (numVal === maxVal ? 'bg-green-500' : 'bg-green-200') :
                prop.highlightMode === 'lowGood' ? (numVal === minVal ? 'bg-green-500' : 'bg-slate-300') :
                'bg-sky-400'
            }`}
            style={{ width: `${barWidth}%`, opacity: 0.4 }}
            />
            )}
            <span className="relative z-10">{displayVal}</span>
            </div>
            );
            } else {
            cellContent = <span>{displayVal}</span>;
            }
                                        }
                                        return <td key={nuclide.symbol} className={`${cellClass} p-3 text-sm`}>{cellContent}</td>;
                                    })}
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            </div>
            )}
            </div>
            <ConfirmationModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onConfirm={handleConfirmClear} title="Clear Comparison"><p>Are you sure you want to clear the list?</p></ConfirmationModal>
            </div>
            );
            };
            
            
            
            
            /**
            * @description A versatile dose rate calculator handling Gamma (Point/Line/Area), Beta, and Internal Dose.
            * Features: Auto-calculation, Field Calc (Inverse Square), Geometry Visualizations, and Bremsstrahlung fix.
            */
            const DoseRateCalculator = ({ radionuclides, preselectedNuclide }) => {
            // --- Constants ---
            const CALC_MODE_GAMMA = 'gamma';
            const CALC_MODE_BETA = 'beta';
            const CALC_MODE_BREMS = 'bremsstrahlung';
            const CALC_MODE_INTERNAL = 'internal';
            const CALC_MODE_FIELD = 'field'; 
            
            const INPUT_MODE_DB = 'fromSource';
            const INPUT_MODE_MANUAL = 'manual';
            
            const GEOMETRY_POINT = 'point';
            const GEOMETRY_LINE = 'line';
            const GEOMETRY_AREA = 'area';
            
            const BETA_MODE_SKIN = 'skin';
            const BETA_MODE_AIR = 'air';
            
            const METHOD_10CFR20 = '10CFR20';
            const METHOD_FGR11 = 'FGR11';
            
            const { settings } = React.useContext(SettingsContext);
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            // --- HELPER: Format Number ---
            const formatNumber = (num) => {
            if (num === null || num === undefined || isNaN(num)) return '-';
            if (num === 0) return '0';
            if (Math.abs(num) < 0.001 || Math.abs(num) >= 10000) {
               return num.toExponential(3);
            }
            return parseFloat(num.toPrecision(4)).toString();
            };
            
            // --- DATA DEFINITIONS (FIXED) ---
            const SHIELD_PROPS = {
            'Plastic': { Z: 6, density: 1.18 }, // PMMA/Lucite approximation
            'Aluminum': { Z: 13, density: 2.70 },
            'Steel': { Z: 26, density: 7.85 }, // Iron approximation
            'Lead': { Z: 82, density: 11.34 },
            'Water': { Z: 7.4, density: 1.00 },
            'Concrete': { Z: 11, density: 2.35 },
            'None': { Z: 0, density: 0 }
            };
            
            // --- Units ---
            const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci'], [settings.unitSystem]);
            const distanceUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['mm', 'cm', 'm'] : ['in', 'ft', 'm'], [settings.unitSystem]);
            const doseRateUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['µSv/hr', 'mSv/hr', 'Sv/hr'] : ['µrem/hr', 'mrem/hr', 'rem/hr', 'mR/hr', 'R/hr'], [settings.unitSystem]);
            const intakeUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq'] : ['pCi', 'nCi', 'µCi', 'mCi', 'Ci'], [settings.unitSystem]);
            
            // --- State ---
            const [calcMode, setCalcMode] = React.useState(() => localStorage.getItem('doseRate_calcMode') || CALC_MODE_GAMMA);
            const [inputMode, setInputMode] = React.useState(INPUT_MODE_DB);
            const [geometryMode, setGeometryMode] = React.useState(GEOMETRY_POINT);
            const [doseMethod, setDoseMethod] = React.useState(METHOD_10CFR20);
            
            // Inputs
            const [activity, setActivity] = React.useState('1');
            const [activityUnit, setActivityUnit] = React.useState(activityUnits[0]);
            const [distance, setDistance] = React.useState('1');
            const [distanceUnit, setDistanceUnit] = React.useState(distanceUnits[2]);
            const [transmission, setTransmission] = React.useState('1.0');
            
            // Geometry Specific
            const [lineLength, setLineLength] = React.useState('1');
            const [lineLengthUnit, setLineLengthUnit] = React.useState('m');
            const [linearActivityUnit, setLinearActivityUnit] = React.useState('mCi/m');
            const [diskRadius, setDiskRadius] = React.useState('10');
            const [diskRadiusUnit, setDiskRadiusUnit] = React.useState('cm');
            const [arealActivityUnit, setArealActivityUnit] = React.useState('µCi/cm²');
            
            // Beta/Brems Specific
            const [shieldMaterial, setShieldMaterial] = React.useState('Plastic');
            const [betaMode, setBetaMode] = React.useState(BETA_MODE_SKIN);
            const [skinActivity, setSkinActivity] = React.useState('1000');
            const [skinActivityUnit, setSkinActivityUnit] = React.useState('dpm/100cm²');
            
            // Internal Specific
            const [intakeRoute, setIntakeRoute] = React.useState('inhalation');
            const [solubility, setSolubility] = React.useState('');
            const [intakeAmount, setIntakeAmount] = React.useState('1');
            const [intakeUnit, setIntakeUnit] = React.useState(intakeUnits[2]);
            
            // Field Calc Specific
            const [field_d1, setField_d1] = React.useState('1');
            const [field_d1Unit, setField_d1Unit] = React.useState('ft');
            const [field_r1, setField_r1] = React.useState('100');
            const [field_r1Unit, setField_r1Unit] = React.useState('mrem/hr');
            const [field_targetType, setField_targetType] = React.useState('findRate'); 
            const [field_d2, setField_d2] = React.useState('10'); 
            const [field_d2Unit, setField_d2Unit] = React.useState('ft');
            const [field_r2, setField_r2] = React.useState('2'); 
            const [field_r2Unit, setField_r2Unit] = React.useState('mrem/hr');
            
            // Manual Data
            const [nuclideSymbol, setNuclideSymbol] = React.useState('');
            const [manualGammaConstant, setManualGammaConstant] = React.useState('');
            const [manualBetaEnergy, setManualBetaEnergy] = React.useState('');
            
            const [result, setResult] = React.useState(null);
            const [error, setError] = React.useState('');
            
            // --- Persistence Effects ---
            React.useEffect(() => {
            localStorage.setItem('doseRate_calcMode', calcMode);
            }, [calcMode]);
            
            React.useEffect(() => {
            setResult(null);
            setError('');
            }, [calcMode, inputMode, geometryMode, betaMode]); 
            
            React.useEffect(() => {
            if (!activityUnits.includes(activityUnit)) setActivityUnit(activityUnits[0]);
            if (!distanceUnits.includes(distanceUnit)) setDistanceUnit(distanceUnits[0]);
            }, [settings.unitSystem]);
            
            React.useEffect(() => { if (preselectedNuclide) { setNuclideSymbol(preselectedNuclide.symbol); setInputMode(INPUT_MODE_DB); } }, [preselectedNuclide]);
            
            // Data Filtering
            const gammaNuclides = React.useMemo(() => radionuclides.filter(n => n.gammaConstant).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
            const betaNuclides = React.useMemo(() => radionuclides.filter(n => n.emissionEnergies?.beta?.length > 0 || n.daughterEmissions?.beta?.length > 0).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
            const dosimetryNuclides = React.useMemo(() => radionuclides.filter(n => n.dosimetry?.ALI).sort((a, b) => a.name.localeCompare(b.name)), [radionuclides]);
            
            const availableNuclides = React.useMemo(() => {
            switch (calcMode) {
               case CALC_MODE_GAMMA: return gammaNuclides;
               case CALC_MODE_BETA:
               case CALC_MODE_BREMS: return betaNuclides;
               case CALC_MODE_INTERNAL: return dosimetryNuclides;
               default: return [];
            }
            }, [calcMode, gammaNuclides, betaNuclides, dosimetryNuclides]);
            
            const selectedNuclide = React.useMemo(() => radionuclides.find(n => n.symbol === nuclideSymbol), [nuclideSymbol, radionuclides]);
            
            const availableClasses = React.useMemo(() => {
            if (!selectedNuclide || !selectedNuclide.dosimetry) return [];
            const sourceObject = doseMethod === METHOD_FGR11 ? selectedNuclide.dosimetry.DCF : selectedNuclide.dosimetry.ALI;
            if (!sourceObject) return [];
            return Object.keys(sourceObject).filter(k => k.startsWith('inhalation_')).map(k => k.split('_')[1]);
            }, [selectedNuclide, doseMethod]);
            
            React.useEffect(() => {
            if (calcMode === CALC_MODE_INTERNAL && intakeRoute === 'inhalation' && availableClasses.length > 0) {
               if (!solubility || !availableClasses.includes(solubility)) setSolubility(availableClasses[0]);
            }
            }, [calcMode, intakeRoute, availableClasses, solubility]);
            
            // --- HELPER: Geometry Visualizer ---
            const GeometryVisualizer = ({ mode }) => {
            if (mode === GEOMETRY_POINT) {
               return (
                   <div className="flex justify-center my-4 opacity-80">
                       <svg width="200" height="60" viewBox="0 0 200 60">
                           <circle cx="20" cy="30" r="5" fill="#0ea5e9" />
                           <text x="20" y="50" fontSize="10" textAnchor="middle" fill="#64748b">Source</text>
                           <line x1="25" y1="30" x2="175" y2="30" stroke="#94a3b8" strokeWidth="2" markerEnd="url(#arrow)" />
                           <text x="100" y="25" fontSize="10" textAnchor="middle" fill="#64748b">Distance (d)</text>
                           <rect x="180" y="20" width="10" height="20" fill="#f43f5e" />
                           <defs><marker id="arrow" markerWidth="10" markerHeight="10" refX="7" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#94a3b8" /></marker></defs>
                       </svg>
                   </div>
               );
            }
            if (mode === GEOMETRY_LINE) {
               return (
                   <div className="flex justify-center my-4 opacity-80">
                       <svg width="200" height="80" viewBox="0 0 200 80">
                           <line x1="20" y1="10" x2="20" y2="70" stroke="#0ea5e9" strokeWidth="4" />
                           <text x="15" y="45" fontSize="10" textAnchor="end" fill="#0ea5e9">L</text>
                           <line x1="20" y1="40" x2="175" y2="40" stroke="#94a3b8" strokeWidth="2" markerEnd="url(#arrow)" />
                           <text x="100" y="35" fontSize="10" textAnchor="middle" fill="#64748b">Distance (Perpendicular to Center)</text>
                           <rect x="180" y="30" width="10" height="20" fill="#f43f5e" />
                           <defs><marker id="arrow" markerWidth="10" markerHeight="10" refX="7" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#94a3b8" /></marker></defs>
                       </svg>
                   </div>
               );
            }
            if (mode === GEOMETRY_AREA) {
               return (
                   <div className="flex justify-center my-4 opacity-80">
                       <svg width="200" height="80" viewBox="0 0 200 80">
                           <ellipse cx="40" cy="40" rx="10" ry="30" stroke="#0ea5e9" strokeWidth="2" fill="none" />
                           <text x="40" y="80" fontSize="10" textAnchor="middle" fill="#0ea5e9">Disk (R)</text>
                           <line x1="40" y1="40" x2="175" y2="40" stroke="#94a3b8" strokeWidth="2" markerEnd="url(#arrow)" />
                           <text x="100" y="35" fontSize="10" textAnchor="middle" fill="#64748b">Distance (Perpendicular to Center)</text>
                           <rect x="180" y="30" width="10" height="20" fill="#f43f5e" />
                           <defs><marker id="arrow" markerWidth="10" markerHeight="10" refX="7" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#94a3b8" /></marker></defs>
                       </svg>
                   </div>
               );
            }
            return null;
            };
            
            // --- ROBUST CONVERSION FACTORS ---
            // Source of Truth: 1 Ci = 3.7e10 Bq
            const BQ_TO_CI = 1 / 3.7e10; 
            
            // Rebuilt activity factors to prevent magnitude errors (kBq vs MBq)
            const activityFactorsCi = React.useMemo(() => ({
            'Ci': 1,
            'mCi': 1e-3,
            'µCi': 1e-6,
            'TBq': BQ_TO_CI * 1e12,
            'GBq': BQ_TO_CI * 1e9,
            'MBq': BQ_TO_CI * 1e6,
            'kBq': BQ_TO_CI * 1e3,
            'Bq': BQ_TO_CI
            }), [BQ_TO_CI]);
            
            const distanceFactorsM = { 'mm': 0.001, 'cm': 0.01, 'm': 1, 'in': 0.0254, 'ft': 0.3048, 'km': 1000 };
            const linearActivityFactorsCi_per_m = { 'µCi/cm': 1e-4, 'mCi/cm': 0.1, 'Ci/cm': 100, 'µCi/m': 1e-6, 'mCi/m': 1e-3, 'Ci/m': 1 };
            const arealActivityFactorsCi_per_m2 = { 'µCi/cm²': 0.01, 'mCi/cm²': 10, 'Ci/cm²': 10000, 'µCi/m²': 1e-6, 'mCi/m²': 1e-3, 'Ci/m²': 1 };
            const doseRateFactors_mrem_hr = { 'µrem/hr': 0.001, 'mrem/hr': 1, 'rem/hr': 1000, 'mR/hr': 1, 'R/hr': 1000, 'µSv/hr': 0.1, 'mSv/hr': 100, 'Sv/hr': 100000 };
            const intakeUnitFactors = { 'pCi': 1e-6, 'nCi': 1e-3, 'µCi': 1, 'mCi': 1000, 'Ci': 1e6, 'Bq': 1/37000, 'kBq': 1/37, 'MBq': 1000/37, 'GBq': 1e6/37 };
            const intakeUnitFactorsBq = { 'pCi': 0.037, 'nCi': 37, 'µCi': 37000, 'mCi': 3.7e7, 'Ci': 3.7e10, 'Bq': 1, 'kBq': 1000, 'MBq': 1e6, 'GBq': 1e9 };
            const concentrationFactors_uCi_per_cm2 = { 'dpm/100cm²': 1 / 2.22e8, 'µCi/cm²': 1, 'mCi/cm²': 1000, 'Ci/cm²': 1e6, 'Bq/cm²': 1 / 37000 };
            
            const handleCalculate = React.useCallback(() => {
            setError(''); setResult(null);
            
            // --- FIELD CALC (Inverse Square) ---
            if (calcMode === CALC_MODE_FIELD) {
               const d1 = parseFloat(field_d1) * distanceFactorsM[field_d1Unit];
               const r1 = parseFloat(field_r1) * doseRateFactors_mrem_hr[field_r1Unit];
               
               if (isNaN(d1) || isNaN(r1) || d1 <= 0 || r1 < 0) {
                   setError("Inputs must be positive numbers."); return;
               }
               
               const k = r1 * (d1 * d1);
               
               if (field_targetType === 'findRate') {
                   const d2 = parseFloat(field_d2) * distanceFactorsM[field_d2Unit];
                   if (isNaN(d2) || d2 <= 0) { setError("Target distance must be > 0."); return; }
                   const r2 = k / (d2 * d2);
                   setResult({ type: 'field', val: r2, unit: 'doseRate', label: 'Projected Dose Rate' });
               } else {
                   const r2 = parseFloat(field_r2) * doseRateFactors_mrem_hr[field_r2Unit];
                   if (isNaN(r2) || r2 <= 0) { setError("Target rate must be > 0."); return; }
                   const d2_sq = k / r2;
                   const d2 = Math.sqrt(d2_sq);
                   setResult({ type: 'field', val: d2 / distanceFactorsM[field_d2Unit], unit: 'distance', label: 'Distance to Boundary' });
               }
               return;
            }
            
            // --- GAMMA / BETA / INTERNAL Logic ---
            const A_val = parseFloat(activity);
            const d_val = parseFloat(distance);
            
            if (calcMode !== CALC_MODE_INTERNAL && (isNaN(d_val) || d_val <= 0)) {
               if(distance) setError("Distance must be > 0."); return;
            }
            
            switch (calcMode) {
               case CALC_MODE_GAMMA: {
                   let gammaConstant = 0;
                   if (inputMode === INPUT_MODE_DB) {
                       if (!selectedNuclide) return;
                       gammaConstant = parseFloat(selectedNuclide.gammaConstant);
                   } else {
                       gammaConstant = parseFloat(manualGammaConstant);
                   }
                   if (!gammaConstant || isNaN(gammaConstant)) return;
               
                   const transValue = parseFloat(transmission) || 1.0;
                   const d_m = d_val * distanceFactorsM[distanceUnit];
                   let doseRateR_hr = 0;
               
                   if (geometryMode === GEOMETRY_POINT) {
                       const A_Ci = A_val * activityFactorsCi[activityUnit];
                       doseRateR_hr = (gammaConstant * A_Ci) / Math.pow(d_m, 2);
                   } else if (geometryMode === GEOMETRY_LINE) {
                       const len_val = parseFloat(lineLength);
                       const len_m = len_val * distanceFactorsM[lineLengthUnit];
                       const A_L_Ci_m = A_val * linearActivityFactorsCi_per_m[linearActivityUnit];
                       doseRateR_hr = (gammaConstant * A_L_Ci_m / d_m) * 2 * Math.atan(len_m / (2 * d_m));
                   } else if (geometryMode === GEOMETRY_AREA) {
                       const r_val = parseFloat(diskRadius);
                       const r_m = r_val * distanceFactorsM[diskRadiusUnit];
                       const A_A_Ci_m2 = A_val * arealActivityFactorsCi_per_m2[arealActivityUnit];
                       doseRateR_hr = Math.PI * gammaConstant * A_A_Ci_m2 * Math.log((Math.pow(r_m, 2) + Math.pow(d_m, 2)) / Math.pow(d_m, 2));
                   }
                   
                   setResult({ 
                       type: 'gamma', 
                       rawDoseRate_mrem_hr: doseRateR_hr * 1000 * transValue, 
                       usedGamma: gammaConstant,
                       label: "Est. Dose Eq. (1 R ≈ 1 rem)" 
                   });
                   break;
               }
               
               case CALC_MODE_BETA: 
               case CALC_MODE_BREMS: {
                   let E_max = 0;
                   if (inputMode === INPUT_MODE_DB) {
                       if (!selectedNuclide) return;
                       if (selectedNuclide.emissionEnergies?.beta?.length > 0) {
                           E_max = parseEnergyToMeV(selectedNuclide.emissionEnergies.beta);
                       } else if (selectedNuclide.daughterEmissions?.beta?.length > 0) {
                           const str = selectedNuclide.daughterEmissions.beta[0];
                           E_max = parseFloat(str.split(' ')[0]);
                       }
                   } else {
                       E_max = parseFloat(manualBetaEnergy);
                   }
                   if (!E_max || isNaN(E_max)) return;
               
                   if (calcMode === CALC_MODE_BETA) {
                       if (betaMode === BETA_MODE_SKIN) {
                           const skin_val = parseFloat(skinActivity);
                           if (isNaN(skin_val)) return;
                           const conc_uCi_cm2 = skin_val * concentrationFactors_uCi_per_cm2[skinActivityUnit];
                           
                           let doseRate_rad_hr = 0;
                           let note = "";
                           if (E_max < 0.07) {
                               doseRate_rad_hr = 0;
                               note = `E_max (${E_max.toFixed(3)} MeV) is too low to penetrate the dead skin layer. Dose is zero.`;
                           } else {
                               let factor = 9.0;
                               if (E_max < 0.6) factor = 9.0 * ((E_max - 0.07) / (0.6 - 0.07));
                               doseRate_rad_hr = factor * conc_uCi_cm2;
                           }
                           setResult({ 
                               type: 'beta_skin', 
                               rawDoseRate_mrem_hr: doseRate_rad_hr * 1000, 
                               e_max: E_max, 
                               sourceNote: note,
                               label: "Skin Dose Rate" 
                           });
                       } else {
                           // Dose in Air (External Point Source)
                           const A_Ci = A_val * activityFactorsCi[activityUnit];
                           const d_ft = (d_val * distanceFactorsM[distanceUnit]) * 3.28084;
                           const d_m = d_val * distanceFactorsM[distanceUnit];
                           
                           let range_g_cm2 = E_max > 0.8 ? (0.542 * E_max - 0.133) : (0.407 * Math.pow(E_max, 1.38));
                           const density_air_g_cm3 = 0.001225; 
                           const range_m = (range_g_cm2 / density_air_g_cm3) / 100;
                           
                           const isBeyondRange = d_m >= range_m;
                           let doseRate_rad_hr = 0;
               
                           if (!isBeyondRange) {
                               doseRate_rad_hr = (300 * A_Ci) / Math.pow(d_ft, 2);
                           } else {
                               doseRate_rad_hr = 0; 
                           }
               
                           setResult({ 
                               type: 'beta_air', 
                               rawDoseRate_mrem_hr: doseRate_rad_hr * 1000, 
                               e_max: E_max, 
                               isBeyondRange, 
                               range_m: range_m.toPrecision(2),
                               warning: isBeyondRange ? "Target is beyond maximum beta range in air." : "Approximation: Uses '300 Rule'. Ignores air attenuation.",
                               label: "Dose Rate in Air"
                           });
                       }
                   } else {
                       // Bremsstrahlung
                       const matProps = SHIELD_PROPS[shieldMaterial];
                       if (!matProps) { setError("Invalid shield material."); return; }
                       const A_Ci = A_val * activityFactorsCi[activityUnit];
                       const d_m = d_val * distanceFactorsM[distanceUnit];
                       const doseRate_R_hr_1m = (6e-4 * matProps.Z * Math.pow(E_max, 2) * A_Ci);
                       const finalRate = doseRate_R_hr_1m / Math.pow(d_m, 2);
                       const fraction = 3.5e-4 * matProps.Z * E_max;
                       setResult({ 
                           type: 'bremsstrahlung', 
                           rawDoseRate_mrem_hr: finalRate * 1000, 
                           bremsstrahlungFraction: (fraction * 100).toPrecision(2),
                           label: "X-Ray Dose Rate (Brems.)"
                       });
                   }
                   break;
               }
               
               case CALC_MODE_INTERNAL: {
                   if (!selectedNuclide) return;
                   const I_val = parseFloat(intakeAmount);
                   if (isNaN(I_val) || I_val <= 0) return;
               
                   const dataKey = intakeRoute === 'ingestion' ? 'ingestion' : `inhalation_${solubility}`;
                   let cede_mrem = 0;
                   
                   if (doseMethod === METHOD_10CFR20) {
                       const I_uCi = I_val * intakeUnitFactors[intakeUnit];
                       const ALI = selectedNuclide.dosimetry.ALI?.[dataKey];
                       if (!ALI) { setError(`ALI not found for ${dataKey}`); setResult(null); return; }
                       cede_mrem = (I_uCi / ALI) * 5000;
                   } else {
                       const I_Bq = I_val * intakeUnitFactorsBq[intakeUnit];
                       const DCF = selectedNuclide.dosimetry.DCF?.[dataKey];
                       if (!DCF) { setError(`DCF not found for ${dataKey}`); setResult(null); return; }
                       cede_mrem = (I_Bq * DCF) * 100000;
                   }
                   setResult({ 
                       type: 'internal', 
                       rawDose_mrem: cede_mrem, 
                       method: doseMethod,
                       label: "Committed Dose (CEDE)"
                   });
                   break;
               }
               
               default: break;
            }
            // FIX: Added ALL missing unit dependencies here
            }, [calcMode, field_d1, field_d1Unit, field_r1, field_r1Unit, field_d2, field_d2Unit, field_r2, field_r2Unit, field_targetType, activity, activityUnit, distance, distanceUnit, geometryMode, inputMode, nuclideSymbol, manualGammaConstant, manualBetaEnergy, transmission, lineLength, lineLengthUnit, linearActivityUnit, diskRadius, diskRadiusUnit, arealActivityUnit, betaMode, skinActivity, skinActivityUnit, shieldMaterial, intakeRoute, solubility, intakeAmount, intakeUnit, doseMethod, selectedNuclide, activityFactorsCi]);
            
            // AUTO-CALCULATION TRIGGER
            React.useEffect(() => {
            handleCalculate();
            }, [handleCalculate]);
            
            const handleSaveToHistory = () => {
            if (result) {
               const formattedResult = formatDoseValue(
                   result.rawDoseRate_mrem_hr || result.rawDose_mrem, 
                   result.type === 'internal' ? 'dose' : 'doseRate', 
                   settings
               );
               
               let inputDetail = '';
               
               if (calcMode === CALC_MODE_FIELD) {
                   inputDetail = `Field: ${field_r1} ${field_r1Unit} @ ${field_d1} ${field_d1Unit}`;
               } 
               else if (calcMode === CALC_MODE_INTERNAL) {
                   inputDetail = `${intakeAmount} ${intakeUnit} ${nuclideSymbol} (${intakeRoute})`;
               } 
               else {
                   const source = nuclideSymbol || 'Manual Source';
                   inputDetail = `${activity} ${activityUnit} ${source} @ ${distance} ${distanceUnit}`;
                   
                   if (shieldMaterial !== 'None' && calcMode === CALC_MODE_BREMS) {
                       inputDetail += ` w/ ${shieldMaterial}`;
                   }
               }
               
               addHistory({ 
                   id: Date.now(), 
                   type: 'Dose Calculation', 
                   icon: ICONS.doseRate, 
                   inputs: inputDetail, 
                   result: `${formattedResult.value} ${formattedResult.unit}`, 
                   view: VIEWS.DOSE_RATE 
               });
               addToast("Saved to history!");
            }
            };
            
            const handleClear = () => {
            setCalcMode(CALC_MODE_GAMMA);
            setInputMode(INPUT_MODE_DB);
            setGeometryMode(GEOMETRY_POINT);
            setNuclideSymbol('');
            setActivity('1');
            setDistance('1');
            setTransmission('1.0');
            setField_r1('100'); setField_d1('1'); setField_d2('10'); setField_r2('2');
            setIntakeAmount('1');
            setResult(null);
            setError('');
            };
            
            return (
            <div className="p-4 animate-fade-in">
               <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                   <div className="flex justify-between items-center mb-6">
                       <h2 className="text-xl font-bold text-slate-800 dark:text-white">Dose Calculator</h2>
                       <ClearButton onClick={handleClear} />
                   </div>
                   
                   <div className="grid grid-cols-3 md:grid-cols-5 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-6 overflow-x-auto">
                       <button onClick={() => setCalcMode(CALC_MODE_FIELD)} className={`py-2 rounded-md text-xs font-bold transition-all ${calcMode === CALC_MODE_FIELD ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}>Field Calc</button>
                       <button onClick={() => setCalcMode(CALC_MODE_GAMMA)} className={`py-2 rounded-md text-xs font-bold transition-all ${calcMode === CALC_MODE_GAMMA ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}>Gamma</button>
                       <button onClick={() => setCalcMode(CALC_MODE_BETA)} className={`py-2 rounded-md text-xs font-bold transition-all ${calcMode === CALC_MODE_BETA ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}>Beta</button>
                       <button onClick={() => setCalcMode(CALC_MODE_BREMS)} className={`py-2 rounded-md text-xs font-bold transition-all ${calcMode === CALC_MODE_BREMS ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}>Brems.</button>
                       <button onClick={() => setCalcMode(CALC_MODE_INTERNAL)} className={`py-2 rounded-md text-xs font-bold transition-all ${calcMode === CALC_MODE_INTERNAL ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm' : 'text-slate-600 dark:text-slate-300'}`}>Internal</button>
                   </div>
                   
                   {/* --- FIELD CALC (INVERSE SQUARE) UI --- */}
                   {calcMode === CALC_MODE_FIELD && (
                       <div className="space-y-4 animate-fade-in">
                           <div className="p-4 bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-lg">
                               <h3 className="text-sm font-bold mb-3">Known Point</h3>
                               <div className="grid grid-cols-2 gap-4">
                                   <div><label className="block text-xs font-medium">Rate (I₁)</label><div className="flex"><input type="number" value={field_r1} onChange={e => setField_r1(e.target.value)} className="w-full p-2 rounded-l-md bg-white dark:bg-slate-700 text-sm"/><select value={field_r1Unit} onChange={e => setField_r1Unit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{doseRateUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                                   <div><label className="block text-xs font-medium">Distance (d₁)</label><div className="flex"><input type="number" value={field_d1} onChange={e => setField_d1(e.target.value)} className="w-full p-2 rounded-l-md bg-white dark:bg-slate-700 text-sm"/><select value={field_d1Unit} onChange={e => setField_d1Unit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                               </div>
                           </div>
                       
                           <div className="flex justify-center bg-slate-100 dark:bg-slate-900 rounded p-1 text-xs">
                               <button onClick={() => setField_targetType('findRate')} className={`flex-1 py-1 rounded ${field_targetType === 'findRate' ? 'bg-white dark:bg-slate-600 shadow font-bold text-sky-600' : ''}`}>Find New Rate (I₂)</button>
                               <button onClick={() => setField_targetType('findDist')} className={`flex-1 py-1 rounded ${field_targetType === 'findDist' ? 'bg-white dark:bg-slate-600 shadow font-bold text-sky-600' : ''}`}>Find Distance (d₂)</button>
                           </div>
                       
                           <div className="p-4 bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 rounded-lg">
                               {field_targetType === 'findRate' ? (
                                   <div><label className="block text-xs font-medium">Target Distance (d₂)</label><div className="flex"><input type="number" value={field_d2} onChange={e => setField_d2(e.target.value)} className="w-full p-2 rounded-l-md bg-white dark:bg-slate-700 text-sm"/><select value={field_d2Unit} onChange={e => setField_d2Unit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                               ) : (
                                   <div><label className="block text-xs font-medium">Target Rate (I₂)</label><div className="flex"><input type="number" value={field_r2} onChange={e => setField_r2(e.target.value)} className="w-full p-2 rounded-l-md bg-white dark:bg-slate-700 text-sm"/><select value={field_r2Unit} onChange={e => setField_r2Unit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{doseRateUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                               )}
                           </div>
                       </div>
                   )}
                   
                   {/* --- GAMMA UI --- */}
                   {calcMode === CALC_MODE_GAMMA && (
                       <div className="space-y-4 animate-fade-in">
                           {/* Geometry Selection */}
                           <div className="flex justify-center">
                               <div className="flex bg-slate-100 dark:bg-slate-900 rounded-lg p-1">
                                   <button onClick={() => setGeometryMode(GEOMETRY_POINT)} className={`px-3 py-1 text-xs font-bold rounded ${geometryMode === GEOMETRY_POINT ? 'bg-white dark:bg-slate-700 shadow text-sky-600' : ''}`}>Point</button>
                                   <button onClick={() => setGeometryMode(GEOMETRY_LINE)} className={`px-3 py-1 text-xs font-bold rounded ${geometryMode === GEOMETRY_LINE ? 'bg-white dark:bg-slate-700 shadow text-sky-600' : ''}`}>Line</button>
                                   <button onClick={() => setGeometryMode(GEOMETRY_AREA)} className={`px-3 py-1 text-xs font-bold rounded ${geometryMode === GEOMETRY_AREA ? 'bg-white dark:bg-slate-700 shadow text-sky-600' : ''}`}>Disk</button>
                               </div>
                           </div>
                           
                           {/* VISUALIZER */}
                           <div className="bg-white dark:bg-slate-900 border border-slate-100 dark:border-slate-800 rounded-lg">
                               <GeometryVisualizer mode={geometryMode} />
                           </div>
                       
                           {/* Common Inputs */}
                           <div className="flex justify-center mb-2"><div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1 text-xs"><button onClick={() => setInputMode(INPUT_MODE_DB)} className={`px-3 py-1 rounded ${inputMode === INPUT_MODE_DB ? 'bg-white dark:bg-slate-700 shadow' : ''}`}>Database</button><button onClick={() => setInputMode(INPUT_MODE_MANUAL)} className={`px-3 py-1 rounded ${inputMode === INPUT_MODE_MANUAL ? 'bg-white dark:bg-slate-700 shadow' : ''}`}>Manual</button></div></div>
                           
                           <div>
                               {inputMode === INPUT_MODE_DB ? (
                                   <div className="mt-1 min-h-[42px]">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={gammaNuclides} onSelect={setNuclideSymbol} placeholder="Select a gamma source..." />}</div>
                               ) : (
                                   <div className="animate-fade-in"><label className="block text-xs font-medium mb-1">Gamma Constant (Γ)</label><div className="flex"><input type="number" value={manualGammaConstant} onChange={e => setManualGammaConstant(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm" placeholder="R·m²/hr·Ci" /></div></div>
                               )}
                           </div>
                           
                           <div className="grid grid-cols-2 gap-4">
                               {geometryMode === GEOMETRY_POINT && (
                                   <div><label className="block text-xs font-medium">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                               )}
                               {geometryMode === GEOMETRY_LINE && (
                                   <div className="col-span-2 grid grid-cols-2 gap-4">
                                       <div><label className="block text-xs font-medium">Length (L)</label><div className="flex"><input type="number" value={lineLength} onChange={e => setLineLength(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={lineLengthUnit} onChange={e => setLineLengthUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                                       <div><label className="block text-xs font-medium">Linear Activity</label><select value={linearActivityUnit} onChange={e => setLinearActivityUnit(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"><option>µCi/cm</option><option>mCi/cm</option><option>Ci/cm</option><option>µCi/m</option><option>mCi/m</option><option>Ci/m</option></select></div>
                                   </div>
                               )}
                               {geometryMode === GEOMETRY_AREA && (
                                   <div className="col-span-2 grid grid-cols-2 gap-4">
                                       <div><label className="block text-xs font-medium">Radius (R)</label><div className="flex"><input type="number" value={diskRadius} onChange={e => setDiskRadius(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={diskRadiusUnit} onChange={e => setDiskRadiusUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                                       <div><label className="block text-xs font-medium">Areal Activity</label><select value={arealActivityUnit} onChange={e => setArealActivityUnit(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"><option>µCi/cm²</option><option>mCi/cm²</option><option>Ci/cm²</option><option>µCi/m²</option><option>mCi/m²</option><option>Ci/m²</option></select></div>
                                   </div>
                               )}
                               <div><label className="block text-xs font-medium">Distance (d or h)</label><div className="flex"><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                               
                               <div className="col-span-2">
                                   <label className="block text-xs font-medium mb-1">Transmission (0-1)</label>
                                   <input type="number" step="0.1" min="0" max="1" value={transmission} onChange={e => setTransmission(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm" placeholder="e.g. 0.5"/>
                               </div>
                           </div>
                       </div>
                   )}
                   
                   {/* --- BETA UI --- */}
                   {(calcMode === CALC_MODE_BETA || calcMode === CALC_MODE_BREMS) && (
                       <div className="space-y-4 animate-fade-in">
                           {/* Input Mode */}
                           <div className="flex justify-center mb-2"><div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1 text-xs"><button onClick={() => setInputMode(INPUT_MODE_DB)} className={`px-3 py-1 rounded ${inputMode === INPUT_MODE_DB ? 'bg-white dark:bg-slate-700 shadow' : ''}`}>Database</button><button onClick={() => setInputMode(INPUT_MODE_MANUAL)} className={`px-3 py-1 rounded ${inputMode === INPUT_MODE_MANUAL ? 'bg-white dark:bg-slate-700 shadow' : ''}`}>Manual E_max</button></div></div>
                           
                           {inputMode === INPUT_MODE_DB ? (
                               <div className="min-h-[42px]">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={betaNuclides} onSelect={setNuclideSymbol} placeholder="Select a beta source..." />}</div>
                           ) : (
                               <div><label className="block text-xs font-medium">Max Beta Energy (MeV)</label><input type="number" value={manualBetaEnergy} onChange={e => setManualBetaEnergy(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm"/></div>
                           )}
                       
                           {calcMode === CALC_MODE_BETA && (
                               <div className="flex gap-2 p-1 bg-slate-100 dark:bg-slate-900 rounded-lg"><button onClick={() => setBetaMode(BETA_MODE_SKIN)} className={`flex-1 py-1.5 text-sm font-medium rounded transition-colors ${betaMode === BETA_MODE_SKIN ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Skin Dose (Contamination)</button><button onClick={() => setBetaMode(BETA_MODE_AIR)} className={`flex-1 py-1.5 text-sm font-medium rounded transition-colors ${betaMode === BETA_MODE_AIR ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Dose in Air (External)</button></div>
                           )}
                       
                           {calcMode === CALC_MODE_BETA && betaMode === BETA_MODE_SKIN && (
                               <div><label className="block text-xs font-medium">Contamination Level</label><div className="flex"><input type="number" value={skinActivity} onChange={e => setSkinActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={skinActivityUnit} onChange={e => setSkinActivityUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{['dpm/100cm²', 'µCi/cm²'].map(u=><option key={u}>{u}</option>)}</select></div></div>
                           )}
                       
                           {calcMode === CALC_MODE_BETA && betaMode === BETA_MODE_AIR && (
                               <div className="grid grid-cols-2 gap-4">
                                   <div><label className="block text-xs font-medium">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                                   <div><label className="block text-xs font-medium">Distance</label><div className="flex"><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                               </div>
                           )}
                       
                           {calcMode === CALC_MODE_BREMS && (
                               <div className="space-y-4">
                                   <div><label className="block text-xs font-medium">Shielding Material</label><select value={shieldMaterial} onChange={e => setShieldMaterial(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm">{Object.keys(SHIELD_PROPS).filter(m => m !== 'None').map(m => <option key={m} value={m}>{m}</option>)}</select></div>
                                   <div className="grid grid-cols-2 gap-4">
                                       <div><label className="block text-xs font-medium">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                                       <div><label className="block text-xs font-medium">Distance</label><div className="flex"><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                                   </div>
                               </div>
                           )}
                       </div>
                   )}
                   
                   {/* --- INTERNAL UI --- */}
                   {calcMode === CALC_MODE_INTERNAL && (
                       <div className="space-y-4 animate-fade-in">
                           <div className="min-h-[42px]">{selectedNuclide ? <CalculatorNuclideInfo nuclide={selectedNuclide} onClear={() => setNuclideSymbol('')} /> : <SearchableSelect options={dosimetryNuclides} onSelect={setNuclideSymbol} placeholder="Select nuclide..." />}</div>
                           <div className="grid grid-cols-2 gap-4">
                               <div><label className="block text-xs font-medium">Method</label><select value={doseMethod} onChange={e => setDoseMethod(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm"><option value={METHOD_10CFR20}>10 CFR 20 (ALI)</option><option value={METHOD_FGR11}>FGR 11 (DCF)</option></select></div>
                               <div><label className="block text-xs font-medium">Route</label><select value={intakeRoute} onChange={e => setIntakeRoute(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm"><option value="inhalation">Inhalation</option><option value="ingestion">Ingestion</option></select></div>
                               {intakeRoute === 'inhalation' && (<div><label className="block text-xs font-medium">Lung Class</label><select value={solubility} onChange={e => setSolubility(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm" disabled={availableClasses.length === 0}>{availableClasses.length > 0 ? availableClasses.map(c=><option key={c}>{c}</option>) : <option>N/A</option>}</select></div>)}
                               <div><label className="block text-xs font-medium">Intake Amount</label><div className="flex"><input type="number" value={intakeAmount} onChange={e => setIntakeAmount(e.target.value)} className="w-full p-2 rounded-l-md bg-slate-100 dark:bg-slate-700 text-sm"/><select value={intakeUnit} onChange={e => setIntakeUnit(e.target.value)} className="rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs">{intakeUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                           </div>
                       </div>
                   )}
                   
                   {/* --- RESULTS --- */}
                   {result && (
                       <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm relative">
                           <div className="flex justify-end -mt-3 -mr-3 mb-2"><Tooltip text="Save to history"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip></div>
                           <p className="text-xs uppercase font-bold text-slate-500 mb-2">{result.label || "Calculated Dose Rate"}</p>
                           <div className="flex items-center justify-center gap-2">
                               {result.type === 'field' ? (
                                   <>
                                       <span className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">{formatNumber(result.val)}</span>
                                       <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{result.unit === 'doseRate' ? field_r1Unit : field_d2Unit}</span>
                                   </>
                               ) : (
                                   <>
                                       <span className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">
                                           {formatDoseValue(
                                               result.rawDoseRate_mrem_hr !== undefined ? result.rawDoseRate_mrem_hr : result.rawDose_mrem, 
                                               result.type === 'internal' ? 'dose' : 'doseRate', 
                                               settings
                                           ).value}
                                       </span>
                                       <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">
                                           {formatDoseValue(
                                               result.rawDoseRate_mrem_hr !== undefined ? result.rawDoseRate_mrem_hr : result.rawDose_mrem, 
                                               result.type === 'internal' ? 'dose' : 'doseRate', 
                                               settings
                                           ).unit}
                                       </span>
                                   </>
                               )}
                           </div>
                           
                           {/* Contextual Info */}
                           {result.usedGamma && <p className="text-xs text-slate-400 mt-2">Gamma Constant: {result.usedGamma} R·m²/hr·Ci</p>}
                           {result.sourceNote && <p className="text-xs text-amber-600 mt-2 italic">{result.sourceNote}</p>}
                           {result.bremsstrahlungFraction && <p className="text-xs text-slate-500 mt-2">Radiative Fraction: ~{result.bremsstrahlungFraction}%</p>}
                           
                           {/* Beta Air Warning Block */}
                           {result.type === 'beta_air' && (
                               <div className="mt-2 border-t border-slate-200 dark:border-slate-600 pt-2">
                                   <p className="text-xs font-semibold text-slate-500 dark:text-slate-400">Max Range in Air: {result.range_m} m</p>
                                   {result.warning && (
                                       <p className={`text-xs mt-2 p-1 rounded font-bold ${result.isBeyondRange ? 'text-amber-600 bg-amber-50 dark:bg-amber-900/20' : 'text-sky-600 bg-sky-50 dark:bg-sky-900/20'}`}>
                                           {result.warning}
                                       </p>
                                   )}
                               </div>
                           )}
                       </div>
                   )}
                   
                   {error && <p className="text-red-500 text-sm text-center mt-4">{error}</p>}
               </div>
            </div>
            );
            };
            
            /**
            * @description A calculator for photon shielding with three modes:
            * 1. (From Source) Calculates final dose rate from a specific radionuclide.
            * 2. (Find Thickness) Calculates required shielding thickness for a specific radionuclide.
            * 3. (Generic Rate) Calculates final OR initial dose rate from a user-inputted HVL.
            */
            
            const ShieldingCalculator = ({ radionuclides, preselectedNuclide }) => {
                // --- Constants ---
                const MODE_GAMMA_DOSE = 'gammaDose';
                const MODE_FIND_THICKNESS = 'findThickness';
                const MODE_BETA_RANGE = 'betaRange';
                
                const DEFINE_BY_SOURCE = 'bySource';
                const DEFINE_BY_RATE = 'byRate';
                
                const INPUT_MODE_DB = 'fromSource';
                const INPUT_MODE_MANUAL = 'manual';
                
                // --- Context & Hooks ---
                const { settings } = React.useContext(SettingsContext);
                const { addHistory } = useCalculationHistory();
                const { addToast } = useToast();
                
                // --- Units ---
                const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci'], [settings.unitSystem]);
                const distanceUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['mm', 'cm', 'm'] : ['in', 'ft', 'm'], [settings.unitSystem]);
                const doseRateUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['µSv/hr', 'mSv/hr', 'Sv/hr'] : ['µrem/hr', 'mrem/hr', 'rem/hr', 'mR/hr', 'R/hr'], [settings.unitSystem]);
                
                // --- State ---
                const [calcMode, setCalcMode] = React.useState(() => localStorage.getItem('shielding_calcMode') || MODE_GAMMA_DOSE);
                const [definitionMode, setDefinitionMode] = React.useState(DEFINE_BY_SOURCE);
                const [inputMode, setInputMode] = React.useState(INPUT_MODE_DB);
                const [useManualHVL, setUseManualHVL] = React.useState(false);
                const [useBuildup, setUseBuildup] = React.useState(false);
                
                const [nuclideSymbol, setNuclideSymbol] = React.useState(() => localStorage.getItem('shielding_nuclideSymbol') || '');
                const [activity, setActivity] = React.useState('1');
                const [activityUnit, setActivityUnit] = React.useState(activityUnits[1]);
                const [distance, setDistance] = React.useState('1');
                const [distanceUnit, setDistanceUnit] = React.useState(distanceUnits[2]);
                
                const [unshieldedRate, setUnshieldedRate] = React.useState('100');
                const [unshieldedRateUnit, setUnshieldedRateUnit] = React.useState(doseRateUnits[1]);
                
                const [genericReference, setGenericReference] = React.useState('Cs-137');
                
                const [manualGamma, setManualGamma] = React.useState('');
                const [manualHVL, setManualHVL] = React.useState('');
                const [manualBetaEnergy, setManualBetaEnergy] = React.useState('');
                
                const [shieldMaterial, setShieldMaterial] = React.useState('Lead');
                const [shieldThickness, setShieldThickness] = React.useState('1');
                const [thicknessUnit, setThicknessUnit] = React.useState('cm');
                const [targetDoseRate, setTargetDoseRate] = React.useState('2');
                const [targetDoseRateUnit, setTargetDoseRateUnit] = React.useState(doseRateUnits[1]);
                
                const [result, setResult] = React.useState(null);
                const [error, setError] = React.useState('');
                
                // --- Persistence ---
                React.useEffect(() => {
                    localStorage.setItem('shielding_calcMode', calcMode);
                    localStorage.setItem('shielding_nuclideSymbol', nuclideSymbol);
                }, [calcMode, nuclideSymbol]);
                
                // --- Data Sources ---
                const SHIELD_PROPS = {
                    'Lead': { density: 11.34, Z: 82, type: 'High-Z' },
                    'Steel': { density: 7.85, Z: 26, type: 'High-Z' },
                    'Tungsten': { density: 19.3, Z: 74, type: 'High-Z' },
                    'Concrete': { density: 2.35, Z: 11, type: 'Low-Z' },
                    'Aluminum': { density: 2.7, Z: 13, type: 'Low-Z' },
                    'Plastic': { density: 1.18, Z: 6, type: 'Low-Z' },
                    'Lucite/Acrylic': { density: 1.19, Z: 6, type: 'Low-Z' },
                    'Glass': { density: 2.23, Z: 11, type: 'Low-Z' },
                    'Water': { density: 1.0, Z: 7.4, type: 'Low-Z' }
                };
                
                const shieldingNuclides = React.useMemo(() => radionuclides.filter(n => n.gammaConstant && HVL_DATA[n.symbol]).sort((a,b) => a.name.localeCompare(b.name)), [radionuclides] );
                const betaNuclides = React.useMemo(() => radionuclides.filter(n => n.emissionEnergies?.beta?.length > 0).sort((a,b) => a.name.localeCompare(b.name)), [radionuclides] );
                
                const availableMaterials = React.useMemo(() => {
                    if (calcMode === MODE_BETA_RANGE) return Object.keys(SHIELD_PROPS);
                    if (useManualHVL) return ['Lead', 'Concrete', 'Steel', 'Water', 'Aluminum', 'Tungsten', 'Plastic', 'Glass'];
                    if (definitionMode === DEFINE_BY_RATE) return ['Lead', 'Concrete', 'Steel', 'Water', 'Aluminum'];
                    if (inputMode === INPUT_MODE_DB && nuclideSymbol && HVL_DATA[nuclideSymbol]) {
                        return Object.keys(HVL_DATA[nuclideSymbol]).filter(k => k !== 'sourceRef');
                    }
                    return ['Lead', 'Concrete', 'Steel', 'Water', 'Aluminum', 'Tungsten'];
                }, [calcMode, inputMode, nuclideSymbol, definitionMode, useManualHVL]);
                
                React.useEffect(() => {
                    if (!availableMaterials.includes(shieldMaterial)) setShieldMaterial(availableMaterials[0]);
                }, [availableMaterials, calcMode]);
                
                // Factors
                const activityFactors = { 'Bq': 1 / 3.7e10, 'kBq': 1 / 3.7e7, 'MBq': 1 / 37000, 'GBq': 1 / 37, 'TBq': 1/0.037, 'µCi': 1e-6, 'mCi': 1e-3, 'Ci': 1 };
                const distanceFactors = { 'mm': 0.001, 'cm': 0.01, 'm': 1, 'in': 0.0254, 'ft': 0.3048 };
                const thicknessFactors = { 'mm': 0.1, 'cm': 1, 'in': 2.54 };
                const doseRateFactors_mrem_hr = { 'µrem/hr': 0.001, 'mrem/hr': 1, 'rem/hr': 1000, 'mR/hr': 1, 'R/hr': 1000, 'µSv/hr': 0.1, 'mSv/hr': 100, 'Sv/hr': 100000 };
                
                // --- Core Calculation Logic ---
                React.useEffect(() => {
                    try {
                        setError(''); setResult(null);
                        
                        // 1. BETA CALCULATION
                        if (calcMode === MODE_BETA_RANGE) {
                            let E_max = 0;
                            if (inputMode === INPUT_MODE_DB) {
                                if (!nuclideSymbol) return;
                                const n = radionuclides.find(r => r.symbol === nuclideSymbol);
                                if (n?.emissionEnergies?.beta) E_max = parseEnergyToMeV(n.emissionEnergies.beta);
                            } else {
                                E_max = parseFloat(manualBetaEnergy);
                            }
                            
                            if (!E_max || E_max <= 0) return;
                            
                            const mat = SHIELD_PROPS[shieldMaterial];
                            if (!mat) { setError("Invalid shield material."); return; }
                            
                            let range_mg_cm2;
                            if (E_max > 0.8) range_mg_cm2 = 542 * E_max - 133;
                            else if (E_max >= 0.15) range_mg_cm2 = 407 * Math.pow(E_max, 1.38);
                            else range_mg_cm2 = 407 * Math.pow(E_max, 1.38);
                            
                            const density_mg_cm3 = mat.density * 1000;
                            const thickness_cm = range_mg_cm2 / density_mg_cm3;
                            
                            let warning = null;
                            if (mat.type === 'High-Z') {
                                warning = `High-Z material (${shieldMaterial}) generates Bremsstrahlung X-rays. Use Plastic/Lucite instead.`;
                            }
                            
                            setResult({ type: 'beta', thickness_cm, material: shieldMaterial, range_mg_cm2, warning });
                            return;
                        }
                        
                        // 2. GAMMA CALCULATIONS
                        let unshieldedRate_R_hr = 0;
                        
                        if (definitionMode === DEFINE_BY_RATE) {
                            const rateVal = parseFloat(unshieldedRate);
                            if (isNaN(rateVal) || rateVal < 0) { if(unshieldedRate) setError("Rate must be positive."); return; }
                            unshieldedRate_R_hr = (rateVal * doseRateFactors_mrem_hr[unshieldedRateUnit]) / 1000;
                        } else {
                            const actVal = parseFloat(activity);
                            const distVal = parseFloat(distance);
                            
                            if (isNaN(actVal) || isNaN(distVal) || actVal <= 0 || distVal <= 0) {
                                if (activity && distance) setError("Inputs must be valid positive numbers.");
                                return;
                            }
                            
                            let gammaConst = 0;
                            if (inputMode === INPUT_MODE_DB) {
                                if (nuclideSymbol) {
                                    const n = radionuclides.find(r => r.symbol === nuclideSymbol);
                                    gammaConst = parseFloat(n?.gammaConstant);
                                }
                            } else {
                                gammaConst = parseFloat(manualGamma);
                            }
                            
                            if (!gammaConst || isNaN(gammaConst)) {
                                if(inputMode === INPUT_MODE_MANUAL) setError("Invalid Gamma Constant.");
                                return;
                            }
                            
                            const actCi = actVal * activityFactors[activityUnit];
                            const distM = distVal * distanceFactors[distanceUnit];
                            unshieldedRate_R_hr = (gammaConst * actCi) / Math.pow(distM, 2);
                        }
                        
                        let hvl_cm = 0;
                        if (useManualHVL) {
                            hvl_cm = parseFloat(manualHVL);
                        } else if (definitionMode === DEFINE_BY_RATE) {
                            hvl_cm = HVL_DATA[genericReference]?.[shieldMaterial];
                        } else if (inputMode === INPUT_MODE_DB && nuclideSymbol) {
                            hvl_cm = HVL_DATA[nuclideSymbol]?.[shieldMaterial];
                        } else {
                            hvl_cm = parseFloat(manualHVL);
                        }
                        
                        if ((!useManualHVL && !hvl_cm) || isNaN(hvl_cm) || hvl_cm <= 0) {
                            if (shieldMaterial && definitionMode === DEFINE_BY_RATE) { /* Wait */ }
                            else if (shieldMaterial && nuclideSymbol) {
                                setError(`HVL data unavailable for ${shieldMaterial}. Enable "Override HVL" to enter it manually.`);
                            }
                            return;
                        }

                        // --- TVL CALCULATION (NEW) ---
                        // TVL is approximately 3.32 * HVL
                        const tvl_cm = hvl_cm * 3.3219;
                        
                        if (calcMode === MODE_GAMMA_DOSE) {
                            const thickVal = parseFloat(shieldThickness);
                            if (isNaN(thickVal) || thickVal < 0) return;
                            const thickCm = thickVal * thicknessFactors[thicknessUnit];
                            
                            let buildup = 1;
                            if (useBuildup) {
                                const mu = Math.log(2) / hvl_cm;
                                const mfp = mu * thickCm;
                                buildup = 1 + mfp;
                            }
                            
                            let transmission = Math.pow(0.5, thickCm / hvl_cm);
                            if (transmission < 1e-9) transmission = 0;
                            
                            const shieldedRate_R_hr = unshieldedRate_R_hr * transmission * buildup;
                            const shieldedRate_mrem_hr = shieldedRate_R_hr * 1000;
                            
                            let reductionFactor = transmission > 0 ? (1 / transmission) : 99999; 
                            if (reductionFactor > 10000) reductionFactor = 10000;
                            
                            let warning = null;
                            if (useBuildup && thickCm > (3 * hvl_cm)) {
                                warning = "Linear buildup approximation may underestimate dose for thick shields (>3 HVL).";
                            }
                            
                            setResult({
                                type: 'gamma_dose',
                                unshielded_mrem_hr: unshieldedRate_R_hr * 1000,
                                shielded_mrem_hr: shieldedRate_mrem_hr < 1e-9 ? 0 : shieldedRate_mrem_hr,
                                transmission: transmission,
                                reduction: reductionFactor,
                                buildup: buildup,
                                hvl: hvl_cm,
                                tvl: tvl_cm, // Added TVL
                                warning
                            });
                            
                        } else if (calcMode === MODE_FIND_THICKNESS) {
                            const targetVal = parseFloat(targetDoseRate);
                            if (isNaN(targetVal) || targetVal <= 0) return;
                            const target_R_hr = (targetVal * doseRateFactors_mrem_hr[targetDoseRateUnit]) / 1000;
                            
                            if (target_R_hr >= unshieldedRate_R_hr) {
                                setResult({ type: 'thickness', val: 0, msg: "Target > Unshielded Rate", unshielded_mrem_hr: unshieldedRate_R_hr * 1000, hvl: hvl_cm, tvl: tvl_cm });
                                return;
                            }
                            
                            let reqThickCm = hvl_cm * Math.log2(unshieldedRate_R_hr / target_R_hr);
                            
                            if (useBuildup) {
                                for(let i=0; i<5; i++) {
                                    const mfp = (Math.log(2) / hvl_cm) * reqThickCm;
                                    const B = 1 + mfp;
                                    reqThickCm = hvl_cm * Math.log2((unshieldedRate_R_hr * B) / target_R_hr);
                                }
                            }
                            
                            setResult({
                                type: 'thickness',
                                val: reqThickCm,
                                unshielded_mrem_hr: unshieldedRate_R_hr * 1000,
                                hvl: hvl_cm,
                                tvl: tvl_cm // Added TVL
                            });
                        }
                        
                    } catch (e) { setError(e.message); setResult(null); }
                }, [calcMode, definitionMode, inputMode, nuclideSymbol, manualGamma, manualHVL, manualBetaEnergy, activity, activityUnit, distance, distanceUnit, unshieldedRate, unshieldedRateUnit, genericReference, shieldMaterial, shieldThickness, thicknessUnit, targetDoseRate, targetDoseRateUnit, useManualHVL, useBuildup]);
                
                const handleSaveToHistory = () => {
                    if (!result) return;
                    let resStr = "";
                    if (result.type === 'beta' || result.type === 'thickness') {
                        const fmt = formatSensibleUnit(result.val || result.thickness_cm, 'distance');
                        resStr = `${fmt.value} ${fmt.unit} ${shieldMaterial}`;
                    } else {
                        const fmt = formatDoseValue(result.shielded_mrem_hr, 'doseRate', settings);
                        resStr = `${fmt.value} ${fmt.unit}`;
                    }
                    addHistory({ id: Date.now(), type: 'Shielding', icon: ICONS.shield, inputs: `${shieldMaterial} calculation`, result: resStr, view: VIEWS.SHIELDING });
                    addToast("Saved to history!");
                };
                
                const handleClearInputs = () => {
                    setCalcMode(MODE_GAMMA_DOSE);
                    setDefinitionMode(DEFINE_BY_SOURCE);
                    setInputMode(INPUT_MODE_DB);
                    setUseManualHVL(false);
                    setUseBuildup(false);
                    setNuclideSymbol('');
                    setActivity('1');
                    setUnshieldedRate('100');
                    setShieldMaterial('Lead');
                    setShieldThickness('1');
                    setResult(null);
                    setError('');
                };
                
                return (
                    <div className="p-4 animate-fade-in">
                        <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-xl font-bold text-slate-800 dark:text-white">Shielding Calculator</h2>
                                <ClearButton onClick={handleClearInputs} />
                            </div>
                            
                            {/* MAIN TABS */}
                            <div className="grid grid-cols-3 gap-2 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-6">
                                {[
                                    { id: MODE_GAMMA_DOSE, label: 'Gamma Dose' },
                                    { id: MODE_FIND_THICKNESS, label: 'Find Thickness' },
                                    { id: MODE_BETA_RANGE, label: 'Beta Range' }
                                ].map(tab => (
                                    <button key={tab.id} onClick={() => setCalcMode(tab.id)}
                                        className={`py-2 rounded-md text-sm font-bold transition-all
                                        ${calcMode === tab.id ? 'bg-sky-600 text-white shadow-sm' : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-600'}`}>
                                        {tab.label}
                                    </button>
                                ))}
                            </div>
                            
                            <div className="space-y-5">
                                {/* 1. GAMMA DEFINITION MODE */}
                                {calcMode !== MODE_BETA_RANGE && (
                                    <div className="flex justify-center mb-2">
                                        <div className="flex bg-slate-100 dark:bg-slate-900 rounded-lg p-1">
                                            <button onClick={() => setDefinitionMode(DEFINE_BY_SOURCE)} className={`px-4 py-1 text-xs font-bold rounded transition-colors ${definitionMode === DEFINE_BY_SOURCE ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Define Source</button>
                                            <button onClick={() => setDefinitionMode(DEFINE_BY_RATE)} className={`px-4 py-1 text-xs font-bold rounded transition-colors ${definitionMode === DEFINE_BY_RATE ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Known Dose Rate</button>
                                        </div>
                                    </div>
                                )}
                                
                                {/* 2. SOURCE INPUTS */}
                                {calcMode === MODE_BETA_RANGE || (definitionMode === DEFINE_BY_SOURCE) ? (
                                    <>
                                        {calcMode !== MODE_BETA_RANGE && (
                                            <div className="flex justify-end -mt-4 mb-2">
                                                <button onClick={() => setInputMode(inputMode === INPUT_MODE_DB ? INPUT_MODE_MANUAL : INPUT_MODE_DB)} className="text-xs text-sky-600 hover:underline">
                                                    Switch to {inputMode === INPUT_MODE_DB ? 'Manual' : 'Database'}
                                                </button>
                                            </div>
                                        )}
                                        
                                        {inputMode === INPUT_MODE_DB || calcMode === MODE_BETA_RANGE ? (
                                            <div className="min-h-[42px]">
                                                {nuclideSymbol ?
                                                    <CalculatorNuclideInfo nuclide={radionuclides.find(n => n.symbol === nuclideSymbol)} onClear={() => setNuclideSymbol('')} />
                                                    : <SearchableSelect options={calcMode === MODE_BETA_RANGE ? betaNuclides : shieldingNuclides} onSelect={setNuclideSymbol} placeholder="Select radionuclide..." />
                                                }
                                            </div>
                                        ) : (
                                            <div className="grid grid-cols-2 gap-4 animate-fade-in">
                                                <div><label className="text-xs font-bold">Gamma Constant (Γ)</label><input type="number" value={manualGamma} onChange={e => setManualGamma(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm" placeholder="R·m²/hr·Ci" /></div>
                                                <div><label className="text-xs font-bold">Half-Value Layer (cm)</label><input type="number" value={manualHVL} onChange={e => { setManualHVL(e.target.value); setUseManualHVL(true); }} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm" /></div>
                                            </div>
                                        )}
                                        
                                        {calcMode === MODE_BETA_RANGE && !nuclideSymbol && (
                                            <div><label className="text-xs font-bold">Max Beta Energy (MeV)</label><input type="number" value={manualBetaEnergy} onChange={e => setManualBetaEnergy(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm" /></div>
                                        )}
                                        
                                        {calcMode !== MODE_BETA_RANGE && (
                                            <div className="grid grid-cols-2 gap-4 animate-fade-in">
                                                <div><label className="text-xs font-bold mb-1 block">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u=><option key={u}>{u}</option>)}</select></div></div>
                                                <div><label className="text-xs font-bold mb-1 block">Distance</label><div className="flex"><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u=><option key={u}>{u}</option>)}</select></div></div>
                                            </div>
                                        )}
                                    </>
                                ) : (
                                    <div className="animate-fade-in">
                                        <label className="text-xs font-bold mb-1 block">Initial (Unshielded) Dose Rate</label>
                                        <div className="flex">
                                            <input type="number" value={unshieldedRate} onChange={e => setUnshieldedRate(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/>
                                            <select value={unshieldedRateUnit} onChange={e => setUnshieldedRateUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{doseRateUnits.map(u=><option key={u}>{u}</option>)}</select>
                                        </div>
                                        
                                        {!useManualHVL && (
                                            <div className="mt-3 p-3 bg-blue-50 dark:bg-blue-900/30 text-xs text-blue-800 dark:text-blue-200 rounded border border-blue-100 dark:border-blue-800">
                                                <p><strong>Note:</strong> Since the isotope is unknown, we must assume an energy to estimate shielding effectiveness.</p>
                                                <div className="mt-2 flex items-center gap-2">
                                                    <span className="font-semibold">Assume:</span>
                                                    <select value={genericReference} onChange={e => setGenericReference(e.target.value)} className="p-1 rounded border border-blue-200 dark:border-blue-700 dark:bg-slate-800">
                                                        <option value="I-125">Low Energy (I-125 / 30 keV)</option>
                                                        <option value="Cs-137">Medium Energy (Cs-137 / 662 keV)</option>
                                                        <option value="Co-60">High Energy (Co-60 / 1.25 MeV)</option>
                                                    </select>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                                    <div className="flex justify-between items-center">
                                        <label className="text-sm font-bold text-slate-700 dark:text-slate-300">Shielding Configuration</label>
                                        {calcMode !== MODE_BETA_RANGE && (inputMode === INPUT_MODE_DB || definitionMode === DEFINE_BY_RATE) && (
                                            <label className="flex items-center gap-2 text-xs cursor-pointer"><input type="checkbox" checked={useManualHVL} onChange={e => setUseManualHVL(e.target.checked)} className="form-checkbox h-3 w-3 rounded text-sky-600" /> Override HVL</label>
                                        )}
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="text-xs font-medium mb-1 block">Material</label>
                                            <select value={shieldMaterial} onChange={e => setShieldMaterial(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm">
                                                {availableMaterials.map(m => <option key={m} value={m}>{m}</option>)}
                                            </select>
                                        </div>
                                        
                                        {calcMode === MODE_GAMMA_DOSE && (
                                            <div><label className="text-xs font-medium mb-1 block">Thickness</label><div className="flex"><input type="number" value={shieldThickness} onChange={e => setShieldThickness(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={thicknessUnit} onChange={e => setThicknessUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{Object.keys(thicknessFactors).map(u=><option key={u}>{u}</option>)}</select></div></div>
                                        )}
                                        
                                        {useManualHVL && calcMode !== MODE_BETA_RANGE && (
                                            <div className="col-span-2"><label className="text-xs font-medium mb-1 block">Manual HVL (cm)</label><input type="number" value={manualHVL} onChange={e => setManualHVL(e.target.value)} className="w-full p-2 bg-slate-100 dark:bg-slate-700 rounded text-sm" /></div>
                                        )}
                                        
                                        {calcMode === MODE_FIND_THICKNESS && (
                                            <div className="col-span-2"><label className="text-xs font-medium mb-1 block">Target Dose Rate</label><div className="flex"><input type="number" value={targetDoseRate} onChange={e => setTargetDoseRate(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={targetDoseRateUnit} onChange={e => setTargetDoseRateUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{doseRateUnits.map(u=><option key={u}>{u}</option>)}</select></div></div>
                                        )}
                                    </div>
                                    
                                    {calcMode !== MODE_BETA_RANGE && (
                                        <div className="flex justify-end pt-2">
                                            <Tooltip text="Approximation (B = 1 + μx). Conservative for < 3 mfp."><label className="flex items-center gap-2 text-xs font-semibold cursor-pointer text-slate-600 dark:text-slate-400"><input type="checkbox" checked={useBuildup} onChange={e => setUseBuildup(e.target.checked)} className="form-checkbox h-3 w-3 rounded text-sky-600" /> Apply Buildup Factor</label></Tooltip>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {error && <p className="text-red-500 text-sm text-center mt-4 bg-red-50 dark:bg-red-900/20 p-2 rounded">{error}</p>}
                            
                            {result && (
                                <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm relative overflow-hidden">
                                    <div className="flex justify-end -mt-3 -mr-3 mb-2"><Tooltip text="Save to history"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip></div>
                                    
                                    {result.type === 'gamma_dose' && (
                                        <>
                                            <p className="text-xs uppercase font-bold text-slate-500 mb-2">Shielded Dose Rate</p>
                                            <div className="flex items-center justify-center gap-2 mb-4">
                                                <span className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">{formatDoseValue(result.shielded_mrem_hr, 'doseRate', settings).value}</span>
                                                <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{formatDoseValue(result.shielded_mrem_hr, 'doseRate', settings).unit}</span>
                                                <CopyButton textToCopy={formatDoseValue(result.shielded_mrem_hr, 'doseRate', settings).value} />
                                            </div>
                                            <div className="grid grid-cols-2 gap-2 text-xs text-slate-600 dark:text-slate-300 border-t border-slate-200 dark:border-slate-600 pt-3">
                                                <p>Unshielded: <strong>{formatDoseValue(result.unshielded_mrem_hr, 'doseRate', settings).value} {formatDoseValue(result.unshielded_mrem_hr, 'doseRate', settings).unit}</strong></p>
                                                
                                                {/* NEW TVL & HVL DISPLAY */}
                                                <p>HVL: <strong>{result.hvl ? result.hvl.toFixed(3) : 'N/A'} cm</strong></p>
                                                <p>TVL: <strong>{result.tvl ? result.tvl.toFixed(3) : 'N/A'} cm</strong></p>
                                                
                                                <p>Shielding Factor: <strong>{result.reduction > 10 ? Math.round(result.reduction) : result.reduction.toFixed(1)}x</strong></p>
                                                <p>Transmission: <strong>{(result.transmission * 100).toFixed(1)}%</strong></p>
                                                {useBuildup && <p>Buildup Factor: <strong>{result.buildup.toFixed(2)}</strong></p>}
                                            </div>
                                        </>
                                    )}
                                    
                                    {result.type === 'thickness' && (
                                        <>
                                            {result.val === 0 ? (
                                                <p className="text-amber-600 font-bold">No shielding required</p>
                                            ) : (
                                                <>
                                                    <p className="text-xs uppercase font-bold text-slate-500 mb-2">Required Thickness</p>
                                                    <div className="flex items-center justify-center gap-2 mb-2">
                                                        <span className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">{formatSensibleUnit(result.val, 'distance').value}</span>
                                                        <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{formatSensibleUnit(result.val, 'distance').unit}</span>
                                                    </div>
                                                    <p className="text-sm text-slate-500">of {shieldMaterial}</p>
                                                    <p className="text-xs text-slate-400 mt-1">
                                                        HVL: {result.hvl ? result.hvl.toFixed(3) : 'N/A'} cm | TVL: {result.tvl ? result.tvl.toFixed(3) : 'N/A'} cm
                                                    </p>
                                                </>
                                            )}
                                        </>
                                    )}
                                    
                                    {result.type === 'beta' && (
                                        <>
                                            <p className="text-xs uppercase font-bold text-slate-500 mb-2">Range (Stopping Thickness)</p>
                                            <div className="flex items-center justify-center gap-2 mb-2">
                                                <span className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">{formatSensibleUnit(result.thickness_cm, 'distance').value}</span>
                                                <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{formatSensibleUnit(result.thickness_cm, 'distance').unit}</span>
                                            </div>
                                            <p className="text-sm text-slate-500">of {result.material}</p>
                                        </>
                                    )}
                                    
                                    {/* WARNINGS */}
                                    <div className="space-y-2 mt-4 text-left">
                                        {result.warning && <div className="p-2 bg-amber-100 dark:bg-amber-900/50 text-amber-800 dark:text-amber-200 text-xs rounded font-medium border-l-4 border-amber-500">{result.warning}</div>}
                                        {result.msg && <div className="p-2 bg-green-100 dark:bg-green-900/50 text-green-800 dark:text-green-200 text-xs rounded">{result.msg}</div>}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            };
            
            /**
            * @description A calculator for determining allowable stay time and total dose received.
            * The dose rate can be calculated from a specific source or entered manually.
            */
            
            const StayTimeCalculator = ({ radionuclides, preselectedNuclide }) => {
            const INPUT_MODE_SOURCE = 'fromSource';
            const INPUT_MODE_MANUAL = 'manualRate';
            
            const { settings } = React.useContext(SettingsContext);
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            const activityUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['Bq', 'kBq', 'MBq', 'GBq', 'TBq'] : ['µCi', 'mCi', 'Ci'], [settings.unitSystem]);
            const distanceUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['mm', 'cm', 'm'] : ['in', 'ft', 'm'], [settings.unitSystem]);
            const doseRateUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['µSv/hr', 'mSv/hr', 'Sv/hr'] : ['µrem/hr', 'mrem/hr', 'rem/hr'], [settings.unitSystem]);
            const doseUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['µSv', 'mSv', 'Sv'] : ['µrem', 'mrem', 'rem'], [settings.unitSystem]);
            
            const [inputMode, setInputMode] = React.useState(() => localStorage.getItem('stayTime_inputMode') || INPUT_MODE_SOURCE);
            const [nuclideSymbol, setNuclideSymbol] = React.useState(() => localStorage.getItem('stayTime_nuclideSymbol') || '');
            
            const [activity, setActivity] = React.useState(() => localStorage.getItem('stayTime_activity') || '1');
            const [activityUnit, setActivityUnit] = React.useState(activityUnits[1]);
            const [distance, setDistance] = React.useState(() => localStorage.getItem('stayTime_distance') || '1');
            const [distanceUnit, setDistanceUnit] = React.useState(distanceUnits[2]);
            const [transmission, setTransmission] = React.useState(() => localStorage.getItem('stayTime_transmission') || '1.0');
            
            const [manualDoseRate, setManualDoseRate] = React.useState(() => localStorage.getItem('stayTime_manualDoseRate') || '10');
            const [manualDoseRateUnit, setManualDoseRateUnit] = React.useState(doseRateUnits[1]);
            
            const [doseLimit, setDoseLimit] = React.useState(() => localStorage.getItem('stayTime_doseLimit') || '100');
            const [doseLimitUnit, setDoseLimitUnit] = React.useState(doseUnits[1]);
            
            const [plannedTime, setPlannedTime] = React.useState(() => localStorage.getItem('stayTime_plannedTime') || '10');
            const [plannedTimeUnit, setPlannedTimeUnit] = React.useState(() => localStorage.getItem('stayTime_plannedTimeUnit') || 'minutes');
            
            const [result, setResult] = React.useState(null);
            const [error, setError] = React.useState('');
            
            // --- Persistence ---
            React.useEffect(() => {
            localStorage.setItem('stayTime_inputMode', inputMode);
            localStorage.setItem('stayTime_nuclideSymbol', nuclideSymbol);
            localStorage.setItem('stayTime_activity', activity);
            localStorage.setItem('stayTime_distance', distance);
            localStorage.setItem('stayTime_transmission', transmission);
            localStorage.setItem('stayTime_manualDoseRate', manualDoseRate);
            localStorage.setItem('stayTime_doseLimit', doseLimit);
            localStorage.setItem('stayTime_plannedTime', plannedTime);
            localStorage.setItem('stayTime_plannedTimeUnit', plannedTimeUnit);
            }, [inputMode, nuclideSymbol, activity, distance, transmission, manualDoseRate, doseLimit, plannedTime, plannedTimeUnit]);
            
            React.useEffect(() => { if (!activityUnits.includes(activityUnit)) setActivityUnit(activityUnits[1]); }, [activityUnits, activityUnit]);
            React.useEffect(() => { if (!distanceUnits.includes(distanceUnit)) setDistanceUnit(distanceUnits[2]); }, [distanceUnits, distanceUnit]);
            React.useEffect(() => { if (!doseRateUnits.includes(manualDoseRateUnit)) setManualDoseRateUnit(doseRateUnits[1]); }, [doseRateUnits, manualDoseRateUnit]);
            React.useEffect(() => { if (!doseUnits.includes(doseLimitUnit)) setDoseLimitUnit(doseUnits[1]); }, [doseUnits, doseLimitUnit]);
            
            React.useEffect(() => {
            setResult(null);
            setError('');
            }, [inputMode]);
            
            React.useEffect(() => {
            const gammaNuclides = radionuclides.filter(n => n.gammaConstant);
            if (preselectedNuclide && gammaNuclides.find(n => n.symbol === preselectedNuclide)) {
            setNuclideSymbol(preselectedNuclide);
            setInputMode(INPUT_MODE_SOURCE);
            }
            }, [preselectedNuclide, radionuclides]);
            
            // --- Factors ---
            const activityFactorsCi = { 'Bq': 1 / 3.7e10, 'kBq': 1 / 3.7e7, 'MBq': 1 / 37000, 'GBq': 1 / 37, 'TBq': 1/0.037, 'µCi': 1e-6, 'mCi': 1e-3, 'Ci': 1 };
            const distanceFactorsM = { 'mm': 0.001, 'cm': 0.01, 'm': 1, 'in': 0.0254, 'ft': 0.3048 };
            const timeFactorsHours = { 'minutes': 1 / 60, 'hours': 1, 'days': 24 };
            const doseRateFactors_mrem_hr = { 'µrem/hr': 0.001, 'mrem/hr': 1, 'rem/hr': 1000, 'µSv/hr': 0.1, 'mSv/hr': 100, 'Sv/hr': 100000 };
            const doseFactors_mrem = { 'µrem': 0.001, 'mrem': 1, 'rem': 1000, 'µSv': 0.1, 'mSv': 100, 'Sv': 100000 };
            const timeUnits_ordered = ['minutes', 'hours', 'days'];
            const gammaNuclides = React.useMemo(() => radionuclides.filter(n => n.gammaConstant).sort((a,b) => a.name.localeCompare(b.name)), [radionuclides] );
            
            // --- Calculation ---
            const handleCalculate = React.useCallback(() => {
            let effectiveDoseRate_mrem_hr = 0;
            try {
            const transValue = parseFloat(transmission);
            if (isNaN(transValue) || transValue < 0 || transValue > 1) { throw new Error('Transmission must be between 0 and 1.'); }
            
            if (inputMode === INPUT_MODE_SOURCE) {
            const nuclide = gammaNuclides.find(n => n.symbol === nuclideSymbol);
            if (!nuclide) { throw new Error('Please select a radionuclide.'); }
            const activityValue = parseFloat(activity);
            const distanceValue = parseFloat(distance);
            
            if (isNaN(activityValue) || isNaN(distanceValue) || distanceValue <= 0 || activityValue < 0) { throw new Error('Please enter valid, positive numbers for activity and distance.'); }
            
            const gammaConstant = parseFloat(nuclide.gammaConstant);
            const activityInCi = activityValue * activityFactorsCi[activityUnit];
            const distanceInM = distanceValue * distanceFactorsM[distanceUnit];
            
            // Inverse Square + Transmission
            const doseRateR_hr = (gammaConstant * activityInCi) / Math.pow(distanceInM, 2);
            effectiveDoseRate_mrem_hr = doseRateR_hr * 1000 * transValue;
            
            } else {
            const manualRate = parseFloat(manualDoseRate);
            if (isNaN(manualRate) || manualRate < 0) { throw new Error('Please enter a valid, non-negative dose rate.'); }
            const baseRate = manualRate * doseRateFactors_mrem_hr[manualDoseRateUnit];
            
            // FIX: Apply transmission to manual rate too
            effectiveDoseRate_mrem_hr = baseRate * transValue;
            }
            
            const limitVal = parseFloat(doseLimit);
            const plannedTimeValue = parseFloat(plannedTime);
            if (isNaN(limitVal) || isNaN(plannedTimeValue) || limitVal <= 0 || plannedTimeValue < 0) { throw new Error('Please enter valid, positive numbers for dose limit and planned time.'); }
            
            if (effectiveDoseRate_mrem_hr <= 1e-9) {
             setResult({ rawDoseRate_mrem_hr: 0, stayTime: 'Infinite', rawTotalDose_mrem: 0, isSafe: true });
             return;
            }
            
            const limit_mrem = limitVal * doseFactors_mrem[doseLimitUnit];
            const stayTimeHours = limit_mrem / effectiveDoseRate_mrem_hr;
            
            let formattedStayTime = "";
            const totalMinutes = stayTimeHours * 60;
            if (totalMinutes > 6000) {
               formattedStayTime = `> 100 hours`;
            } else if (totalMinutes > 60) {
              const hrs = Math.floor(totalMinutes / 60);
              const mins = Math.round(totalMinutes % 60);
              formattedStayTime = `${hrs} hr ${mins} min`;
            } else {
              const mins = Math.floor(totalMinutes);
              const secs = Math.round((totalMinutes - mins) * 60);
              formattedStayTime = `${mins} min ${secs} sec`;
            }
            
            const plannedTimeInHours = plannedTimeValue * timeFactorsHours[plannedTimeUnit];
            const totalDoseReceived_mrem = effectiveDoseRate_mrem_hr * plannedTimeInHours;
            const isSafe = totalDoseReceived_mrem <= limit_mrem;
            
            setResult({ rawDoseRate_mrem_hr: effectiveDoseRate_mrem_hr, stayTime: formattedStayTime, rawTotalDose_mrem: totalDoseReceived_mrem, isSafe: isSafe });
            } catch(e) {
            setError(e.message);
            setResult(null);
            }
            }, [inputMode, nuclideSymbol, activity, activityUnit, distance, distanceUnit, transmission, manualDoseRate, manualDoseRateUnit, doseLimit, doseLimitUnit, plannedTime, plannedTimeUnit, gammaNuclides]);
            
            React.useEffect(() => {
            setResult(null);
            setError('');
            if (inputMode === INPUT_MODE_SOURCE && !nuclideSymbol) { return; }
            handleCalculate();
            }, [handleCalculate]);
            
            const handleClearInputs = () => {
            setInputMode(INPUT_MODE_SOURCE);
            setNuclideSymbol('');
            setActivity('1');
            setDistance('1');
            setTransmission('1.0');
            setManualDoseRate('10');
            setDoseLimit('100');
            setPlannedTime('10');
            setError('');
            setResult(null);
            
            const keysToClear = ['stayTime_inputMode', 'stayTime_nuclideSymbol', 'stayTime_activity', 'stayTime_distance', 'stayTime_transmission', 'stayTime_manualDoseRate', 'stayTime_doseLimit', 'stayTime_plannedTime'];
            keysToClear.forEach(key => localStorage.removeItem(key));
            };
            
            const handleSaveToHistory = () => {
            if (result) {
            const formattedDoseRate = formatDoseValue(result.rawDoseRate_mrem_hr, 'doseRate', settings);
            addHistory({
             id: Date.now(),
             type: 'Stay Time',
             icon: ICONS.stopwatch,
             inputs: `${formattedDoseRate.value} ${formattedDoseRate.unit}, ${doseLimit} ${doseLimitUnit} limit`,
             result: result.stayTime,
             view: VIEWS.STAY_TIME
            });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-md mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
            <div className="flex justify-between items-center mb-6">
                <h2 className="text-xl font-bold text-slate-800 dark:text-white">Stay Time Calculator</h2>
                <ClearButton onClick={handleClearInputs} />
            </div>
            
            <div className="flex justify-center mb-6">
                <div className="flex bg-slate-100 dark:bg-slate-900 rounded-lg p-1 w-full">
                    <button onClick={() => setInputMode(INPUT_MODE_SOURCE)} className={`flex-1 py-1.5 text-sm font-medium rounded transition-colors ${inputMode === INPUT_MODE_SOURCE ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Calculate from Source</button>
                    <button onClick={() => setInputMode(INPUT_MODE_MANUAL)} className={`flex-1 py-1.5 text-sm font-medium rounded transition-colors ${inputMode === INPUT_MODE_MANUAL ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Known Dose Rate</button>
                </div>
            </div>
            
            <div className="space-y-4">
                {inputMode === INPUT_MODE_SOURCE ? (
                    <div className="space-y-4 animate-fade-in">
                        <div className="min-h-[42px]">
                            {nuclideSymbol ?
                                <CalculatorNuclideInfo nuclide={gammaNuclides.find(n => n.symbol === nuclideSymbol)} onClear={() => setNuclideSymbol('')} /> :
                                <SearchableSelect options={gammaNuclides} onSelect={setNuclideSymbol} placeholder="Select a gamma source..." />
                            }
                        </div>
            
                        <div className="grid grid-cols-2 gap-4">
                            <div><label className="text-xs font-bold mb-1 block">Activity</label><div className="flex"><input type="number" value={activity} onChange={e => setActivity(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={activityUnit} onChange={e => setActivityUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{activityUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                            <div><label className="text-xs font-bold mb-1 block">Distance</label><div className="flex"><input type="number" value={distance} onChange={e => setDistance(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={distanceUnit} onChange={e => setDistanceUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{distanceUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                        </div>
                    </div>
                ) : (
                    <div className="animate-fade-in">
                        <label className="text-xs font-bold mb-1 block">Work Area Dose Rate (Unshielded)</label>
                        <div className="flex"><input type="number" value={manualDoseRate} onChange={e => setManualDoseRate(e.target.value)} className="w-full p-2 rounded-l bg-slate-100 dark:bg-slate-700 text-sm"/><select value={manualDoseRateUnit} onChange={e => setManualDoseRateUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{doseRateUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div>
                    </div>
                )}
            
                {/* Shared Transmission Input */}
                <div>
                    <Tooltip text="Factor to account for shielding. 1.0 = Unshielded. 0.5 = 1 HVL.">
                        <label className="text-xs font-bold mb-1 block cursor-help underline decoration-dotted">Transmission Factor (0-1)</label>
                    </Tooltip>
                    <input type="number" step="0.1" min="0" max="1" value={transmission} onChange={e => setTransmission(e.target.value)} className="w-full p-2 rounded bg-slate-100 dark:bg-slate-700 text-sm" placeholder="e.g., 0.5 for 1 HVL"/>
                </div>
            
                {/* Planning Section */}
                <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4 bg-slate-50 dark:bg-slate-800/50">
                    <div className="flex items-center gap-2 mb-1"><Icon path={ICONS.stopwatch} className="w-4 h-4 text-slate-400"/><span className="text-sm font-bold text-slate-600 dark:text-slate-300">ALARA Planning</span></div>
                    <div className="grid grid-cols-2 gap-4">
                        <div><label className="text-xs font-bold mb-1 block">Dose Limit</label><div className="flex"><input type="number" value={doseLimit} onChange={e => setDoseLimit(e.target.value)} className="w-full p-2 rounded-l bg-white dark:bg-slate-700 text-sm"/><select value={doseLimitUnit} onChange={e => setDoseLimitUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{doseUnits.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                        <div><label className="text-xs font-bold mb-1 block">Planned Time</label><div className="flex"><input type="number" value={plannedTime} onChange={e => setPlannedTime(e.target.value)} className="w-full p-2 rounded-l bg-white dark:bg-slate-700 text-sm"/><select value={plannedTimeUnit} onChange={e => setPlannedTimeUnit(e.target.value)} className="rounded-r bg-slate-200 dark:bg-slate-600 text-xs">{timeUnits_ordered.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
                    </div>
                </div>
            
                {error && <p className="text-red-500 text-sm text-center bg-red-50 dark:bg-red-900/20 p-2 rounded">{error}</p>}
            
                {result && (
                    <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm relative overflow-hidden">
                        <div className="flex justify-end -mt-3 -mr-3 mb-2"><Tooltip text="Save to history"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip></div>
            
                        <p className="text-xs uppercase font-bold text-slate-500 mb-2">Maximum Stay Time</p>
                        <div className="flex items-center justify-center gap-2 mb-4">
                            <span className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">{result.stayTime}</span>
                            <CopyButton textToCopy={result.stayTime} />
                        </div>
            
                        <div className="grid grid-cols-2 gap-2 text-xs text-slate-600 dark:text-slate-300 border-t border-slate-200 dark:border-slate-600 pt-3">
                            <div>
                                <p>Effective Rate:</p>
                                <p className="font-bold text-sm text-slate-800 dark:text-white">
                                    {formatDoseValue(result.rawDoseRate_mrem_hr, 'doseRate', settings).value} {formatDoseValue(result.rawDoseRate_mrem_hr, 'doseRate', settings).unit}
                                </p>
                            </div>
                            <div>
                                <p>Proj. Dose:</p>
                                <p className={`font-bold text-sm ${result.isSafe ? 'text-green-600 dark:text-green-400' : 'text-red-500'}`}>
                                    {formatDoseValue(result.rawTotalDose_mrem, 'dose', settings).value} {formatDoseValue(result.rawTotalDose_mrem, 'dose', settings).unit}
                                </p>
                            </div>
                        </div>
            
                        {!result.isSafe && <p className="text-xs font-bold text-red-500 mt-2 bg-red-50 dark:bg-red-900/30 p-1 rounded">Planned time exceeds dose limit!</p>}
                    </div>
                )}
            </div>
            </div>
            </div>
            );
            };
            
            /**
            * Data and components for the Neutron Tools module.
            */
            
            // --- Data from 10 CFR 20.1004 for Fluence/Dose Conversion ---
            
            const NEUTRON_CONVERSION_FACTORS = [
            { energyMeV: 2.5e-8, fluencePerRem: 980e6, q: 2, label: 'Thermal (0.025 eV)' },
            { energyMeV: 1e-7, fluencePerRem: 980e6, q: 2, label: '0.1 eV' },
            { energyMeV: 1e-6, fluencePerRem: 810e6, q: 2, label: '1 eV' },
            { energyMeV: 1e-5, fluencePerRem: 810e6, q: 2, label: '10 eV' },
            { energyMeV: 1e-4, fluencePerRem: 840e6, q: 2, label: '100 eV' },
            { energyMeV: 1e-3, fluencePerRem: 980e6, q: 2, label: '1 keV' },
            { energyMeV: 1e-2, fluencePerRem: 1000e6, q: 2.5, label: '10 keV' },
            { energyMeV: 1e-1, fluencePerRem: 170e6, q: 7.5, label: '100 keV' },
            { energyMeV: 5e-1, fluencePerRem: 39e6, q: 11, label: '0.5 MeV' },
            { energyMeV: 1, fluencePerRem: 27e6, q: 11, label: '1 MeV' },
            { energyMeV: 2.5, fluencePerRem: 29e6, q: 9, label: '2.5 MeV' },
            { energyMeV: 5, fluencePerRem: 23e6, q: 8, label: '5 MeV' },
            { energyMeV: 7, fluencePerRem: 24e6, q: 7, label: '7 MeV' },
            { energyMeV: 10, fluencePerRem: 24e6, q: 6.5, label: '10 MeV' },
            { energyMeV: 14, fluencePerRem: 17e6, q: 7.5, label: '14 MeV' },
            { energyMeV: 20, fluencePerRem: 16e6, q: 8, label: '20 MeV' },
            { energyMeV: 40, fluencePerRem: 14e6, q: 7, label: '40 MeV' },
            { energyMeV: 60, fluencePerRem: 16e6, q: 5.5, label: '60 MeV' },
            { energyMeV: 100, fluencePerRem: 20e6, q: 4, label: '100 MeV' },
            { energyMeV: 200, fluencePerRem: 19e6, q: 3.5, label: '200 MeV' },
            { energyMeV: 300, fluencePerRem: 19e6, q: 3.5, label: '300 MeV' },
            { energyMeV: 400, fluencePerRem: 20e6, q: 3.5, label: '400 MeV' }
            ];
            
            // 1. Updated Data with Abundances
            const NEUTRON_ACTIVATION_DATA = [
            { targetSymbol: 'Co-59', name: 'Cobalt-59', atomicWeight: 58.933, thermalCrossSection_barns: 37.2, productSymbol: 'Co-60', abundance: 100 },
            { targetSymbol: 'Na-23', name: 'Sodium-23', atomicWeight: 22.990, thermalCrossSection_barns: 0.53, productSymbol: 'Na-24', abundance: 100 },
            { targetSymbol: 'Au-197', name: 'Gold-197', atomicWeight: 196.967, thermalCrossSection_barns: 98.65, productSymbol: 'Au-198', abundance: 100 },
            { targetSymbol: 'Ir-191', name: 'Iridium-191', atomicWeight: 190.960, thermalCrossSection_barns: 954, productSymbol: 'Ir-192', abundance: 37.3 },
            { targetSymbol: 'Ho-165', name: 'Holmium-165', atomicWeight: 164.930, thermalCrossSection_barns: 64.7, productSymbol: 'Ho-166', abundance: 100 },
            { targetSymbol: 'Fe-58', name: 'Iron-58', atomicWeight: 57.933, thermalCrossSection_barns: 1.3, productSymbol: 'Fe-59', abundance: 0.282 },
            { targetSymbol: 'Lu-176', name: 'Lutetium-176', atomicWeight: 175.942, thermalCrossSection_barns: 2090, productSymbol: 'Lu-177', abundance: 2.59 },
            { targetSymbol: 'Ta-181', name: 'Tantalum-181', atomicWeight: 180.948, thermalCrossSection_barns: 20.6, productSymbol: 'Ta-182', abundance: 99.988 },
            { targetSymbol: 'Sc-45', name: 'Scandium-45', atomicWeight: 44.956, thermalCrossSection_barns: 27.5, productSymbol: 'Sc-46', abundance: 100 },
            { targetSymbol: 'Cu-63', name: 'Copper-63', atomicWeight: 62.929, thermalCrossSection_barns: 4.5, productSymbol: 'Cu-64', abundance: 69.15 },
            { targetSymbol: 'Ag-109', name: 'Silver-109', atomicWeight: 108.905, thermalCrossSection_barns: 89, productSymbol: 'Ag-110m', abundance: 48.16 },
            { targetSymbol: 'Sb-123', name: 'Antimony-123', atomicWeight: 122.904, thermalCrossSection_barns: 4.1, productSymbol: 'Sb-124', abundance: 42.79 },
            { targetSymbol: 'Eu-151', name: 'Europium-151', atomicWeight: 150.920, thermalCrossSection_barns: 9200, productSymbol: 'Eu-152', abundance: 47.8 },
            { targetSymbol: 'Ca-44', name: 'Calcium-44', atomicWeight: 43.955, thermalCrossSection_barns: 1.0, productSymbol: 'Ca-45', abundance: 2.086 },
            ].sort((a,b) => a.name.localeCompare(b.name));
            
            // --- Updated Data: Expanded Material & Shielding Data ---
            
            // 1. Expanded Composite Materials
            const COMPOSITE_MATERIALS_DATA = {
            'Ordinary Concrete': {
            density_g_cm3: 2.3,
            composition: [
            { element: 'Sodium-23', targetSymbol: 'Na-23', massFraction: 0.01 },
            { element: 'Iron-58', targetSymbol: 'Fe-58', massFraction: 0.015 * 0.0028 },
            { element: 'Cobalt-59', targetSymbol: 'Co-59', massFraction: 0.00001 },
            { element: 'Europium-151', targetSymbol: 'Eu-151', massFraction: 0.000001 },
            { element: 'Calcium-44', targetSymbol: 'Ca-44', massFraction: 0.08 * 0.02086 }
            ]
            },
            'Standard Human Tissue': {
            density_g_cm3: 1.0,
            composition: [ { element: 'Sodium-23', targetSymbol: 'Na-23', massFraction: 0.0015 } ]
            },
            'Stainless Steel 304': {
            density_g_cm3: 8.0,
            composition: [
            { element: 'Iron-58', targetSymbol: 'Fe-58', massFraction: 0.70 * 0.0028 },
            { element: 'Cobalt-59', targetSymbol: 'Co-59', massFraction: 0.001 },
            { element: 'Chromium-50', targetSymbol: 'Cr-50', massFraction: 0.19 * 0.0435 }
            ]
            },
            'Aluminum 6061': {
            density_g_cm3: 2.7,
            composition: [
            { element: 'Aluminum-27', targetSymbol: 'Al-27', massFraction: 0.97 }, // Activates to Al-28 (short) -> Na-24 (via n,alpha)
            { element: 'Magnesium-26', targetSymbol: 'Mg-26', massFraction: 0.01 * 0.11 }, // Activates to Mg-27
            { element: 'Copper-63', targetSymbol: 'Cu-63', massFraction: 0.003 * 0.69 }
            ]
            },
            'Standard Soil': {
            density_g_cm3: 1.6,
            composition: [
            { element: 'Sodium-23', targetSymbol: 'Na-23', massFraction: 0.006 }, // Na-24
            { element: 'Manganese-55', targetSymbol: 'Mn-55', massFraction: 0.0008 }, // Mn-56
            { element: 'Aluminum-27', targetSymbol: 'Al-27', massFraction: 0.07 } // Al-28
            ]
            }
            };
            
            // 2. Expanded Neutron Shielding Data (Split Fission vs 14 MeV)
            // Values approximated from NCRP 38 / 79 & IAEA
            const NEUTRON_SHIELDING_DATA = {
            'Water': { thermal: 2.8, fission: 6.1, fusion14: 12.0 },
            'Polyethylene': { thermal: 3.5, fission: 5.3, fusion14: 10.5 },
            'Concrete': { thermal: 4.8, fission: 10.7, fusion14: 18.0 },
            'Borated Poly (5%)': { thermal: 0.8, fission: 5.1, fusion14: 10.2 }, // High thermal capture
            'Steel': { thermal: 99, fission: 7.9, fusion14: 13.0 }, // Thermal Hvl is large (poor absorber)
            'Lead': { thermal: 99, fission: 15.0, fusion14: 14.0 }, // Poor neutron shield
            'Cadmium': { thermal: 0.02, fission: 99, fusion14: 99 } // Excellent thermal, useless fast
            };
            
            
            const FluenceDoseConverter = ({ calcMode, setCalcMode, energy, setEnergy, inputValue, setInputValue, inputUnit, setInputUnit, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const { settings } = React.useContext(SettingsContext);
            
            // Dynamic Units
            const doseUnits = React.useMemo(() => settings.unitSystem === 'si' ? ['µSv', 'mSv', 'Sv'] : ['µrem', 'mrem', 'rem'], [settings.unitSystem]);
            
            // Auto-switch default input unit
            React.useEffect(() => {
            if (calcMode === 'doseToFluence') {
            if (!doseUnits.includes(inputUnit)) setInputUnit(doseUnits[1]);
            } else {
            setInputUnit('n/cm²');
            }
            }, [calcMode, settings.unitSystem]);
            
            const logLogInterpolate = (targetX, x1, y1, x2, y2) => y1 * Math.pow(targetX / x1, Math.log(y2 / y1) / Math.log(x2 / x1));
            const doseFactorsRem = { 'µrem': 1e-6, 'mrem': 1e-3, 'rem': 1, 'µSv': 1e-4, 'mSv': 0.1, 'Sv': 100 };
            
            React.useEffect(() => {
            try {
            setError('');
            const val = parseFloat(inputValue);
            const energyVal = parseFloat(energy);
            
            if (isNaN(val) || isNaN(energyVal) || val < 0 || energyVal <= 0) {
              if(inputValue) setError('Inputs must be positive numbers.');
              setResult(null); return;
            }
            
            // Interpolate Fluence-to-Rem factor
            let p1 = NEUTRON_CONVERSION_FACTORS[0], p2 = NEUTRON_CONVERSION_FACTORS[NEUTRON_CONVERSION_FACTORS.length - 1];
            if (energyVal < p1.energyMeV) { p2 = p1; }
            else if (energyVal > p2.energyMeV) { p1 = p2; }
            else {
              for (let i = 0; i < NEUTRON_CONVERSION_FACTORS.length - 1; i++) {
                  if (energyVal >= NEUTRON_CONVERSION_FACTORS[i].energyMeV && energyVal <= NEUTRON_CONVERSION_FACTORS[i + 1].energyMeV) {
                      p1 = NEUTRON_CONVERSION_FACTORS[i];
                      p2 = NEUTRON_CONVERSION_FACTORS[i + 1];
                      break;
                  }
              }
            }
            
            const fluencePerRem = (p1.energyMeV === p2.energyMeV) ? p1.fluencePerRem : logLogInterpolate(energyVal, p1.energyMeV, p1.fluencePerRem, p2.energyMeV, p2.fluencePerRem);
            
            if (calcMode === 'fluenceToDose') {
              const dose_rem = val / fluencePerRem;
              const formatted = formatDoseValue(dose_rem * 1000, 'dose', settings);
              setResult({
                  val: formatted.value,
                  unit: formatted.unit,
                  label: 'Equivalent Dose',
                  factor: fluencePerRem.toExponential(2)
              });
            } else {
              const dose_rem = val * doseFactorsRem[inputUnit];
              const fluence = dose_rem * fluencePerRem;
              setResult({
                  val: fluence.toExponential(3),
                  unit: 'n/cm²',
                  label: 'Required Fluence',
                  factor: fluencePerRem.toExponential(2)
              });
            }
            } catch (e) { setError('Calculation error.'); setResult(null); }
            }, [calcMode, energy, inputValue, inputUnit, settings.unitSystem]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Neutron Conversion', icon: ICONS.neutron, inputs: `${inputValue} ${inputUnit} (${energy} MeV)`, result: `${result.val} ${result.unit}`, view: VIEWS.NEUTRON });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="grid grid-cols-2 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg">
             <button onClick={() => setCalcMode('fluenceToDose')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${calcMode === 'fluenceToDose' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Fluence → Dose</button>
             <button onClick={() => setCalcMode('doseToFluence')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${calcMode === 'doseToFluence' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Dose → Fluence</button>
            </div>
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
             <div><label className="block text-sm font-medium">Neutron Energy</label><select value={energy} onChange={e => setEnergy(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{NEUTRON_CONVERSION_FACTORS.map(f => <option key={f.energyMeV} value={f.energyMeV}>{f.label}</option>)}</select></div>
             <div>
                 <label className="block text-sm font-medium">{calcMode === 'fluenceToDose' ? 'Neutron Fluence' : 'Dose'}</label>
                 <div className="flex">
                     <input type="number" value={inputValue} onChange={e => setInputValue(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700" />
                     {calcMode === 'doseToFluence' ? (
                         <select value={inputUnit} onChange={e => setInputUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{doseUnits.map(u => <option key={u} value={u}>{u}</option>)}</select>
                     ) : (
                         <div className="mt-1 px-3 flex items-center bg-slate-200 dark:bg-slate-600 rounded-r-md text-sm text-slate-500 dark:text-slate-300">n/cm²</div>
                     )}
                 </div>
             </div>
            </div>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (
             <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm relative overflow-hidden">
                 <div className="flex justify-end -mt-3 -mr-3 mb-2"><Tooltip text="Save to history"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-600 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip></div>
            
                 <p className="text-xs uppercase font-bold text-slate-500 dark:text-slate-400 mb-2">{result.label}</p>
                 <div className="flex items-center justify-center gap-2 mb-2">
                     <span className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.val}</span>
                     <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{result.unit}</span>
                     <CopyButton textToCopy={result.val} />
                 </div>
                 <p className="text-xs text-slate-500 dark:text-slate-400">Factor: {result.factor} n/cm² per rem</p>
             </div>
            )}
            </div>
            );
            };
            
            const ActivationCalculator = ({ radionuclides, inputMode, setInputMode, targetMass, setTargetMass, massUnit, setMassUnit, abundance, setAbundance, neutronFlux, setNeutronFlux, irradiationTime, setIrradiationTime, timeUnit, setTimeUnit, result, setResult, error, setError, targetSymbol, setTargetSymbol, manualAW, setManualAW, manualCS, setManualCS, manualHL, setManualHL, manualHLUnit, setManualHLUnit, manualProductName, setManualProductName }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const { settings } = React.useContext(SettingsContext);
            
            const massUnits = { 'µg': 1e-6, 'mg': 1e-3, 'g': 1, 'kg': 1000 };
            const timeUnits = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400 };
            
            // Auto-set abundance
            React.useEffect(() => {
            if (inputMode === 'fromDB') {
            const data = NEUTRON_ACTIVATION_DATA.find(t => t.targetSymbol === targetSymbol);
            if (data) setAbundance(data.abundance.toString());
            }
            }, [targetSymbol, inputMode]);
            
            React.useEffect(() => {
            try {
            setError('');
            let atomicWeight, crossSection, halfLife_s, productName;
            
            if (inputMode === 'fromDB') {
             const targetData = NEUTRON_ACTIVATION_DATA.find(t => t.targetSymbol === targetSymbol);
             if (!targetData) throw new Error('Target material data not found.');
             const productData = radionuclides.find(r => r.symbol === targetData.productSymbol);
             if (!productData) throw new Error(`Product ${targetData.productSymbol} data missing.`);
            
             atomicWeight = targetData.atomicWeight;
             crossSection = targetData.thermalCrossSection_barns;
             halfLife_s = parseHalfLifeToSeconds(productData.halfLife);
             productName = `${productData.name} (${productData.symbol})`;
            } else {
             atomicWeight = parseFloat(manualAW);
             crossSection = parseFloat(manualCS);
             const hl_val = parseFloat(manualHL);
             halfLife_s = hl_val * (parseHalfLifeToSeconds(`1 ${manualHLUnit}`));
             productName = manualProductName || 'Product';
             if ([atomicWeight, crossSection, hl_val].some(isNaN)) { if(manualAW) setError('Invalid manual inputs.'); setResult(null); return; }
            }
            
            const mass_g = parseFloat(targetMass) * massUnits[massUnit];
            const flux = parseFloat(neutronFlux);
            const t_s = parseFloat(irradiationTime) * timeUnits[timeUnit];
            const abund = parseFloat(abundance) / 100.0;
            
            if ([mass_g, flux, t_s, abund].some(isNaN) || mass_g <= 0 || flux < 0 || t_s < 0 || abund <= 0) {
             if (targetMass && neutronFlux) setError('Inputs must be valid positive numbers.');
             setResult(null); return;
            }
            
            const AVOGADRO = 6.02214076e23;
            const num_target_atoms = (mass_g * abund * AVOGADRO) / atomicWeight;
            const lambda = Math.log(2) / halfLife_s;
            const sigma_cm2 = crossSection * 1e-24;
            
            // A = N * sigma * phi * (1 - e^-lambda*t)
            const sat_activity = num_target_atoms * sigma_cm2 * flux;
            const saturation_fraction = 1 - Math.exp(-lambda * t_s);
            const activity_Bq = sat_activity * saturation_fraction;
            
            const configKey = settings.unitSystem === 'si' ? 'activity_si' : 'activity_conventional';
            const baseAct = settings.unitSystem === 'si' ? activity_Bq : activity_Bq / 3.7e10;
            const formatted = formatSensibleUnit(baseAct, configKey);
            
            setResult({
             productName,
             displayVal: formatted.value,
             unit: formatted.unit,
             saturationPct: (saturation_fraction * 100)
            });
            
            } catch (e) { setError(e.message); setResult(null); }
            }, [inputMode, targetSymbol, targetMass, massUnit, abundance, neutronFlux, irradiationTime, timeUnit, manualAW, manualCS, manualHL, manualHLUnit, manualProductName, settings.unitSystem]);
            
            const handleSaveToHistory = () => {
            if (result) {
            let inputs = '';
            
            if (inputMode === 'fromDB') {
            inputs = `${targetMass} ${massUnit} ${targetSymbol} @ ${neutronFlux} n/cm²s`;
            } else {
            // Fix: Include mass and flux even for manual targets
            inputs = `${targetMass} ${massUnit} Manual Target @ ${neutronFlux} n/cm²s`;
            }
            
            addHistory({ 
            id: Date.now(), 
            type: 'Activation', 
            icon: ICONS.neutron, 
            inputs: inputs, 
            result: `${result.displayVal} ${result.unit} ${result.productName}`, 
            view: VIEWS.NEUTRON 
            });
            addToast("Calculation saved!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="flex justify-center mb-2">
             <div className="flex bg-slate-100 dark:bg-slate-900 rounded-lg p-1">
                 <button onClick={() => setInputMode('fromDB')} className={`px-4 py-1 text-xs font-bold rounded transition-colors ${inputMode === 'fromDB' ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Database</button>
                 <button onClick={() => setInputMode('manual')} className={`px-4 py-1 text-xs font-bold rounded transition-colors ${inputMode === 'manual' ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Manual</button>
             </div>
            </div>
            
            {inputMode === 'fromDB' ? (
             <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg animate-fade-in">
                 <label className="block text-sm font-medium">Target Isotope</label>
                 <select value={targetSymbol} onChange={e => setTargetSymbol(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{NEUTRON_ACTIVATION_DATA.map(t => <option key={t.targetSymbol} value={t.targetSymbol}>{t.name} ({t.abundance}% nat.)</option>)}</select>
             </div>
            ) : (
             <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4 animate-fade-in">
                 <div className="grid grid-cols-2 gap-4">
                     <div><label className="block text-sm font-medium">Atomic Weight</label><input type="number" value={manualAW} onChange={e => setManualAW(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                     <div><label className="block text-sm font-medium">Cross-Section (b)</label><input type="number" value={manualCS} onChange={e => setManualCS(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                 </div>
                 <div><label className="block text-sm font-medium">Product Half-Life</label><div className="flex"><input type="number" value={manualHL} onChange={e => setManualHL(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/><select value={manualHLUnit} onChange={e => setManualHLUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{longTimeUnits_ordered.map(u => <option key={u} value={u}>{u}</option>)}</select></div></div>
             </div>
            )}
            
            <div className="space-y-4">
             <div className="grid grid-cols-2 gap-4">
                 <div>
                     <label className="block text-sm font-medium">Total Mass</label>
                     <div className="flex">
                         <input type="number" value={targetMass} onChange={e => setTargetMass(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                         <select value={massUnit} onChange={e => setMassUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(massUnits).map(u => <option key={u} value={u}>{u}</option>)}</select>
                     </div>
                 </div>
                 <div>
                     <Tooltip text="Percentage of the total mass that is the target isotope. Defaults to natural abundance.">
                         <label className="block text-sm font-medium cursor-help underline decoration-dotted">Abundance (%)</label>
                     </Tooltip>
                     <input type="number" value={abundance} onChange={e => setAbundance(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/>
                 </div>
             </div>
             <div><label className="block text-sm font-medium">Thermal Flux (n/cm²·s)</label><input type="text" value={neutronFlux} onChange={e => setNeutronFlux(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
             <div>
                 <label className="block text-sm font-medium">Irradiation Time</label>
                 <div className="flex">
                     <input type="number" value={irradiationTime} onChange={e => setIrradiationTime(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                     <select value={timeUnit} onChange={e => setTimeUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(timeUnits).map(u => <option key={u} value={u}>{u}</option>)}</select>
                 </div>
             </div>
            </div>
            
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            
            {result && (
             <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm relative overflow-hidden">
                 <div className="flex justify-end -mt-3 -mr-3 mb-2"><Tooltip text="Save to Recent Calculations" widthClass="w-auto"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip></div>
            
                 <p className="text-xs uppercase font-bold text-slate-500 mb-2">Produced Activity</p>
                 <div className="flex items-center justify-center gap-2 mb-2">
                     <span className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.displayVal}</span>
                     <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{result.unit}</span>
                     <CopyButton textToCopy={result.displayVal} />
                 </div>
                 <p className="text-sm font-medium text-slate-600 dark:text-slate-300 mb-4">of {result.productName}</p>
            
                 {/* Saturation Bar */}
                 <div className="relative pt-1">
                    <div className="flex mb-1 items-center justify-between">
                      <span className="text-xs font-semibold inline-block text-sky-600 dark:text-sky-400">Saturation</span>
                      <span className="text-xs font-semibold inline-block text-sky-600 dark:text-sky-400">{result.saturationPct.toFixed(1)}%</span>
                    </div>
                    <div className="overflow-hidden h-2 mb-4 text-xs flex rounded bg-sky-200 dark:bg-slate-600">
                      <div style={{ width: `${result.saturationPct}%` }} className="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-sky-500"></div>
                    </div>
                 </div>
             </div>
            )}
            </div>
            );
            };
            
            const CompositeActivationCalculator = ({ radionuclides, material, setMaterial, totalMass, setTotalMass, massUnit, setMassUnit, neutronFlux, setNeutronFlux, irradiationTime, setIrradiationTime, timeUnit, setTimeUnit, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const massUnits = { 'µg': 1e-6, 'mg': 1e-3, 'g': 1, 'kg': 1000 };
            const timeUnits = { 'seconds': 1, 'minutes': 60, 'hours': 3600, 'days': 86400 };
            
            React.useEffect(() => {
            try {
            setError('');
            const materialData = COMPOSITE_MATERIALS_DATA[material];
            if (!materialData) throw new Error("Selected material data not found.");
            const total_mass_g = parseFloat(totalMass) * massUnits[massUnit];
            const flux_n_cm2_s = parseFloat(neutronFlux);
            const time_s = parseFloat(irradiationTime) * timeUnits[timeUnit];
            if (isNaN(total_mass_g) || isNaN(flux_n_cm2_s) || isNaN(time_s)) { if(totalMass && neutronFlux && irradiationTime) setError("Inputs must be valid numbers."); setResult(null); return; }
            
            const activationProducts = [];
            for (const component of materialData.composition) {
            const targetData = NEUTRON_ACTIVATION_DATA.find(t => t.targetSymbol === component.targetSymbol);
            if (!targetData) continue;
            const productData = radionuclides.find(r => r.symbol === targetData.productSymbol);
            if (!productData || productData.halfLife === 'Stable') continue;
            
            const component_mass_g = total_mass_g * component.massFraction;
            const AVOGADRO = 6.02214076e23; const BARN_TO_CM2 = 1e-24;
            const num_target_atoms = (component_mass_g / targetData.atomicWeight) * AVOGADRO;
            const product_half_life_s = parseHalfLifeToSeconds(productData.halfLife);
            const product_lambda = Math.log(2) / product_half_life_s;
            const cross_section_cm2 = targetData.thermalCrossSection_barns * BARN_TO_CM2;
            const saturation_factor = 1 - Math.exp(-product_lambda * time_s);
            const activity_Bq = num_target_atoms * cross_section_cm2 * flux_n_cm2_s * saturation_factor;
            
            if (activity_Bq > 1e-3) { activationProducts.push({ product: productData, targetElement: component.element, activity_Bq: activity_Bq, activity_Ci: activity_Bq / 3.7e10 }); }
            }
            activationProducts.sort((a, b) => b.activity_Bq - a.activity_Bq);
            setResult(activationProducts);
            } catch (e) { setError(e.message); setResult(null); }
            }, [material, totalMass, massUnit, neutronFlux, irradiationTime, timeUnit, radionuclides, setResult, setError]);
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Composite Activation', icon: ICONS.neutron, inputs: `${totalMass} ${massUnit} of ${material}`, result: `${result.length} products found`, view: VIEWS.NEUTRON });
            addToast("Calculation saved to history!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
            <div><label className="block text-sm font-medium">Composite Material</label><select value={material} onChange={e => setMaterial(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{Object.keys(COMPOSITE_MATERIALS_DATA).map(m => <option key={m} value={m}>{m}</option>)}</select></div>
            <div>
             <label className="block text-sm font-medium">Total Mass</label>
             <div className="flex">
                 <input type="number" value={totalMass} onChange={e => setTotalMass(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                 <select value={massUnit} onChange={e => setMassUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(massUnits).map(u => <option key={u} value={u}>{u}</option>)}</select>
             </div>
            </div>
            <div><label className="block text-sm font-medium">Thermal Neutron Flux (n/cm²·s)</label><input type="text" value={neutronFlux} onChange={e => setNeutronFlux(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            <div>
             <label className="block text-sm font-medium">Irradiation Time</label>
             <div className="flex">
                 <input type="number" value={irradiationTime} onChange={e => setIrradiationTime(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                 <select value={timeUnit} onChange={e => setTimeUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(timeUnits).map(u => <option key={u} value={u}>{u}</option>)}</select>
             </div>
            </div>
            </div>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            {result && (<div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg animate-fade-in">
            <div className="flex justify-between items-center -mt-2">
              <h3 className="text-lg font-bold text-slate-700 dark:text-slate-200 mb-2">Principal Activation Products</h3>
              <Tooltip text="Save to Recent Calculations" widthClass="w-auto">
                 <button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors">
                     <Icon path={ICONS.notepad} className="w-5 h-5" />
                 </button>
              </Tooltip>
            </div>
            <div className="space-y-2">{result.length > 0 ? result.map(p => (<div key={p.product.symbol} className="grid grid-cols-3 items-center text-sm border-b border-slate-200 dark:border-slate-600 pb-1 last:border-0"><span className="font-semibold text-sky-600 dark:text-sky-400">{p.product.name}</span><span className="text-xs text-center text-slate-500 dark:text-slate-400">(from {p.targetElement})</span><span className="font-mono text-right">{p.activity_Ci.toExponential(2)} Ci</span></div>)) : <p className="text-center text-sm text-slate-500 dark:text-slate-400">No significant activation products found.</p>}</div>
            </div>)}
            </div>
            );
            };
            
            const NeutronShieldingCalculator = ({ selectedEnergy, setSelectedEnergy, initialFlux, setInitialFlux, shieldMaterial, setShieldMaterial, shieldThickness, setShieldThickness, thicknessUnit, setThicknessUnit, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            const thicknessFactors_cm = { 'mm': 0.1, 'cm': 1, 'in': 2.54, 'ft': 30.48 };
            
            // Source Spectrum state, defaults to fission
            const [spectrum, setSpectrum] = React.useState('fission'); // 'fission' or 'fusion14'
            
            // useEffect hook for intelligent spectrum switching
            // This automatically selects the most likely spectrum when the energy changes.
            React.useEffect(() => {
            const energyMeV = parseFloat(selectedEnergy);
            if (isNaN(energyMeV)) return;
            
            // Threshold for Fusion spectrum (typically D-T reactions are > 10 MeV)
            const fusionThreshold = 10; // in MeV
            
            if (energyMeV >= fusionThreshold) {
            setSpectrum('fusion14');
            } else {
            // Default to fission/AmBe for all other non-thermal energies
            setSpectrum('fission');
            }
            }, [selectedEnergy]); // Dependency: run this whenever the energy changes
            
            const getHvl = (mat) => {
            const data = NEUTRON_SHIELDING_DATA[mat];
            if (!data) return null;
            
            const energyMeV = parseFloat(selectedEnergy);
            // If energy is explicitly thermal, force thermal HVL, ignoring the toggle
            if (energyMeV < 1e-4) return data.thermal;
            
            // Otherwise, use the automatically-set (or manually overridden) spectrum toggle
            return spectrum === 'fission' ? data.fission : data.fusion14;
            };
            
            // Interpolation and Calculation logic remains the same...
            const logLogInterpolate = (targetX, x1, y1, x2, y2) => y1 * Math.pow(targetX / x1, Math.log(y2 / y1) / Math.log(x2 / x1));
            
            React.useEffect(() => {
            try {
            setError('');
            const flux_val = parseFloat(initialFlux); const thickness_val = parseFloat(shieldThickness); const energyVal = parseFloat(selectedEnergy);
            if (isNaN(flux_val) || isNaN(thickness_val) || isNaN(energyVal) || flux_val < 0 || thickness_val < 0 || energyVal <= 0) {
            if(initialFlux && shieldThickness && selectedEnergy) setError("Please enter valid positive numbers.");
            setResult(null); return;
            }
            
            const hvl_cm = getHvl(shieldMaterial);
            if (!hvl_cm || hvl_cm >= 99) { throw new Error("This material is ineffective as a shield for the selected neutron energy."); }
            
            let p1 = NEUTRON_CONVERSION_FACTORS[0], p2 = NEUTRON_CONVERSION_FACTORS[NEUTRON_CONVERSION_FACTORS.length - 1];
            if (energyVal < p1.energyMeV) { p2 = p1; }
            else if (energyVal > p2.energyMeV) { p1 = p2; }
            else {
            for (let i = 0; i < NEUTRON_CONVERSION_FACTORS.length - 1; i++) {
             if (energyVal >= NEUTRON_CONVERSION_FACTORS[i].energyMeV && energyVal <= NEUTRON_CONVERSION_FACTORS[i + 1].energyMeV) {
                 p1 = NEUTRON_CONVERSION_FACTORS[i]; p2 = NEUTRON_CONVERSION_FACTORS[i + 1]; break;
             }
            }
            }
            const fluencePerRem = (p1.energyMeV === p2.energyMeV) ? p1.fluencePerRem : logLogInterpolate(energyVal, p1.energyMeV, p1.fluencePerRem, p2.energyMeV, p2.fluencePerRem);
            const FLUX_TO_DOSE_RATE_FACTOR = (1 / fluencePerRem) * 1000 * 3600;
            
            const thickness_cm = thickness_val * thicknessFactors_cm[thicknessUnit];
            const final_flux = flux_val * Math.pow(0.5, thickness_cm / hvl_cm);
            const initial_dose_rate_mrem_hr = flux_val * FLUX_TO_DOSE_RATE_FACTOR;
            const final_dose_rate_mrem_hr = final_flux * FLUX_TO_DOSE_RATE_FACTOR;
            
            setResult({
            initialFlux: flux_val.toExponential(3),
            finalFlux: final_flux.toExponential(3),
            initialDose: formatSensibleUnit(initial_dose_rate_mrem_hr, 'doseRate'),
            finalDose: formatSensibleUnit(final_dose_rate_mrem_hr, 'doseRate'),
            hvlUsed: hvl_cm
            });
            } catch(e) { setError(e.message); setResult(null); }
            }, [initialFlux, shieldMaterial, shieldThickness, thicknessUnit, selectedEnergy, spectrum, setResult, setError]);
            
            // Save handler 
            const handleSaveToHistory = () => {
            if (result) {
            const inputs = `${initialFlux} n/cm²s (${selectedEnergy} MeV) + ${shieldThickness} ${thicknessUnit} ${shieldMaterial}`;
            addHistory({ 
              id: Date.now(), 
              type: 'Neutron Shielding', 
              icon: ICONS.shield, 
              inputs: inputs, 
              result: `Final: ${result.finalDose.value} ${result.finalDose.unit}`, 
              view: VIEWS.NEUTRON 
            });
            addToast("Calculation saved to history!");
            }
            };
            
            // Component JSX with updated UI
            return (
            <div className="space-y-4">
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
            <div>
            <label className="block text-sm font-medium">Neutron Energy</label>
            <select value={selectedEnergy} onChange={e => setSelectedEnergy(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{NEUTRON_CONVERSION_FACTORS.map(f => <option key={f.energyMeV} value={f.energyMeV}>{f.label}</option>)}</select>
            </div>
            
            {/* A toggle for the spectrum, disabled for thermal neutrons */}
            {parseFloat(selectedEnergy) >= 1e-4 && (
            <div>
                <label className="block text-sm font-medium mb-1">Assumed Source Spectrum</label>
                <div className="flex bg-slate-100 dark:bg-slate-900 rounded-lg p-1">
                    <button onClick={() => setSpectrum('fission')} className={`flex-1 py-1 text-xs font-bold rounded transition-colors ${spectrum === 'fission' ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>Fission / AmBe (~2 MeV)</button>
                    <button onClick={() => setSpectrum('fusion14')} className={`flex-1 py-1 text-xs font-bold rounded transition-colors ${spectrum === 'fusion14' ? 'bg-white dark:bg-slate-700 text-sky-600 shadow-sm' : 'text-slate-500'}`}>D-T Fusion (~14 MeV)</button>
                </div>
            </div>
            )}
            
            <div><label className="block text-sm font-medium">Initial Neutron Flux (n/cm²·s)</label><input type="text" value={initialFlux} onChange={e => setInitialFlux(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            <div><label className="block text-sm font-medium">Shield Material</label><select value={shieldMaterial} onChange={e => setShieldMaterial(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{Object.keys(NEUTRON_SHIELDING_DATA).map(m => <option key={m} value={m}>{m}</option>)}</select></div>
            <div>
             <label className="block text-sm font-medium">Shield Thickness</label>
             <div className="flex">
                 <input type="number" value={shieldThickness} onChange={e => setShieldThickness(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                 <select value={thicknessUnit} onChange={e => setThicknessUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600">{Object.keys(thicknessFactors_cm).map(u => <option key={u} value={u}>{u}</option>)}</select>
             </div>
            </div>
            </div>
            {error && <p className="text-red-500 text-sm text-center bg-red-50 dark:bg-red-900/20 p-2 rounded">{error}</p>}
            {result && (
            <div className="mt-6 p-6 bg-slate-100 dark:bg-slate-700 rounded-lg text-center animate-fade-in shadow-sm relative overflow-hidden">
             <div className="flex justify-end -mt-3 -mr-3 mb-2"><Tooltip text="Save to Recent Calculations" widthClass="w-auto"><button onClick={handleSaveToHistory} className="p-2 text-slate-400 hover:text-sky-500 transition-colors"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></Tooltip></div>
             <p className="text-xs uppercase font-bold text-slate-500 mb-2">Shielded Dose Rate</p>
             <div className="flex items-center justify-center gap-2 mb-2">
                 <span className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.finalDose.value}</span>
                 <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{result.finalDose.unit}</span>
                 <CopyButton textToCopy={result.finalDose.value} />
             </div>
             <div className="grid grid-cols-2 gap-2 text-xs text-slate-600 dark:text-slate-300 border-t border-slate-200 dark:border-slate-600 pt-3">
                 <p>Unshielded: <strong>{result.initialDose.value} {result.initialDose.unit}</strong></p>
                 <p>HVL Used: <strong>{result.hvlUsed} cm</strong></p>
             </div>
            </div>
            )}
            </div>
            );
            };
            
            const NeutronCalculator = ({radionuclides}) => {
            const [activeTab, setActiveTab] = React.useState('fluenceDose');
            const { settings } = React.useContext(SettingsContext);
            
            // State for FluenceDoseConverter
            const [fluence_calcMode, setFluence_calcMode] = React.useState('fluenceToDose');
            const [fluence_energy, setFluence_energy] = React.useState('1');
            const [fluence_inputValue, setFluence_inputValue] = React.useState('1e6');
            const [fluence_inputUnit, setFluence_inputUnit] = React.useState('n/cm²');
            const [fluence_result, setFluence_result] = React.useState(null);
            const [fluence_error, setFluence_error] = React.useState('');
            
            // State for ActivationCalculator
            const [act_inputMode, setAct_inputMode] = React.useState('fromDB');
            const [act_targetMass, setAct_targetMass] = React.useState('1');
            const [act_massUnit, setAct_massUnit] = React.useState('g');
            const [act_abundance, setAct_abundance] = React.useState('100');
            const [act_neutronFlux, setAct_neutronFlux] = React.useState('1e12');
            const [act_irradiationTime, setAct_irradiationTime] = React.useState('1');
            const [act_timeUnit, setAct_timeUnit] = React.useState('hours');
            const [act_result, setAct_result] = React.useState(null);
            const [act_error, setAct_error] = React.useState('');
            const [act_targetSymbol, setAct_targetSymbol] = React.useState('Co-59');
            const [act_manualAW, setAct_manualAW] = React.useState('58.933');
            const [act_manualCS, setAct_manualCS] = React.useState('37.2');
            const [act_manualHL, setAct_manualHL] = React.useState('5.27');
            const [act_manualHLUnit, setAct_manualHLUnit] = React.useState('years');
            const [act_manualProductName, setAct_manualProductName] = React.useState('Co-60');
            
            // State for CompositeActivationCalculator
            const [comp_material, setComp_material] = React.useState('Ordinary Concrete');
            const [comp_totalMass, setComp_totalMass] = React.useState('100');
            const [comp_massUnit, setComp_massUnit] = React.useState('kg');
            const [comp_neutronFlux, setComp_neutronFlux] = React.useState('1e12');
            const [comp_irradiationTime, setComp_irradiationTime] = React.useState('8');
            const [comp_timeUnit, setComp_timeUnit] = React.useState('hours');
            const [comp_result, setComp_result] = React.useState(null);
            const [comp_error, setComp_error] = React.useState('');
            
            // State for NeutronShieldingCalculator
            const [shield_selectedEnergy, setShield_selectedEnergy] = React.useState('2.5');
            const [shield_initialFlux, setShield_initialFlux] = React.useState('1e6');
            const [shield_shieldMaterial, setShield_shieldMaterial] = React.useState('Polyethylene');
            const [shield_shieldThickness, setShield_shieldThickness] = React.useState('10');
            const [shield_thicknessUnit, setShield_thicknessUnit] = React.useState('cm');
            const [shield_result, setShield_result] = React.useState(null);
            const [shield_error, setShield_error] = React.useState('');
            
            const handleFluenceClear = () => {
            setFluence_calcMode('fluenceToDose'); setFluence_energy('1'); setFluence_inputValue('1e6');
            setFluence_result(null); setFluence_error('');
            };
            const handleActivationClear = () => {
            setAct_inputMode('fromDB'); setAct_targetMass('1'); setAct_massUnit('g'); setAct_neutronFlux('1e12');
            setAct_irradiationTime('1'); setAct_timeUnit('hours'); setAct_targetSymbol('Co-59');
            setAct_abundance('100');
            setAct_manualAW('58.933'); setAct_manualCS('37.2'); setAct_manualHL('5.27'); setAct_manualHLUnit('years');
            setAct_manualProductName('Co-60'); setAct_result(null); setAct_error('');
            };
            const handleCompositeClear = () => {
            setComp_material('Ordinary Concrete'); setComp_totalMass('100'); setComp_massUnit('kg');
            setComp_neutronFlux('1e12'); setComp_irradiationTime('8'); setComp_timeUnit('hours');
            setComp_result(null); setComp_error('');
            };
            const handleShieldingClear = () => {
            setShield_selectedEnergy('2.5'); setShield_initialFlux('1e6'); setShield_shieldMaterial('Polyethylene');
            setShield_shieldThickness('10'); setShield_thicknessUnit('cm'); setShield_result(null); setShield_error('');
            };
            
            const handleClearActiveCalculator = () => {
            switch (activeTab) {
            case 'fluenceDose': handleFluenceClear(); break;
            case 'activation': handleActivationClear(); break;
            case 'composite': handleCompositeClear(); break;
            case 'shielding': handleShieldingClear(); break;
            default: break;
            }
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-md mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
              <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-bold text-slate-800 dark:text-white">Neutron Tools</h2>
                  <ClearButton onClick={handleClearActiveCalculator} />
              </div>
              <div className="grid grid-cols-2 lg:grid-cols-4 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-4">
                  <button onClick={() => setActiveTab('fluenceDose')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'fluenceDose' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Fluence</button>
                  <button onClick={() => setActiveTab('activation')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'activation' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Activation</button>
                  <button onClick={() => setActiveTab('composite')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'composite' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Composite</button>
                  <button onClick={() => setActiveTab('shielding')} className={`p-2 rounded-md text-sm font-semibold transition-colors ${activeTab === 'shielding' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Shielding</button>
              </div>
              {activeTab === 'fluenceDose' && <FluenceDoseConverter
                  calcMode={fluence_calcMode} setCalcMode={setFluence_calcMode}
                  energy={fluence_energy} setEnergy={setFluence_energy}
                  inputValue={fluence_inputValue} setInputValue={setFluence_inputValue}
                  inputUnit={fluence_inputUnit} setInputUnit={setFluence_inputUnit}
                  result={fluence_result} setResult={setFluence_result}
                  error={fluence_error} setError={setFluence_error}
              />}
              {activeTab === 'activation' && <ActivationCalculator
                  radionuclides={radionuclides}
                  inputMode={act_inputMode} setInputMode={setAct_inputMode}
                  targetMass={act_targetMass} setTargetMass={setAct_targetMass}
                  massUnit={act_massUnit} setMassUnit={setAct_massUnit}
                  abundance={act_abundance} setAbundance={setAct_abundance}
                  neutronFlux={act_neutronFlux} setNeutronFlux={setAct_neutronFlux}
                  irradiationTime={act_irradiationTime} setIrradiationTime={setAct_irradiationTime}
                  timeUnit={act_timeUnit} setTimeUnit={setAct_timeUnit}
                  result={act_result} setResult={setAct_result}
                  error={act_error} setError={setAct_error}
                  targetSymbol={act_targetSymbol} setTargetSymbol={setAct_targetSymbol}
                  manualAW={act_manualAW} setManualAW={setAct_manualAW}
                  manualCS={act_manualCS} setManualCS={setAct_manualCS}
                  manualHL={act_manualHL} setManualHL={setAct_manualHL}
                  manualHLUnit={act_manualHLUnit} setManualHLUnit={setAct_manualHLUnit}
                  manualProductName={act_manualProductName} setManualProductName={setAct_manualProductName}
              />}
              {activeTab === 'composite' && <CompositeActivationCalculator
                  radionuclides={radionuclides}
                  material={comp_material} setMaterial={setComp_material}
                  totalMass={comp_totalMass} setTotalMass={setComp_totalMass}
                  massUnit={comp_massUnit} setMassUnit={setComp_massUnit}
                  neutronFlux={comp_neutronFlux} setNeutronFlux={setComp_neutronFlux}
                  irradiationTime={comp_irradiationTime} setIrradiationTime={setComp_irradiationTime}
                  timeUnit={comp_timeUnit} setTimeUnit={setComp_timeUnit}
                  result={comp_result} setResult={setComp_result}
                  error={comp_error} setError={setComp_error}
              />}
              {activeTab === 'shielding' && <NeutronShieldingCalculator
                  selectedEnergy={shield_selectedEnergy} setSelectedEnergy={setShield_selectedEnergy}
                  initialFlux={shield_initialFlux} setInitialFlux={setShield_initialFlux}
                  shieldMaterial={shield_shieldMaterial} setShieldMaterial={setShield_shieldMaterial}
                  shieldThickness={shield_shieldThickness} setShieldThickness={setShield_shieldThickness}
                  thicknessUnit={shield_thicknessUnit} setThicknessUnit={setShield_thicknessUnit}
                  result={shield_result} setResult={setShield_result}
                  error={shield_error} setError={setShield_error}
              />}
            </div>
            </div>
            );
            };
            
            /**
            * @description A unified calculator for determining detection limits for both
            * MARSSIM-compliant static counts and scanning surveys. Now includes "Time to Target" reverse calc.
            */
            
            const MDACalculator = ({ onNavClick, onDeepLink }) => {
            const MDA_MODE_STATIC = 'static';
            const MDA_MODE_SCAN = 'scan';
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            // --- State Management ---
            const [mdaMode, setMdaMode] = React.useState(() => localStorage.getItem('mda_mdaMode') || MDA_MODE_STATIC);
            
            // Shared State
            const [backgroundMode, setBackgroundMode] = React.useState('rate'); // 'rate' or 'counts'
            const [backgroundCpm, setBackgroundCpm] = React.useState(() => localStorage.getItem('mda_backgroundCpm') || '50');
            const [bkgCounts, setBkgCounts] = React.useState('50');
            const [bkgTime, setBkgTime] = React.useState('1');
            
            const [instrumentEff, setInstrumentEff] = React.useState(() => localStorage.getItem('mda_instrumentEff') || '20');
            const [surfaceEff, setSurfaceEff] = React.useState(() => localStorage.getItem('mda_surfaceEff') || '50');
            const [probeArea, setProbeArea] = React.useState(() => localStorage.getItem('mda_probeArea') || '15');
            
            // Static State
            const [grossTime, setGrossTime] = React.useState(() => localStorage.getItem('mda_grossTime') || '1');
            const [outputUnit, setOutputUnit] = React.useState(() => localStorage.getItem('mda_outputUnit') || 'dpm/100cm²');
            const [sampleVolume, setSampleVolume] = React.useState(() => localStorage.getItem('mda_sampleVolume') || '1');
            const [sampleMass, setSampleMass] = React.useState(() => localStorage.getItem('mda_sampleMass') || '100');
            const [targetLimit, setTargetLimit] = React.useState(() => localStorage.getItem('mda_targetLimit') || '');
            
            // Scan State
            const [scanSpeed, setScanSpeed] = React.useState(() => localStorage.getItem('mda_scanSpeed') || '5');
            const [probeDimension, setProbeDimension] = React.useState(() => localStorage.getItem('mda_probeDimension') || '4.4');
            const [dprime, setDprime] = React.useState(() => localStorage.getItem('mda_dprime') || '1.38');
            const [surveyorEff, setSurveyorEff] = React.useState(() => localStorage.getItem('mda_surveyorEff') || '0.5');
            
            const [result, setResult] = React.useState(null);
            const [error, setError] = React.useState('');
            
            // --- Data and Constants ---
            const MDA_UNIT_CONFIG = { 'counts': { label: 'LLD (counts)', category: 'Counts', requires: [] }, 'cpm': { label: 'LLD Rate (cpm)', category: 'Rate', requires: [] }, 'dpm': { label: 'Activity (dpm)', category: 'Activity', requires: ['efficiency'] }, 'Bq': { label: 'Activity (Bq)', category: 'Activity', requires: ['efficiency'] }, 'µCi': { label: 'Activity (µCi)', category: 'Activity', requires: ['efficiency'] }, 'dpm/100cm²': { label: 'Surface (dpm/100cm²)', category: 'Concentration', requires: ['efficiency', 'area'] }, 'Bq/L': { label: 'Liquid (Bq/L)', category: 'Concentration', requires: ['efficiency', 'volume'] }, 'pCi/g': { label: 'Solid (pCi/g)', category: 'Concentration', requires: ['efficiency', 'mass'] } };
            const dpmFactors = { 'dpm': 1, 'Bq': 1 / 60, 'µCi': 1 / 2.22e6 };
            
            const PROBE_PRESETS = {
            'custom': { label: 'Custom / Manual', area: '', dim: '' },
            '44-9': { label: 'Pancake GM (Ludlum 44-9)', area: '15', dim: '4.4' },
            '43-5': { label: 'Alpha Scint. (Ludlum 43-5)', area: '50', dim: '7.6' },
            '43-37': { label: 'Floor Monitor (Gas Prop)', area: '584', dim: '13' },
            '43-68': { label: 'Handheld Gas Prop', area: '100', dim: '10' },
            '43-89': { label: 'Alpha/Beta Scint (Square)', area: '100', dim: '10' },
            '43-93': { label: 'Alpha/Beta Scint (Round)', area: '100', dim: '11' }
            };
            
            React.useEffect(() => {
            localStorage.setItem('mda_mdaMode', mdaMode);
            localStorage.setItem('mda_backgroundCpm', backgroundCpm);
            localStorage.setItem('mda_instrumentEff', instrumentEff);
            localStorage.setItem('mda_surfaceEff', surfaceEff);
            localStorage.setItem('mda_probeArea', probeArea);
            localStorage.setItem('mda_grossTime', grossTime);
            localStorage.setItem('mda_outputUnit', outputUnit);
            localStorage.setItem('mda_sampleVolume', sampleVolume);
            localStorage.setItem('mda_sampleMass', sampleMass);
            localStorage.setItem('mda_scanSpeed', scanSpeed);
            localStorage.setItem('mda_probeDimension', probeDimension);
            localStorage.setItem('mda_dprime', dprime);
            localStorage.setItem('mda_surveyorEff', surveyorEff);
            localStorage.setItem('mda_targetLimit', targetLimit);
            }, [mdaMode, backgroundCpm, instrumentEff, surfaceEff, probeArea, grossTime, outputUnit, sampleVolume, sampleMass, scanSpeed, probeDimension, dprime, surveyorEff, targetLimit]);
            
            React.useEffect(() => { setResult(null); setError(''); }, [mdaMode]);
            
            const handlePresetChange = (key) => {
            const p = PROBE_PRESETS[key];
            if (p && key !== 'custom') {
            setProbeArea(p.area);
            setProbeDimension(p.dim);
            addToast(`Loaded settings for ${p.label}`);
            }
            };
            
            const handleTabSwitch = (newMode) => {
            if (newMode === MDA_MODE_SCAN && backgroundMode === 'counts') {
            const cts = parseFloat(bkgCounts);
            const tm = parseFloat(bkgTime);
            if (!isNaN(cts) && !isNaN(tm) && tm > 0) {
                setBackgroundCpm((cts / tm).toString());
                setBackgroundMode('rate');
                addToast("Background rate synced from counts.");
            }
            }
            setMdaMode(newMode);
            };
            
            const getTotalEfficiency = (iEff, sEff) => (iEff / 100.0) * (sEff / 100.0);
            
            const handleStaticCalculate = React.useCallback(() => {
            let bkgRate = 0;
            let Tb = 0;
            
            if (backgroundMode === 'rate') {
            bkgRate = parseFloat(backgroundCpm);
            Tb = 0; 
            } else {
            const counts = parseFloat(bkgCounts);
            Tb = parseFloat(bkgTime);
            if (isNaN(counts) || isNaN(Tb) || Tb <= 0) throw new Error("Invalid background counts/time.");
            bkgRate = counts / Tb;
            }
            
            const Ts = parseFloat(grossTime);
            const ei = parseFloat(instrumentEff);
            const es = parseFloat(surfaceEff);
            const A = parseFloat(probeArea);
            const V = parseFloat(sampleVolume);
            const M = parseFloat(sampleMass);
            
            if (isNaN(bkgRate) || isNaN(Ts) || Ts <= 0) throw new Error('Please enter valid, positive numbers for background and time.');
            
            let Ld_counts;
            if (backgroundMode === 'counts' && Math.abs(Ts - Tb) > 0.01 * Ts) {
            Ld_counts = (2.71) + 3.29 * Math.sqrt(bkgRate * Ts * (1 + Ts/Tb));
            } else {
            Ld_counts = 2.71 + 4.65 * Math.sqrt(bkgRate * Ts);
            }
            
            if (isNaN(ei) || isNaN(es) || ei <= 0 || es <= 0) throw new Error('Valid efficiencies are required.');
            const E_total = getTotalEfficiency(ei, es);
            const mda_dpm = (Ld_counts / Ts) / E_total;
            
            let finalMDA;
            if (MDA_UNIT_CONFIG[outputUnit].category === 'Activity') {
            finalMDA = mda_dpm * dpmFactors[outputUnit];
            } else if (outputUnit === 'dpm/100cm²') {
            if (isNaN(A) || A <= 0) throw new Error('Probe Area is required.');
            finalMDA = mda_dpm * (100 / A);
            } else if (outputUnit === 'Bq/L') {
            if (isNaN(V) || V <= 0) throw new Error('Sample Volume is required.');
            finalMDA = (mda_dpm / 60) / V;
            } else if (outputUnit === 'pCi/g') {
            if (isNaN(M) || M <= 0) throw new Error('Sample Mass is required.');
            finalMDA = (mda_dpm / 2.22) / M;
            } else if (outputUnit === 'cpm') {
            finalMDA = Ld_counts / Ts;
            } else if (outputUnit === 'counts') {
            finalMDA = Ld_counts;
            }
            
            let timeToTarget = null;
            const target = parseFloat(targetLimit);
            if (outputUnit !== 'counts' && !isNaN(target) && target > 0 && finalMDA > target) {
            timeToTarget = Ts * Math.pow(finalMDA / target, 2);
            }
            
            setResult({ 
            type: 'static', 
            LLD: Ld_counts.toPrecision(3), 
            MDA: finalMDA.toPrecision(3), 
            unit: outputUnit,
            timeToTarget: timeToTarget ? timeToTarget.toFixed(1) : null
            });
            
            }, [backgroundMode, bkgCounts, bkgTime, backgroundCpm, grossTime, instrumentEff, surfaceEff, outputUnit, probeArea, sampleVolume, sampleMass, targetLimit]);
            
            const handleScanCalculate = React.useCallback(() => {
            const bkgRate = parseFloat(backgroundCpm);
            const dimension_cm = parseFloat(probeDimension);
            const eff_i = parseFloat(instrumentEff);
            const eff_s = parseFloat(surfaceEff);
            const speed_cms = parseFloat(scanSpeed);
            const dp = parseFloat(dprime);
            const p = parseFloat(surveyorEff);
            const total_area_cm2 = parseFloat(probeArea);
            
            if (isNaN(bkgRate) || isNaN(eff_i) || isNaN(eff_s) || isNaN(speed_cms) || isNaN(dimension_cm) || bkgRate < 0 || eff_i <= 0 || eff_s <= 0 || speed_cms <= 0 || dimension_cm <= 0) {
            throw new Error('Please enter valid, positive numbers.');
            }
            if (isNaN(total_area_cm2) || total_area_cm2 <= 0) throw new Error("Probe Area required.");
            
            const residence_time_s = dimension_cm / speed_cms;
            const b_cps = bkgRate / 60.0;
            const E_total = getTotalEfficiency(eff_i, eff_s);
            const B_i = b_cps * residence_time_s;
            const mdcr_instrument_cpm = dp * Math.sqrt(B_i) * (60 / residence_time_s);
            const mdcr_surveyor_cpm = mdcr_instrument_cpm / Math.sqrt(p);
            const scan_mda = mdcr_surveyor_cpm / (E_total * (total_area_cm2 / 100.0));
            
            setResult({
            type: 'scan',
            obs_interval: residence_time_s.toPrecision(2),
            scan_mda: scan_mda.toPrecision(3),
            scan_mdcr: mdcr_surveyor_cpm.toFixed(0),
            isAlphaWarn: bkgRate < 5
            });
            }, [backgroundCpm, probeDimension, instrumentEff, surfaceEff, scanSpeed, dprime, surveyorEff, probeArea]);
            
            const handleSaveToHistory = () => {
            if (!result) return;
            let inputs = mdaMode === MDA_MODE_STATIC ? `Time: ${grossTime} min` : `Speed: ${scanSpeed} cm/s`;
            let resString = mdaMode === MDA_MODE_STATIC ? `${result.MDA} ${result.unit}` : `${result.scan_mda} dpm/100cm²`;
            addHistory({ id: Date.now(), type: mdaMode === MDA_MODE_STATIC ? 'Static MDA' : 'Scan MDC', icon: ICONS.search, inputs: inputs, result: resString, view: VIEWS.MDA });
            addToast("Calculation saved to history!");
            };
            
            React.useEffect(() => {
            try {
            setError(''); setResult(null);
            if (mdaMode === MDA_MODE_STATIC) handleStaticCalculate();
            else handleScanCalculate();
            } catch (e) { setError(e.message); setResult(null); }
            }, [mdaMode, backgroundMode, backgroundCpm, bkgCounts, bkgTime, grossTime, outputUnit, sampleVolume, sampleMass, scanSpeed, dprime, surveyorEff, probeArea, instrumentEff, surfaceEff, probeDimension, targetLimit, handleStaticCalculate, handleScanCalculate]);
            
            const handleClearInputs = () => {
            setMdaMode(MDA_MODE_STATIC);
            setBackgroundCpm('50'); setBkgCounts('50'); setBkgTime('1');
            setInstrumentEff('20'); setSurfaceEff('50'); setProbeArea('15');
            setGrossTime('1'); setOutputUnit('dpm/100cm²'); setTargetLimit('');
            setScanSpeed('5'); setProbeDimension('4.4');
            setResult(null); setError('');
            const keys = ['mda_mdaMode', 'mda_backgroundCpm', 'mda_instrumentEff', 'mda_surfaceEff', 'mda_probeArea', 'mda_grossTime', 'mda_outputUnit', 'mda_targetLimit', 'mda_scanSpeed'];
            keys.forEach(k => localStorage.removeItem(k));
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-slate-800 dark:text-white">Detection Limit Calculator</h2>
                    <ClearButton onClick={handleClearInputs} />
                </div>
                <div className="flex w-full p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-4">
                    <button onClick={() => handleTabSwitch(MDA_MODE_STATIC)} className={`w-1/2 p-2 rounded-md text-sm font-semibold transition-colors ${mdaMode === MDA_MODE_STATIC ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Static Count MDA</button>
                    <button onClick={() => handleTabSwitch(MDA_MODE_SCAN)} className={`w-1/2 p-2 rounded-md text-sm font-semibold transition-colors ${mdaMode === MDA_MODE_SCAN ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Scan Survey MDC</button>
                </div>
            
                <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4 mb-4">
                    <div className="flex justify-between items-center -mb-2">
                        <h3 className="text-md font-semibold text-center">Shared Inputs</h3>
                        <div className="flex items-center gap-2">
                            <span className="text-xs text-slate-500">Preset:</span>
                            <select onChange={(e) => handlePresetChange(e.target.value)} className="text-xs p-1 rounded border border-slate-300 dark:bg-slate-700 dark:border-slate-600">
                                {Object.entries(PROBE_PRESETS).map(([k, v]) => <option key={k} value={k}>{v.label}</option>)}
                            </select>
                        </div>
                    </div>
            
                    {mdaMode === MDA_MODE_STATIC && (
                        <div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1 text-xs">
                            <button onClick={() => setBackgroundMode('rate')} className={`flex-1 py-1 rounded ${backgroundMode === 'rate' ? 'bg-white dark:bg-slate-600 shadow' : ''}`}>Enter Rate (CPM)</button>
                            <button onClick={() => setBackgroundMode('counts')} className={`flex-1 py-1 rounded ${backgroundMode === 'counts' ? 'bg-white dark:bg-slate-600 shadow' : ''}`}>Enter Counts</button>
                        </div>
                    )}
            
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {backgroundMode === 'rate' || mdaMode === MDA_MODE_SCAN ? (
                            <div><label className="block text-sm font-medium">Background Rate (cpm)</label><input type="number" value={backgroundCpm} onChange={e => setBackgroundCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                        ) : (
                            <>
                                <div><label className="block text-sm font-medium">Bkg Counts</label><input type="number" value={bkgCounts} onChange={e => setBkgCounts(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                                <div><label className="block text-sm font-medium">Bkg Time (min)</label><input type="number" value={bkgTime} onChange={e => setBkgTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                            </>
                        )}
            
                        <div><label className="block text-sm font-medium">Probe Area (cm²)</label><input type="number" value={probeArea} onChange={e => setProbeArea(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                        <div><label className="block text-sm font-medium">Instrument Eff. (%)</label><input type="number" value={instrumentEff} onChange={e => setInstrumentEff(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                        <div><label className="block text-sm font-medium">Source Eff. (%)</label><input type="number" value={surfaceEff} onChange={e => setSurfaceEff(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                    </div>
                </div>
            
                {mdaMode === MDA_MODE_STATIC ? (
                    <div className="space-y-4 animate-fade-in">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><label className="block text-sm font-medium">Sample Time (min)</label><input type="number" value={grossTime} onChange={e => setGrossTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                            <div><label className="block text-sm font-medium">Desired Unit</label><select value={outputUnit} onChange={e => setOutputUnit(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">{Object.keys(MDA_UNIT_CONFIG).map(u => <option key={u} value={u}>{MDA_UNIT_CONFIG[u].label}</option>)}</select></div>
                        </div>
                        {MDA_UNIT_CONFIG[outputUnit].requires.includes('volume') && (
                            <div><label className="block text-sm font-medium">Sample Volume (L)</label><input type="number" value={sampleVolume} onChange={e => setSampleVolume(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                        )}
                        {MDA_UNIT_CONFIG[outputUnit].requires.includes('mass') && (
                            <div><label className="block text-sm font-medium">Sample Mass (g)</label><input type="number" value={sampleMass} onChange={e => setSampleMass(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                        )}
                        <div>
                            <label className="block text-sm font-medium text-slate-700 dark:text-slate-300">Target Limit (Optional)</label>
                            <div className="flex items-center gap-2">
                                <input type="number" value={targetLimit} onChange={e => setTargetLimit(e.target.value)} placeholder={`e.g. 1000`} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" />
                                <span className="text-xs text-slate-500 mt-1 whitespace-nowrap">{outputUnit}</span>
                            </div>
                        </div>
                    </div>
                ) : (
                    <div className="space-y-4 animate-fade-in">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><label className="block text-sm font-medium">Scan Speed (cm/s)</label><input type="number" value={scanSpeed} onChange={e => setScanSpeed(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                            <div><label className="block text-sm font-medium">Probe Dimension (Scan Direction)</label><input type="number" value={probeDimension} onChange={e => setProbeDimension(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                        </div>
                    </div>
                )}
            
                {error && <p className="text-red-500 text-sm text-center mt-4">{error}</p>}
            
                {result && (
                    <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 animate-fade-in shadow-sm">
                        <div className="flex justify-end -mt-3 -mr-3 mb-2"><button onClick={handleSaveToHistory} className="text-slate-400 hover:text-sky-600"><Icon path={ICONS.notepad} className="w-5 h-5" /></button></div>
            
                        {result.type === 'static' ? (
                            <>
                                <p className="text-xs uppercase font-bold text-slate-500 text-center">
                                    {['cpm', 'counts'].includes(result.unit) ? 'Detection Limit (Ld)' : 'Minimum Detectable Activity'}
                                </p>
            
                                <div className="flex items-center justify-center gap-2">
                                    <span className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.MDA}</span>
                                    <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">{result.unit}</span>
                                </div>
            
                                {targetLimit && (
                                    <div className={`mt-3 p-3 rounded text-center border-l-4 ${parseFloat(result.MDA) <= parseFloat(targetLimit) ? 'bg-green-100 border-green-500 text-green-800' : 'bg-red-100 border-red-500 text-red-800'}`}>
                                        <p className="font-bold text-sm">{parseFloat(result.MDA) <= parseFloat(targetLimit) ? "PASS: Meets Limit" : "FAIL: Exceeds Limit"}</p>
                                        {parseFloat(result.MDA) > parseFloat(targetLimit) && result.timeToTarget && (
                                            <p className="text-xs mt-1">
                                                To reach {targetLimit} {result.unit}, increase sample time to <strong>{result.timeToTarget} min</strong>.
                                            </p>
                                        )}
                                    </div>
                                )}
                            </>
                        ) : (
                            <>
                                <p className="text-xs uppercase font-bold text-slate-500 text-center">Scan MDC</p>
                                <div className="flex items-center justify-center gap-2">
                                    <span className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.scan_mda}</span>
                                    <span className="text-md font-semibold text-slate-600 dark:text-slate-300">dpm/100cm²</span>
                                </div>
                                <div className="mt-2 text-center border-t border-slate-200 dark:border-slate-600 pt-2">
                                    <p className="text-xs text-slate-500">Surveyor Minimum Detectable Count Rate</p>
                                    <p className="font-mono font-bold text-lg text-slate-700 dark:text-slate-200">{result.scan_mdcr} net cpm</p>
                                </div>
                                {result.isAlphaWarn && (
                                    <p className="text-xs text-amber-600 mt-2 text-center bg-amber-50 p-2 rounded">
                                        <strong>Note:</strong> Background is very low (&lt;5 cpm). MARSSIM probability methods (Section 6.7.2.2) may be more accurate than the <em>d'</em> method for Alpha scanning.
                                    </p>
                                )}
                            </>
                        )}
                    </div>
                )}
            </div>
            </div>
            );
            };
            
            /**
            * @description A calculator to determine the required number of statistical samples for a
            * survey unit based on the more precise MARSSIM Equation 5-2.
            */
            
            const MARSSIM_SampleCalculator = ({ onTransferResults }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            const [alpha, setAlpha] = React.useState('0.05');
            const [beta, setBeta] = React.useState('0.05');
            const [sigma, setSigma] = React.useState('15');
            const [dcgl, setDcgl] = React.useState('100');
            const [lbgr, setLbgr] = React.useState('50');
            const [cv, setCv] = React.useState('0.3');
            const [backgroundPresence, setBackgroundPresence] = React.useState('insignificant');
            
            const [result, setResult] = React.useState(null);
            const [error, setError] = React.useState('');
            
            const zScores = {
            '0.005': 2.576, '0.01': 2.326, '0.025': 1.960, '0.05': 1.645,
            '0.10': 1.282, '0.20': 0.841,
            };
            
            const getNormalCDF = (x) => {
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            const prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            return x > 0 ? 1 - prob : prob;
            };
            
            const handleClearInputs = () => {
            setAlpha('0.05'); setBeta('0.05'); setSigma('15');
            setDcgl('100'); setLbgr('50'); setCv('0.3');
            setBackgroundPresence('insignificant');
            setResult(null); setError('');
            };
            
            React.useEffect(() => { handleCalculate(); }, []);
            
            React.useEffect(() => {
            localStorage.setItem('marssim_alpha', alpha);
            localStorage.setItem('marssim_beta', beta);
            localStorage.setItem('marssim_sigma', sigma);
            localStorage.setItem('marssim_dcgl', dcgl);
            localStorage.setItem('marssim_lbgr', lbgr);
            localStorage.setItem('marssim_cv', cv);
            localStorage.setItem('marssim_bg', backgroundPresence);
            }, [alpha, beta, sigma, dcgl, lbgr, cv, backgroundPresence]);
            
            const handleCalculateSigma = () => {
            const d = parseFloat(dcgl); const c = parseFloat(cv);
            if (!isNaN(d) && !isNaN(c)) setSigma((d * c).toPrecision(3));
            };
            
            const handleSetLbgr = () => {
            const d = parseFloat(dcgl);
            if (!isNaN(d)) setLbgr((d * 0.5).toPrecision(3));
            };
            
            const handleCalculate = () => {
            const sVal = parseFloat(sigma);
            const dVal = parseFloat(dcgl);
            const lVal = parseFloat(lbgr);
            
            if (isNaN(sVal) || isNaN(dVal) || isNaN(lVal) || sVal <= 0) {
            setResult(null); return;
            }
            if (dVal <= lVal) {
            setError('DCGL must be greater than LBGR.');
            setResult(null); return;
            }
            setError('');
            
            const z1_alpha = zScores[alpha];
            const z1_beta = zScores[beta];
            const delta = dVal - lVal;
            const rawRelShift = delta / sVal;
            const usedRelShift = rawRelShift > 3.0 ? 3.0 : rawRelShift;
            
            let Pr = 0;
            let N_raw = 0;
            let methodLabel = '';
            let samplesPerUnit = 0;
            let isWRS = false;
            
            if (backgroundPresence === 'insignificant') {
            methodLabel = 'No Background Correction (Sign Formula)';
            Pr = getNormalCDF(usedRelShift);
            if (Pr <= 0.5) { setError("Relative Shift too low."); setResult(null); return; }
            N_raw = Math.pow(z1_alpha + z1_beta, 2) / (4 * Math.pow(Pr - 0.5, 2));
            samplesPerUnit = Math.ceil(N_raw * 1.20);
            } else {
            isWRS = true;
            methodLabel = 'With Background Reference (WRS Formula)';
            Pr = getNormalCDF(usedRelShift / Math.sqrt(2));
            if (Pr <= 0.5) { setError("Relative Shift too low."); setResult(null); return; }
            N_raw = Math.pow(z1_alpha + z1_beta, 2) / (3 * Math.pow(Pr - 0.5, 2));
            const N_total_with_margin = N_raw * 1.20;
            samplesPerUnit = Math.ceil(N_total_with_margin / 2);
            }
            
            setResult({
            totalShift: delta,
            relativeShift: rawRelShift.toFixed(2),
            final_N: samplesPerUnit,
            methodLabel,
            isWRS
            });
            };
            
            const handleSaveToHistory = () => {
            if (result) {
            addHistory({
                id: Date.now(),
                type: 'MARSSIM Samples',
                icon: ICONS.calculator,
                inputs: `${result.methodLabel}, Δ/σ: ${result.relativeShift}`,
                result: `${result.final_N} samples`,
                view: VIEWS.MARSSIM_SAMPLES
            });
            addToast("Calculation saved to history!");
            }
            };
            
            React.useEffect(() => { handleCalculate(); }, [alpha, beta, sigma, dcgl, lbgr, cv, backgroundPresence]);
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-md mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                <div className="flex justify-between items-center mb-1">
                    <h2 className="text-xl font-bold text-slate-800 dark:text-white">MARSSIM Samples Calculator</h2>
                    <ClearButton onClick={handleClearInputs} />
                </div>
            
                <div className="mb-4 p-3 bg-slate-50 dark:bg-slate-700/50 rounded-lg border border-slate-200 dark:border-slate-600">
                    <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Is the Contaminant present in Background?</label>
                    <div className="flex gap-4">
                        <label className="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="bgP" value="insignificant" checked={backgroundPresence === 'insignificant'} onChange={e => setBackgroundPresence(e.target.value)} className="text-sky-600"/>
                            <span className="text-sm font-medium">No (Use Sign Formula)</span>
                        </label>
                        <label className="flex items-center gap-2 cursor-pointer">
                            <input type="radio" name="bgP" value="significant" checked={backgroundPresence === 'significant'} onChange={e => setBackgroundPresence(e.target.value)} className="text-sky-600"/>
                            <span className="text-sm font-medium">Yes (Use WRS Formula)</span>
                        </label>
                    </div>
                </div>
            
                <div className="space-y-4">
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <label className="block text-sm font-medium">Type I Error (α)</label>
                            <select value={alpha} onChange={e => setAlpha(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">
                                {Object.keys(zScores).map(key => <option key={key} value={key}>{key}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="block text-sm font-medium">Type II Error (β)</label>
                            <select value={beta} onChange={e => setBeta(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700">
                                {Object.keys(zScores).map(key => <option key={key} value={key}>{key}</option>)}
                            </select>
                        </div>
                    </div>
                    <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                        <div>
                            <label className="block text-sm font-medium">Estimated Std. Deviation (σ)</label>
                            <input type="number" value={sigma} onChange={e => setSigma(e.target.value)} placeholder="in units of DCGL" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium">DCGL (Limit)</label>
                            <input type="number" value={dcgl} onChange={e => setDcgl(e.target.value)} placeholder="Cleanup limit" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium">LBGR (Mean)</label>
                            <input type="number" value={lbgr} onChange={e => setLbgr(e.target.value)} placeholder="Concentration that is 'clean'" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" />
                        </div>
                    </div>
            
                    <details className="p-3 my-2 rounded-lg bg-slate-50 dark:bg-slate-900/50 border border-slate-200 dark:border-slate-700">
                        <summary className="cursor-pointer text-sm font-semibold text-slate-600 dark:text-slate-300">
                            Scoping Data Helper
                        </summary>
                        <div className="mt-4 pt-4 border-t border-slate-200 dark:border-slate-700 space-y-3">
                            <div className="flex items-end gap-2">
                                <div className="flex-grow">
                                    <label className="block text-xs font-medium">Coefficient of Variation (CV)</label>
                                    <input type="number" value={cv} onChange={e => setCv(e.target.value)} step="0.05" className="w-full mt-1 p-2 rounded-md bg-white dark:bg-slate-700" />
                                </div>
                                <button onClick={handleCalculateSigma} className="px-3 py-2 text-sm bg-slate-200 dark:bg-slate-600 rounded-md font-semibold hover:bg-slate-300 dark:hover:bg-slate-500">
                                    Calculate σ
                                </button>
                            </div>
                            <button onClick={handleSetLbgr} className="w-full px-3 py-2 text-sm bg-slate-200 dark:bg-slate-600 rounded-md font-semibold hover:bg-slate-300 dark:hover:bg-slate-500">
                                Set LBGR to 50% of DCGL
                            </button>
                        </div>
                    </details>
            
                    <button onClick={handleSaveToHistory} className="w-full py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">Save to Calculations</button>
            
                    {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            
                    {result && (
                        <div className="p-4 bg-slate-100 dark:bg-slate-700 rounded-lg mt-4 space-y-3 text-center animate-fade-in">
                            <div className="flex justify-between items-center pb-2 border-b border-slate-200 dark:border-slate-600">
                                <span className="text-sm font-bold text-slate-500 uppercase">Calculation Method</span>
                                <span className={`text-sm font-mono font-bold ${parseFloat(result.relativeShift) < 1 || parseFloat(result.relativeShift) > 3 ? 'text-amber-500' : 'text-green-600'}`}>Δ/σ: {result.relativeShift}</span>
                            </div>
            
                            <div className="py-2">
                                <p className="font-semibold block text-sm text-slate-500 dark:text-slate-400">
                                    {result.isWRS ? "Required Survey Points (N/2)" : "Required Survey Points (N)"}
                                </p>
                                <div className="flex items-center justify-center gap-2">
                                    <p className="text-4xl font-extrabold text-sky-600 dark:text-sky-400">{result.final_N}</p>
                                    <CopyButton textToCopy={result.final_N} />
                                </div>
                                <p className="text-xs font-medium text-slate-600 dark:text-slate-300 mt-1">(Includes 20% MARSSIM adjustment)</p>
                            </div>
            
                            {result.isWRS && (
                                <div className="p-3 bg-amber-50 dark:bg-amber-900/20 rounded border border-amber-200 dark:border-amber-700 text-xs text-amber-800 dark:text-amber-200">
                                    <strong>WRS Requirement:</strong> You must also collect <strong>{result.final_N}</strong> samples in your Reference Area.
                                </div>
                            )}
            
                            <button
                                onClick={() => onTransferResults(result.final_N)}
                                className="flex items-center justify-center gap-2 w-full py-2 bg-emerald-600 text-white font-bold rounded-lg hover:bg-emerald-700 transition shadow-sm hover:shadow-md"
                            >
                                <Icon path={ICONS.map} className="w-5 h-5" />
                                Map These Points &rarr;
                            </button>
                        </div>
                    )}
                </div>
            </div>
            </div>
            );
            };
            
            /**
            * @description React component for a graphical survey unit drawing tool. This utility
            * allows users to visually plan and lay out radiation survey points on an interactive map.
            * The tool is designed to support the planning phase of a final status survey, particularly
            * for a **Multi-Agency Radiation Survey and Site Investigation Manual (MARSSIM)** project.
            *
            * Key features include:
            * - **Interactive Map:** A Leaflet-based map provides a visual canvas.
            * - **Drawing Controls:** Users can draw survey unit boundaries using **polygons** or
            * **rectangles**.
            * - **Sample Point Generation:** Automatically generates statistical sample points within
            * the drawn boundary using common MARSSIM patterns: **random**, **square grid**, or
            * **triangular grid**.
            * - **Manual Point Placement:** Allows for the placement of "biased" sample points in
            * areas of known or suspected contamination.
            * - **Area Calculation:** Automatically calculates the area of the drawn survey unit.
            * - **Data Export:** The final list of sample points, including coordinates and a unique
            * identifier, can be exported to a `.csv` file for use with GPS devices or for documentation.
            *
            * This component is an essential part of the MARSSIM suite, bridging the statistical
            * calculations with a practical, field-ready planning tool.
            *
            * @prop {boolean} isVisible - Boolean to trigger map redraw on component mount,
            * ensuring correct rendering within a tabbed interface.
            */
            
            const DrawingTool = ({ isVisible, importedSamples }) => {
            const mapRef = React.useRef(null);
            const drawnItemsRef = React.useRef(null);
            const samplePointsLayerRef = React.useRef(null);
            const originMarkerRef = React.useRef(null);
            const fileInputRef = React.useRef(null);
            const osmLayerRef = React.useRef(null);
            const satelliteLayerRef = React.useRef(null);
            const { addToast } = useToast();
            
            // --- STATE MANAGEMENT ---
            const [surveyUnitLayer, setSurveyUnitLayer] = React.useState(null);
            const [surveyUnitArea, setSurveyUnitArea] = React.useState(0);
            const [plottedPoints, setPlottedPoints] = React.useState([]);
            const [locationInput, setLocationInput] = React.useState('');
            const [surveyUnitName, setSurveyUnitName] = React.useState('SU-1');
            const [surveyClass, setSurveyClass] = React.useState('Class 1');
            const [samplesToPlace, setSamplesToPlace] = React.useState(25);
            const [sampleCalcMode, setSampleCalcMode] = React.useState('byNumber');
            const [gridSpacing, setGridSpacing] = React.useState(10);

            const [mapStyle, setMapStyle] = React.useState('street');
            
            const highlightStyle = { weight: 5, color: '#0ea5e9', dashArray: '', fillOpacity: 0.5 };
            const defaultStyle = { color: '#3388ff' };
            
            const plottedPointsRef = React.useRef(plottedPoints);
            const surveyUnitNameRef = React.useRef(surveyUnitName);
            const surveyClassRef = React.useRef(surveyClass);
            
            // Keep refs synchronized with state
            React.useEffect(() => { plottedPointsRef.current = plottedPoints; }, [plottedPoints]);
            React.useEffect(() => { surveyUnitNameRef.current = surveyUnitName; }, [surveyUnitName]);
            React.useEffect(() => { surveyClassRef.current = surveyClass; }, [surveyClass]);
            
            
            // Handle Imported Samples
            React.useEffect(() => {
                if (importedSamples && importedSamples > 0) {
                    setSamplesToPlace(importedSamples);
                    setSampleCalcMode('byNumber'); 
                    addToast(`Imported ${importedSamples} samples from calculator.`);
                }
            }, [importedSamples]);
            
            // --- HELPER FUNCTIONS ---
            
            React.useEffect(() => {
            if (surveyUnitLayer) {
            const popupContent = `<b>Survey Unit: ${surveyUnitName}</b><br>Class: ${surveyClass}<br>Area: ${surveyUnitArea.toFixed(1)} m²`;
            surveyUnitLayer.setPopupContent(popupContent);
            }
            }, [surveyUnitName, surveyClass, surveyUnitLayer, surveyUnitArea]);
            
            const getNextIdForPrefix = (points, prefix) => {
            const existingNumbers = points
            .filter(p => p.id.startsWith(prefix + '-'))
            .map(p => parseInt(p.id.split('-')[1], 10))
            .sort((a, b) => a - b);
            
            let nextNum = 1;
            for (const num of existingNumbers) {
            if (num === nextNum) {
              nextNum++;
            } else {
              break; // Found a gap
            }
            }
            return `${prefix}-${nextNum}`;
            };
            
            // Robust point-in-polygon check
            const isPointInPolygon = (point, polygonLatLngs) => {
            // Leaflet Draw polygons can have nested arrays for holes, we take the outer ring [0]
            const polyPoints = (Array.isArray(polygonLatLngs[0])) ? polygonLatLngs[0] : polygonLatLngs;
            const x = point.lat, y = point.lng;
            let inside = false;
            for (let i = 0, j = polyPoints.length - 1; i < polyPoints.length; j = i++) {
            const xi = polyPoints[i].lat, yi = polyPoints[i].lng;
            const xj = polyPoints[j].lat, yj = polyPoints[j].lng;
            const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
            }
            return inside;
            };
            
            // Clears ONLY the statistical samples (Random, Square, Triangular)
            const handleClearPoints = () => {
            const biasedOnly = plottedPoints.filter(p => p.type === 'Biased');
            setPlottedPoints(biasedOnly);
            
            // Remove layers that are NOT the origin marker and NOT matched to a biased point ID
            samplePointsLayerRef.current.eachLayer(layer => {
            if (layer !== originMarkerRef.current) {
              // Check if this layer corresponds to a biased point we are keeping
              // Biased points are stored in state, so we can check IDs if we attached them to layers
              // Simplified approach: Clear all points layer, re-add biased points
              samplePointsLayerRef.current.removeLayer(layer);
            }
            });
            
            // Re-add biased points visually
            biasedOnly.forEach(p => {
            const latLng = { lat: p.lat, lng: p.lng };
            const popupContent = `<b>Bias Sample Point #${p.id}</b><br>Type: Biased<br>Lat: ${p.lat.toFixed(7)}<br>Lng: ${p.lng.toFixed(7)}`;
            const marker = L.circleMarker(latLng, { radius: 4, className: 'biased-sample-marker' }).bindPopup(popupContent);
            marker.myCustomId = p.id;
            drawnItemsRef.current.addLayer(marker); // Biased points live in drawnItems so they persist
            });
            };
            
            const handleClearAll = () => {
            if (drawnItemsRef.current) drawnItemsRef.current.clearLayers();
            if (samplePointsLayerRef.current) samplePointsLayerRef.current.clearLayers();
            setSurveyUnitLayer(null);
            setSurveyUnitArea(0);
            setPlottedPoints([]);
            };
            
            const onDrawDelete = (e) => {
            e.layers.eachLayer(layer => {
            if (layer instanceof L.CircleMarker && layer.myCustomId) {
              const deletedId = layer.myCustomId;
              setPlottedPoints(currentPoints =>
                  currentPoints.filter(p => p.id !== deletedId)
              );
            } else if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
              handleClearAll();
            }
            });
            addToast("Item(s) removed from map.");
            };
            
            // --- CORE LOGIC ---
            const onDrawEditOrCreate = (e) => {
            if (e.type === 'draw:edited') {
            const currentPoints = plottedPointsRef.current;
            
            // 1. Separate biased points (persist) from statistical (clear, as they may now be outside)
            const biasedPoints = currentPoints.filter(p => p.type === 'Biased');
            const statisticalPoints = currentPoints.filter(p => p.type !== 'Biased');
            
            // If we had statistical points, warn the user they are gone/need regen
            if (statisticalPoints.length > 0) {
               addToast("Boundary modified. Statistical samples cleared.");
               // Clear them visually
               samplePointsLayerRef.current.clearLayers();
               // Origin marker might need re-adding
               if (originMarkerRef.current) {
                    // Logic in useEffect will re-add origin based on surveyUnitLayer
                    originMarkerRef.current.remove();
                    originMarkerRef.current = null;
               }
            }
            
            // Update Biased Points positions if they were dragged (Leaflet Draw handles marker drag)
            const updatedBiasedPoints = [];
            e.layers.eachLayer(layer => {
              if (layer instanceof L.CircleMarker && layer.myCustomId) {
                  const latLng = layer.getLatLng();
                  updatedBiasedPoints.push({
                      id: layer.myCustomId,
                      lat: latLng.lat,
                      lng: latLng.lng,
                      type: 'Biased'
                  });
              } else if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
                  // Recalculate Area using Geodesic (more accurate)
                  const latLngs = layer.getLatLngs()[0];
                  const area = L.GeometryUtil.geodesicArea(latLngs);
                  setSurveyUnitArea(area);
            
                  const popupContent = `<b>Survey Unit: ${surveyUnitNameRef.current}</b><br>Class: ${surveyClassRef.current}<br>Area: ${area.toFixed(1)} m²`;
                  layer.setPopupContent(popupContent);
              }
            });
            
            // If we didn't find specific marker layers in the event, we keep the old biased points (they weren't edited)
            // But this event usually contains everything being edited.
            // Simplified: We set state to just the biased points. User must click "Generate" again for grid.
            setPlottedPoints(updatedBiasedPoints.length > 0 ? updatedBiasedPoints : biasedPoints);
            return;
            }
            
            const layer = e.layer;
            if (!layer) return;
            
            if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
            drawnItemsRef.current.eachLayer(l => {
              if (l instanceof L.Polygon || l instanceof L.Rectangle) { drawnItemsRef.current.removeLayer(l); }
            });
            handleClearPoints();
            drawnItemsRef.current.addLayer(layer);
            setSurveyUnitLayer(layer);
            
            // Use Geodesic Area
            const latLngs = layer.getLatLngs()[0];
            const area = L.GeometryUtil.geodesicArea(latLngs);
            setSurveyUnitArea(area);
            
            const popupContent = `<b>Survey Unit: ${surveyUnitNameRef.current}</b><br>Class: ${surveyClassRef.current}<br>Area: ${area.toFixed(1)} m²`;
            layer.bindPopup(popupContent).openPopup();
            
            layer.on({
              mouseover: (e) => e.target.setStyle(highlightStyle),
              mouseout: (e) => e.target.setStyle(defaultStyle)
            });
            } else if (layer instanceof L.Marker) {
            drawnItemsRef.current.removeLayer(layer);
            const latLng = layer.getLatLng();
            
            setPlottedPoints(prevPoints => {
              const newId = getNextIdForPrefix(prevPoints, 'B');
              const newPoint = { id: newId, lat: latLng.lat, lng: latLng.lng, type: 'Biased' };
            
              const popupContent = `<b>Bias Sample Point #${newId}</b><br>Type: Biased<br>Lat: ${latLng.lat.toFixed(7)}<br>Lng: ${latLng.lng.toFixed(7)}`;
              const newMarker = L.circleMarker(latLng, {
                  radius: 4,
                  className: 'biased-sample-marker'
              }).bindPopup(popupContent);
            
              newMarker.on('contextmenu', () => {
                   drawnItemsRef.current.removeLayer(newMarker);
                   setPlottedPoints(prev => prev.filter(p => p.id !== newId));
                   addToast(`Bias Point #${newId} removed.`);
               });
            
              newMarker.myCustomId = newId;
              drawnItemsRef.current.addLayer(newMarker);
            
              return [...prevPoints, newPoint];
            });
            }
            };
            
            const handleGenerateSamples = React.useCallback((pattern) => {
            if (!surveyUnitLayer) {
            addToast("Please draw a survey unit boundary first.");
            return;
            }
            handleClearPoints(); // Clear existing grid points
            
            // Retrieve biased points to preserve them
            const existingBiasedPoints = plottedPointsRef.current.filter(p => p.type === 'Biased');
            
            let numSamples = samplesToPlace;
            let spacingMeters = gridSpacing;
            const latLngs = surveyUnitLayer.getLatLngs();
            const bounds = surveyUnitLayer.getBounds();
            
            // 1. Calculate Spacing / Number
            if (pattern !== 'random') {
            if (sampleCalcMode === 'bySpacing') {
              if (spacingMeters <= 0) { addToast("Grid spacing must be > 0."); return; }
              // Estimate N
              const multiplier = pattern === 'triangular' ? 0.866 : 1;
              numSamples = Math.ceil(surveyUnitArea / (spacingMeters * spacingMeters * multiplier));
              setSamplesToPlace(numSamples);
            } else { // byNumber
              if (numSamples <= 0) { addToast("Number of samples must be > 0."); return; }
              const multiplier = pattern === 'triangular' ? 0.866 : 1;
              spacingMeters = Math.sqrt(surveyUnitArea / (multiplier * numSamples));
              setGridSpacing(spacingMeters.toFixed(2));
            }
            }
            
            // --- Infinite Loop Protection ---
            if (pattern !== 'random' && spacingMeters <= 0.01) {
            addToast("Calculated grid spacing is too small. Check area and sample count.");
            return;
            }
            
            const newPoints = [];
            
            if (pattern === 'random') {
            // Random generation (unchanged)
            for (let i = 0; i < numSamples; i++) {
              let pointFound = false;
              let attempts = 0;
              while (!pointFound && attempts < 2000) {
                  const lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());
                  const lng = bounds.getWest() + Math.random() * (bounds.getEast() - bounds.getWest());
                  if (isPointInPolygon({ lat, lng }, latLngs)) {
                      newPoints.push({ lat, lng });
                      pointFound = true;
                  }
                  attempts++;
              }
            }
            } else {
            // Systematic Grid
            // Approx conversion factors at the center latitude
            const centerLat = (bounds.getSouth() + bounds.getNorth()) / 2;
            const metersPerDegLat = 111320;
            const metersPerDegLng = 111320 * Math.cos(centerLat * Math.PI / 180);
            
            const spacingLat = spacingMeters / metersPerDegLat;
            const spacingLng = spacingMeters / metersPerDegLng;
            
            // Random start point logic (MARSSIM requirement)
            // L.GeometryUtil.randomPointInLayer(surveyUnitLayer) is better but manual is fine for now
            const randomLatOffset = Math.random() * spacingLat;
            const randomLngOffset = Math.random() * spacingLng;
            
            let row = 0;
            // Loop with safety check
            for (let lat = bounds.getSouth() + randomLatOffset - spacingLat; lat < bounds.getNorth() + spacingLat; lat += spacingLat * (pattern === 'triangular' ? 0.866 : 1)) {
            
              const triangularShift = (pattern === 'triangular' && row % 2 !== 0) ? spacingLng / 2 : 0;
            
              for (let lng = bounds.getWest() + randomLngOffset - spacingLng; lng < bounds.getEast() + spacingLng; lng += spacingLng) {
            
                  const actualLng = lng + triangularShift;
            
                  if (isPointInPolygon({ lat, lng: actualLng }, latLngs)) {
                      newPoints.push({ lat, lng: actualLng });
                  }
              }
              row++;
            }
            }
            
            // Add to map
            const pointsWithTypes = newPoints.map((p, index) => {
            const prefix = pattern.charAt(0).toUpperCase(); // R, S, T
            return {
              ...p,
              id: `${prefix}-${index + 1}`,
              type: pattern.charAt(0).toUpperCase() + pattern.slice(1)
            };
            });
            
            setPlottedPoints([...existingBiasedPoints, ...pointsWithTypes]);
            
            pointsWithTypes.forEach(point => {
            const marker = L.circleMarker([point.lat, point.lng], { radius: 4, className: 'grid-sample-marker' });
            const popupContent = `<b>Sample Point #${point.id}</b><br>Type: ${point.type}<br>Lat: ${point.lat.toFixed(7)}<br>Lng: ${point.lng.toFixed(7)}`;
            marker.bindPopup(popupContent).addTo(samplePointsLayerRef.current);
            });
            
            addToast(`${newPoints.length} ${pattern} sample points generated.`);
            
            }, [surveyUnitLayer, sampleCalcMode, samplesToPlace, gridSpacing, surveyUnitArea, addToast]);
            
            const handleZoomToSurveyUnit = () => { if (surveyUnitLayer && mapRef.current) { mapRef.current.fitBounds(surveyUnitLayer.getBounds()); } };
            
            const handleSavePlan = () => {
            if (!surveyUnitLayer) { addToast("Please draw a survey unit to save."); return; }
            const planData = {
            surveyUnit: surveyUnitLayer.toGeoJSON(),
            points: plottedPoints,
            surveyClass: surveyClass,
            samplesToPlace: samplesToPlace,
            };
            const blob = new Blob([JSON.stringify(planData, null, 2)], { type: 'application/json' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "survey-plan.json";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            };
            
            const handleLoadPlan = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
            try {
              const parsedData = JSON.parse(e.target.result);
              if (!parsedData.surveyUnit || !parsedData.points) { throw new Error("Invalid plan file format."); }
            
              handleClearAll();
            
              const newSurveyUnit = L.geoJSON(parsedData.surveyUnit, { style: defaultStyle });
              const layer = newSurveyUnit.getLayers()[0];
              if (layer) {
                  drawnItemsRef.current.addLayer(layer);
                  setSurveyUnitLayer(layer);
            
                  // Use Geodesic
                  const latLngs = layer.getLatLngs()[0];
                  const area = L.GeometryUtil.geodesicArea(latLngs);
                  setSurveyUnitArea(area);
            
                  mapRef.current.fitBounds(layer.getBounds());
            
                  const popupContent = `<b>Survey Unit</b><br>Class: ${parsedData.surveyClass || 'Class 1'}<br>Area: ${area.toFixed(1)} m²`;
                  layer.bindPopup(popupContent);
                  layer.on({
                      mouseover: (e) => e.target.setStyle(highlightStyle),
                      mouseout: (e) => e.target.setStyle(defaultStyle)
                  });
              }
            
              const loadedPoints = parsedData.points || [];
              setPlottedPoints(loadedPoints);
              setSurveyClass(parsedData.surveyClass || 'Class 1');
              setSamplesToPlace(parsedData.samplesToPlace || 25);
            
              loadedPoints.forEach((point, index) => {
                  const marker = L.circleMarker([point.lat, point.lng], {
                      radius: 4,
                      className: point.type === 'Biased' ? 'biased-sample-marker' : 'grid-sample-marker'
                  });
                  const popupContent = `<b>Sample Point #${point.id}</b><br>Type: ${point.type}<br>Lat: ${point.lat.toFixed(7)}<br>Lng: ${point.lng.toFixed(7)}`;
                  marker.bindPopup(popupContent);
            
                  marker.on('contextmenu', () => {
                       // Remove from map
                       samplePointsLayerRef.current.removeLayer(marker);
                       
                       // Update state
                       setPlottedPoints(prev => prev.filter(p => p.id !== point.id));
                       
                       addToast(`Point #${point.id} removed.`);
                   });
            
                  marker.addTo(samplePointsLayerRef.current);
            
                  if (point.type === 'Biased') {
                      marker.myCustomId = point.id;
                      drawnItemsRef.current.addLayer(marker); // Ensure Biased persist in edits
                  }
              });
            
            } catch (error) { 
               // Use app toast instead of browser alert
               addToast(`Error loading plan: ${error.message}`); 
            }
            };
            reader.readAsText(file);
            event.target.value = null;
            };
            
            // Export Function
            const handleExport = () => {
                if (!filteredList || filteredList.length === 0) return;
            
                // IMPROVEMENT: Added raw numeric columns for analysis
                const headers = [
                    'Name', 'Symbol', 'Category', 
                    'Half-Life (Text)', 'Half-Life (Seconds)', 
                    'Decay Constant (s^-1)', 
                    'Specific Activity (Bq/g)', 
                    'Gamma Constant (R-m2/hr-Ci)', 
                    'D-Value (TBq)',
                    'Emissions'
                ];
                
                const csvRows = [headers.join(',')];
            
                filteredList.forEach(n => {
                    // sanitize text to prevent CSV breakages
                    const name = `"${n.name}"`;
                    const emissions = `"${(n.emissionType || []).join('; ')}"`;
                    
                    // Parse raw values
                    const hlSeconds = parseHalfLifeToSeconds(n.halfLife);
                    const sa = parseSpecificActivity(n.specificActivity);
                    const lambda = hlSeconds === Infinity ? 0 : Math.log(2) / hlSeconds;
            
                    const row = [
                        name,
                        n.symbol,
                        n.category,
                        `"${n.halfLife}"`, // Quote text to handle spaces
                        hlSeconds === Infinity ? 'Infinity' : hlSeconds,
                        lambda,
                        sa || 'N/A',
                        n.gammaConstant ? parseFloat(n.gammaConstant) : 'N/A',
                        n.dValue || 'N/A',
                        emissions
                    ];
                    csvRows.push(row.join(','));
                });
            
                const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'nuclide_database_export.csv';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };
            
            const handleGoToLocation = async () => {
            if (!locationInput.trim()) return;
            const coordRegex = /^-?[\d.]+\s*,\s*-?[\d.]+$/;
            if (coordRegex.test(locationInput)) {
            const [lat, lng] = locationInput.split(',').map(Number);
            if (!isNaN(lat) && !isNaN(lng)) { mapRef.current.setView([lat, lng], 16); return; }
            }
            try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationInput)}`);
            const data = await response.json();
            if (data && data.length > 0) {
              const { lat, lon } = data[0];
              mapRef.current.setView([parseFloat(lat), parseFloat(lon)], 16);
            } else { addToast("Location not found."); }
            } catch (error) { addToast("Could not connect to the location service."); }
            };
            
            // --- PRINT / PDF HANDLER (Simplified for brevity, includes origin style) ---
            const handlePrintMap = () => {
            if (!mapRef.current || !surveyUnitLayer) { addToast("No survey unit to print."); return; }
            // ... (Keep existing print logic, it works fine. Ensure you update the coordinate precision in the HTML table generation to .toFixed(7) if desired.)
            // Just triggering the existing function if you kept it.
            window.print();
            };
            
            // --- MAP INITIALIZATION ---
            React.useEffect(() => {
                // 1. Check if map is already initialized
                if (mapRef.current) return;
                
                // 2. Safety Check: Ensure the HTML element exists before trying to load Leaflet
                if (!document.getElementById('marssim-map')) return;
            
                L.drawLocal.draw.toolbar.buttons.marker = 'Place a bias sample';
                L.drawLocal.draw.handlers.marker.tooltip.start = 'Click map to place bias sample.';
                
                const biasMarkerIcon = new L.DivIcon({ className: 'leaflet-draw-biased-marker-icon', iconSize: new L.Point(12, 12), iconAnchor: new L.Point(8, 8) });
                const yourStadiaApiKey = 'a7f8d6b2-37be-4661-afa4-0409424b5708';
                
                osmLayerRef.current = L.tileLayer('https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png?api_key={apiKey}', {
                    attribution: '&copy; <a href="https://stadiamaps.com/" target="_blank">Stadia Maps</a>',
                    maxNativeZoom: 19, maxZoom: 21, apiKey: yourStadiaApiKey
                });
                satelliteLayerRef.current = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri', maxNativeZoom: 19, maxZoom: 21 });
                
                mapRef.current = L.map('marssim-map', { layers: [osmLayerRef.current] }).setView([37.207, -76.51], 13);
                
                drawnItemsRef.current = new L.FeatureGroup();
                samplePointsLayerRef.current = new L.FeatureGroup();
                mapRef.current.addLayer(drawnItemsRef.current);
                mapRef.current.addLayer(samplePointsLayerRef.current);
                
                const drawControl = new L.Control.Draw({
                    edit: { featureGroup: drawnItemsRef.current },
                    draw: {
                        polyline: false, polygon: { shapeOptions: { color: '#3388ff' } },
                        rectangle: { shapeOptions: { color: '#3388ff' } },
                        marker: { icon: biasMarkerIcon }, circle: false, circlemarker: false
                    }
                });
                mapRef.current.addControl(drawControl);
                
                // Add North Arrow & Scale (Keep existing logic)
                L.control.scale({ imperial: true, metric: true }).addTo(mapRef.current);
                
                // Events
                mapRef.current.on(L.Draw.Event.CREATED, onDrawEditOrCreate);
                mapRef.current.on(L.Draw.Event.EDITED, onDrawEditOrCreate);
                mapRef.current.on(L.Draw.Event.DELETED, onDrawDelete);
                
                return () => { if (mapRef.current) { mapRef.current.remove(); mapRef.current = null; } };
            }, []);
            
            React.useEffect(() => { if (isVisible && mapRef.current) { setTimeout(() => mapRef.current.invalidateSize(), 100); } }, [isVisible]);
            
            // Manage Origin Marker
            React.useEffect(() => {
            if (originMarkerRef.current) { originMarkerRef.current.remove(); originMarkerRef.current = null; }
            if (surveyUnitLayer && samplePointsLayerRef.current) {
            const originLatLng = surveyUnitLayer.getBounds().getSouthWest();
            const originMarker = L.circleMarker(originLatLng, { radius: 6, className: 'origin-sample-marker' }).bindPopup(`<b>Survey Origin (SW Corner)</b><br>Lat: ${originLatLng.lat.toFixed(7)}<br>Lng: ${originLatLng.lng.toFixed(7)}`);
            originMarker.addTo(samplePointsLayerRef.current);
            originMarkerRef.current = originMarker;
            }
            }, [surveyUnitLayer]);

            // Handle Map Style Switching ---
            React.useEffect(() => {
                if (!mapRef.current || !osmLayerRef.current || !satelliteLayerRef.current) return;

                if (mapStyle === 'satellite') {
                    if (mapRef.current.hasLayer(osmLayerRef.current)) {
                        mapRef.current.removeLayer(osmLayerRef.current);
                    }
                    if (!mapRef.current.hasLayer(satelliteLayerRef.current)) {
                        mapRef.current.addLayer(satelliteLayerRef.current);
                    }
                } else {
                    if (mapRef.current.hasLayer(satelliteLayerRef.current)) {
                        mapRef.current.removeLayer(satelliteLayerRef.current);
                    }
                    if (!mapRef.current.hasLayer(osmLayerRef.current)) {
                        mapRef.current.addLayer(osmLayerRef.current);
                    }
                }
            }, [mapStyle]);
            
            return (
                <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
                    {/* Header Row */}
                    <div className="flex flex-wrap justify-between items-center mb-4 gap-4">
                        
                        {/* Left Side: Title + Toggle */}
                        <div className="flex items-center gap-4">
                            <h3 className="text-lg font-bold">Survey Unit Drawing Tool</h3>
                            
                            {/* Map Style Toggle */}
                            <div className="flex bg-slate-200 dark:bg-slate-700 rounded-lg p-1">
                                <button 
                                    onClick={() => setMapStyle('street')}
                                    className={`px-3 py-1 text-xs font-bold rounded-md transition-all ${mapStyle === 'street' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}
                                >
                                    Street
                                </button>
                                <button 
                                    onClick={() => setMapStyle('satellite')}
                                    className={`px-3 py-1 text-xs font-bold rounded-md transition-all ${mapStyle === 'satellite' ? 'bg-white dark:bg-slate-600 shadow text-sky-600' : 'text-slate-500'}`}
                                >
                                    Satellite
                                </button>
                            </div>
                        </div>
                        
                        {/* Right Side: Action Buttons */}
                        <div className="flex items-center gap-2">
                            {surveyUnitLayer && ( <button onClick={handleZoomToSurveyUnit} className="px-3 py-2 text-sm bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">Zoom to Unit</button> )}
                            <input type="file" ref={fileInputRef} onChange={handleLoadPlan} accept=".json" style={{ display: 'none' }} />
                            <button onClick={() => fileInputRef.current.click()} className="px-3 py-2 text-sm bg-slate-200 dark:bg-slate-600 font-semibold rounded-lg hover:bg-slate-300 dark:hover:bg-slate-500 transition">Load Plan</button>
                            <button onClick={handleSavePlan} className="px-3 py-2 text-sm bg-slate-200 dark:bg-slate-600 font-semibold rounded-lg hover:bg-slate-300 dark:hover:bg-slate-500 transition">Save Plan</button>
                        </div>
                    </div>

                    {/* Location Search Bar */}
                    <div className="flex gap-2 items-center mb-4">
                        <input type="text" value={locationInput} onChange={(e) => setLocationInput(e.target.value)} onKeyDown={(e) => { if (e.key === 'Enter') handleGoToLocation(); }} placeholder="Enter an address or lat,lng coordinates" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 focus:outline-none focus:ring-2 focus:ring-sky-500"/>
                        <button onClick={handleGoToLocation} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">Go</button>
                    </div>
                    
                    {/* Map Container */}
                    <div id="marssim-map" className="w-full h-[60vh] my-4 rounded-lg bg-slate-200 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 z-0"></div>
                    
                    {/* Dashboard Controls */}
                    <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div className="md:col-span-2 p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg">
                            <h4 className="font-bold text-lg mb-3">Survey Unit Dashboard</h4>
                            <div className="grid grid-cols-2 gap-4 text-sm">
                                <div>
                                    <label className="font-semibold text-slate-500 dark:text-slate-400">Unit Name</label>
                                    <input type="text" value={surveyUnitName} onChange={e => setSurveyUnitName(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600"/>
                                </div>
                                <div>
                                    <label className="font-semibold text-slate-500 dark:text-slate-400">Unit Class</label>
                                    <select value={surveyClass} onChange={e => setSurveyClass(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600">
                                        <option>Class 1</option><option>Class 2</option><option>Class 3</option><option>Un-Impacted</option><option>Other</option>
                                    </select>
                                </div>
                                <div className="pt-2">
                                    <p className="font-semibold text-slate-500 dark:text-slate-400">Area (Geodesic)</p>
                                    <p className="text-xl font-bold text-sky-600 dark:text-sky-400">{surveyUnitArea.toFixed(1)} m²</p>
                                </div>
                                <div className="pt-2">
                                    <p className="font-semibold text-slate-500 dark:text-slate-400">Plotted Samples</p>
                                    <p className="text-xl font-bold text-sky-600 dark:text-sky-400">{plottedPoints.length}</p>
                                </div>
                            </div>
                            {gridSpacing > 0 && (
                                <div className="mt-3 p-2 bg-white dark:bg-slate-700 border border-slate-200 dark:border-slate-600 rounded text-xs">
                                    <span className="font-bold text-slate-600 dark:text-slate-300">Hotspot Detection:</span>
                                    <span className="ml-1 text-slate-500 dark:text-slate-400">
                                        With L = {gridSpacing}m, approx. unscanned area is 
                                        <strong> {((gridSpacing * gridSpacing) * 0.866).toFixed(1)} m²</strong> (Triangular) or 
                                        <strong> {(gridSpacing * gridSpacing).toFixed(1)} m²</strong> (Square).
                                    </span>
                                </div>
                            )}
                        </div>
                        <div className="p-4 bg-slate-50 dark:bg-slate-800/50 rounded-lg h-full flex flex-col justify-between">
                            <div>
                                <h4 className="font-bold text-lg mb-3">Statistical Samples</h4>
                                <div className="flex w-full p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-3">
                                    <button onClick={() => setSampleCalcMode('byNumber')} className={`w-1/2 p-1 rounded-md text-xs font-semibold ${sampleCalcMode === 'byNumber' ? 'bg-white dark:bg-slate-800' : ''}`}>By Number</button>
                                    <button onClick={() => setSampleCalcMode('bySpacing')} className={`w-1/2 p-1 rounded-md text-xs font-semibold ${sampleCalcMode === 'bySpacing' ? 'bg-white dark:bg-slate-800' : ''}`}>By Spacing</button>
                                </div>
                                {sampleCalcMode === 'byNumber' ? (
                                    <div className="text-center">
                                        <label className="font-semibold text-sm text-slate-500 dark:text-slate-400 mb-2">Desired Number of Samples</label>
                                        <input type="number" value={samplesToPlace} onChange={(e) => setSamplesToPlace(parseInt(e.target.value, 10) || 0)} className="persistent-spinner w-24 text-center text-2xl font-bold text-sky-600 dark:text-sky-400 p-1 bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-md focus:ring-2 focus:ring-sky-500 focus:outline-none" />
                                    </div>
                                ) : (
                                    <div className="text-center">
                                        <label className="font-semibold text-sm text-slate-500 dark:text-slate-400 mb-2">Grid Spacing (meters)</label>
                                        <input type="number" value={gridSpacing} onChange={(e) => setGridSpacing(parseInt(e.target.value, 10) || 0)} className="persistent-spinner w-24 text-center text-2xl font-bold text-sky-600 dark:text-sky-400 p-1 bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-md focus:ring-2 focus:ring-sky-500 focus:outline-none" />
                                    </div>
                                )}
                            </div>
                            <div className="grid grid-cols-3 gap-2 mt-2">
                                <button onClick={() => handleGenerateSamples('square')} className="p-2 text-xs md:text-sm bg-slate-200 dark:bg-slate-600 font-semibold rounded-md hover:bg-sky-200 dark:hover:bg-sky-800">Square Grid</button>
                                <button onClick={() => handleGenerateSamples('triangular')} className="p-2 text-[12px] leading-tight bg-slate-200 dark:bg-slate-600 font-semibold rounded-md hover:bg-sky-200 dark:hover:bg-sky-800">Triangular Grid</button>
                                <button onClick={() => handleGenerateSamples('random')} className="p-2 text-xs md:text-sm bg-slate-200 dark:bg-slate-600 font-semibold rounded-md hover:bg-sky-200 dark:hover:bg-sky-800">Random</button>
                            </div>
                        </div>
                    </div>

                    {/* Data Table */}
                    <div className="mt-6 pt-6 border-t border-slate-200 dark:border-slate-700">
                        <div className="flex justify-between items-center">
                            <h3 className="text-lg font-bold">Plotted Sample Coordinates ({plottedPoints.length})</h3>
                            <div className="flex items-center gap-4">
                                <button onClick={handleClearPoints} className="text-xs text-slate-500 hover:underline font-semibold flex items-center gap-1"><Icon path={ICONS.clear} className="w-3 h-3"/> Clear Grid Points</button>
                                <button onClick={handleClearAll} className="text-xs text-slate-500 hover:underline font-semibold flex items-center gap-1"><Icon path={ICONS.clear} className="w-3 h-3"/> Clear All</button>
                                <button onClick={handleExport} className="px-3 py-2 text-sm bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition flex items-center gap-2">Export CSV</button>
                            </div>
                        </div>
                        <div className="max-h-60 overflow-y-auto mt-2 pr-2">
                            {plottedPoints.length > 0 || surveyUnitLayer ? (
                                <div className="overflow-x-auto">
                                    <table className="w-full text-sm text-center">
                                        <thead className="bg-slate-100 dark:bg-slate-700 sticky top-0">
                                            <tr>
                                                <th className="p-2 text-center">#</th>
                                                <th className="p-2 text-center">Type</th>
                                                <th className="p-2 text-center">Latitude</th>
                                                <th className="p-2 text-center">Longitude</th>
                                                <th className="p-2 text-center">X (m)</th>
                                                <th className="p-2 text-center">Y (m)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {(() => {
                                                const origin = surveyUnitLayer ? { lat: surveyUnitLayer.getBounds().getSouthWest().lat, lng: surveyUnitLayer.getBounds().getSouthWest().lng } : null;
                                                const sortedPoints = [...plottedPoints].sort((a, b) => {
                                                    const aIsBiased = a.type === 'Biased';
                                                    const bIsBiased = b.type === 'Biased';
                                                    if (aIsBiased && !bIsBiased) return -1;
                                                    if (!aIsBiased && bIsBiased) return 1;
                                                    const aNum = parseInt(a.id.split('-')[1]);
                                                    const bNum = parseInt(b.id.split('-')[1]);
                                                    return aNum - bNum;
                                                });
                                                return sortedPoints.map((point) => {
                                                    let xDist = 'N/A', yDist = 'N/A';
                                                    if (origin) {
                                                        yDist = calculateDistance(origin, { lat: point.lat, lng: origin.lng }).toFixed(3);
                                                        xDist = calculateDistance(origin, { lat: origin.lat, lng: point.lng }).toFixed(3);
                                                    }
                                                    return (
                                                        <tr key={point.id} className="border-b border-slate-200 dark:border-slate-700">
                                                            <td className="p-2 font-medium">{point.id}</td>
                                                            <td className="p-2">{point.type}</td>
                                                            <td className="p-2 font-mono">{point.lat.toFixed(7)}</td>
                                                            <td className="p-2 font-mono">{point.lng.toFixed(7)}</td>
                                                            <td className="p-2 font-mono">{xDist}</td>
                                                            <td className="p-2 font-mono">{yDist}</td>
                                                        </tr>
                                                    );
                                                });
                                            })()}
                                        </tbody>
                                        <tfoot>
                                            {(() => {
                                                const origin = surveyUnitLayer ? { lat: surveyUnitLayer.getBounds().getSouthWest().lat, lng: surveyUnitLayer.getBounds().getSouthWest().lng } : null;
                                                if (!origin) return null;
                                                return ( <tr className="bg-slate-200 dark:bg-slate-700 font-semibold border-t-2 border-slate-300 dark:border-slate-600"><td colSpan="2" className="p-2 text-left">Origin (SW Corner)</td><td className="p-2 font-mono">{origin.lat.toFixed(7)}</td><td className="p-2 font-mono">{origin.lng.toFixed(7)}</td><td className="p-2 font-mono">0.000</td><td className="p-2 font-mono">0.000</td></tr> );
                                            })()}
                                        </tfoot>
                                    </table>
                                </div>
                            ) : ( <p className="text-center text-slate-500 dark:text-slate-400 py-4">No sample points have been placed.</p> )}
                        </div>
                    </div>
                </div>
            );
            };
            
            /**
            * @description React component for the MARSSIM Sample Design Suite.
            * This component acts as a container for two main functionalities:
            * 1.  **Sample Size Calculator:** Calculates the number of samples required based on MARSSIM methodology.
            * 2.  **Survey Unit Drawing Tool:** Provides a user interface for drawing survey units and sample locations.
            *
            * It manages the active module state ('calculator' or 'drawing') and conditionally renders the corresponding
            * sub-component (`MARSSIM_SampleCalculator` or `DrawingTool`) based on user selection.
            */
            
            const MARSSIM_SampleDesign = () => {
            const [activeModule, setActiveModule] = React.useState('calculator');
            //  Shared state to hold the calculated N
            const [transferredSamples, setTransferredSamples] = React.useState(null);
            
            //  Handler to receive N and switch tabs
            const handleTransferN = (n) => {
            setTransferredSamples(n);
            setActiveModule('drawing');
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-4xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
              <h2 className="text-xl font-bold text-slate-800 dark:text-white">MARSSIM Sample Design Suite</h2>
            
              {/* Navigation Tabs */}
              <div className="flex w-full p-1 my-4 bg-slate-200 dark:bg-slate-700 rounded-lg">
                  <button
                      onClick={() => setActiveModule('calculator')}
                      className={`w-1/2 p-2 rounded-md text-sm font-semibold transition-colors ${
                          activeModule === 'calculator' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'
                      }`}
                  >
                      1. Calculate Number of Samples
                  </button>
                  <button
                      onClick={() => setActiveModule('drawing')}
                      className={`w-1/2 p-2 rounded-md text-sm font-semibold transition-colors ${
                          activeModule === 'drawing' ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'
                      }`}
                  >
                      2. Draw Survey Unit
                  </button>
              </div>
            
              {/* Content Area */}
              <div>
                  <div style={{ display: activeModule === 'calculator' ? 'block' : 'none' }}>
                      {/* PASS the handler down */}
                      <MARSSIM_SampleCalculator onTransferResults={handleTransferN} />
                  </div>
                  <div style={{ display: activeModule === 'drawing' ? 'block' : 'none' }}>
                      {/* PASS the data down */}
                      <DrawingTool
                          isVisible={activeModule === 'drawing'}
                          importedSamples={transferredSamples}
                      />
                  </div>
              </div>
            </div>
            </div>
            );
            };
            
            // ==============================================================================
// MARSSIM STATISTICAL TESTS MODULE
// Includes: Sign Test, WRS Test, and Multi-Hot-Spot EMC Evaluation
// ==============================================================================

// --- HELPER: Unity Rule Warning Banner ---
const UnityRuleInfo = () => (
    <div className="mt-2 p-3 bg-blue-50 dark:bg-blue-900/30 border-l-4 border-blue-500 rounded text-sm text-blue-800 dark:text-blue-200 animate-fade-in">
        <p className="font-bold flex items-center gap-2">
            <Icon path={ICONS.info} className="w-4 h-4" />
            Input Requirement: Sum of Fractions (SOF)
        </p>
        <p className="mt-1 text-xs opacity-90">
            When applying the Unity Rule, <strong>DO NOT</strong> enter raw activity (pCi/g). 
            You must pre-calculate the dimensionless Sum of Fractions for each sample 
            (e.g., <span className="font-mono">Conc A/Limit A + Conc B/Limit B...</span>) and enter that single number here.
            The test compares your SOF values against 1.0.
        </p>
    </div>
);

// 1. SIGN TEST CALCULATOR
const SignTest_Calculator = ({ dcgl, setDcgl, dataInput, setDataInput, alpha, setAlpha, subtractBkg, setSubtractBkg, background, setBackground, result, setResult, error, setError }) => {
    const { addHistory } = useCalculationHistory();
    const { addToast } = useToast();
    
    // Unity Rule State
    const [useUnityRule, setUseUnityRule] = React.useState(false);

    React.useEffect(() => {
        if (useUnityRule) setDcgl('1.0');
    }, [useUnityRule, setDcgl]);

    // Critical Values Lookup (MARSSIM Table I.3)
    const signTestCriticalValues = {
        '0.05': { 5: 5, 6: 6, 7: 7, 8: 7, 9: 8, 10: 8, 11: 9, 12: 10, 13: 11, 14: 11, 15: 12, 16: 12, 17: 13, 18: 14, 19: 14, 20: 15, 21: 16, 22: 16, 23: 17, 24: 17, 25: 18, 26: 19, 27: 19, 28: 20, 29: 21, 30: 21 },
        '0.025': { 5: 5, 6: 6, 7: 7, 8: 8, 9: 8, 10: 9, 11: 10, 12: 10, 13: 11, 14: 12, 15: 12, 16: 13, 17: 14, 18: 14, 19: 15, 20: 15, 21: 16, 22: 17, 23: 17, 24: 18, 25: 19, 26: 19, 27: 20, 28: 20, 29: 21, 30: 22 },
        '0.01': { 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 9, 11: 10, 12: 11, 13: 11, 14: 12, 15: 13, 16: 13, 17: 14, 18: 15, 19: 15, 20: 16, 21: 17, 22: 17, 23: 18, 24: 18, 25: 19, 26: 20, 27: 20, 28: 21, 29: 22, 30: 22 },
        '0.10': { 5: 4, 6: 5, 7: 6, 8: 6, 9: 7, 10: 8, 11: 8, 12: 9, 13: 10, 14: 10, 15: 11, 16: 11, 17: 12, 18: 13, 19: 13, 20: 14, 21: 15, 22: 15, 23: 16, 24: 16, 25: 17, 26: 18, 27: 18, 28: 19, 29: 20, 30: 20 }
    };
    const zScores = { '0.05': 1.645, '0.025': 1.960, '0.01': 2.326, '0.10': 1.282 };
    
    const parseData = (dataString) => dataString.split(/[\s,;\n]+/).filter(d => d.trim() !== '' && !isNaN(d)).map(Number);
    
    const getStats = (data) => {
        if (!data.length) return null;
        const max = Math.max(...data);
        const mean = data.reduce((a, b) => a + b, 0) / data.length;
        return { max, mean };
    };
    
    const handleCalculate = () => {
        setResult(null); setError('');
        const rawChunks = dataInput.split(/[\s,;\n]+/).filter(d => d.trim() !== '');
        let measurements = rawChunks.map(Number).filter(n => !isNaN(n));
        const droppedCount = rawChunks.length - measurements.length;
        const dcgl_val = parseFloat(dcgl);
        const bkg_val = parseFloat(background);
        
        if (isNaN(dcgl_val) || dcgl_val <= 0) { setError('DCGL must be a valid positive number.'); return; }
        if (measurements.length === 0) { setError('Please enter measurement data.'); return; }
        
        if (subtractBkg && !useUnityRule) {
            if (isNaN(bkg_val)) { setError('Please enter a valid background value.'); return; }
            measurements = measurements.map(m => m - bkg_val);
        }
        
        const epsilon = 1e-9;
        const validData = measurements.filter(val => Math.abs(dcgl_val - val) > epsilon);
        const n_adjusted = validData.length;
        const ties = measurements.length - n_adjusted;
        
        if (n_adjusted === 0) { setError('All data points are equal to the DCGL; the test cannot be performed.'); return; }
        
        const S_plus = validData.filter(val => (dcgl_val - val) > 0).length;
        let Cs; let note = '';
        const tableValue = signTestCriticalValues[alpha]?.[n_adjusted];
        
        if (tableValue !== undefined) {
            Cs = tableValue; note = `Used MARSSIM Table I.3 for N=${n_adjusted}.`;
        } else {
            const zAlpha = zScores[alpha];
            Cs = Math.ceil((n_adjusted / 2) + (zAlpha * Math.sqrt(n_adjusted) / 2));
            note = `Used Large Sample Approximation for N=${n_adjusted}.`;
        }
        
        const testPassed = S_plus >= Cs;
        
        setResult({
            conclusion: testPassed ? 'PASS' : 'FAIL',
            reason: `S+ (${S_plus}) is ${testPassed ? '≥' : '<'} Critical Value (${Cs}).`,
            n: measurements.length,
            n_adjusted, ties, S_plus, Cs, note,
            stats: getStats(measurements),
            dcgl: dcgl_val,
            warning: droppedCount > 0 ? `Warning: ${droppedCount} non-numeric values were ignored.` : null, 
        });
    };
    
    const handleSaveToHistory = () => {
        if (result) {
            addHistory({ id: Date.now(), type: 'Sign Test', icon: ICONS.labStats, inputs: `N=${result.n}, DCGL=${dcgl} ${useUnityRule ? '(Unity Rule)' : ''}`, result: `UNIT ${result.conclusion}ES`, view: VIEWS.MARSSIM_TESTS });
            addToast("Saved to history!");
        }
    };
    
    React.useEffect(() => { handleCalculate(); }, [dcgl, dataInput, alpha, subtractBkg, background, useUnityRule]);
    
    return (
        <div className="space-y-4">
            <div className="p-4 bg-sky-50 dark:bg-sky-900/20 border border-sky-200 dark:border-sky-800 rounded-lg text-sm text-sky-800 dark:text-sky-200">
                <strong>Applicability:</strong> Use when contaminant is <em>not</em> present in background (Class 1/2/3).
            </div>
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                <label className="flex items-center gap-2 font-bold text-sm text-sky-600 dark:text-sky-400 cursor-pointer">
                    <input type="checkbox" checked={useUnityRule} onChange={e => setUseUnityRule(e.target.checked)} className="form-checkbox h-4 w-4 rounded text-sky-600" />
                    Apply Unity Rule (Sum of Fractions)
                </label>
                {useUnityRule && <UnityRuleInfo />}

                <div className="grid grid-cols-2 gap-4">
                    <div>
                        <label className="block text-sm font-medium">{useUnityRule ? "DCGL (Unity Limit)" : "DCGL (Activity Limit)"}</label>
                        <input type="number" value={dcgl} onChange={e => setDcgl(e.target.value)} disabled={useUnityRule} className={`w-full mt-1 p-2 rounded-md border ${useUnityRule ? 'bg-slate-200 text-slate-500' : 'bg-slate-100'} dark:bg-slate-700 dark:border-slate-600`}/>
                    </div>
                    <div>
                        <label className="block text-sm font-medium">Alpha (&alpha;)</label>
                        <select value={alpha} onChange={e => setAlpha(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 dark:border-slate-600">
                            <option value="0.05">0.05</option><option value="0.025">0.025</option><option value="0.01">0.01</option><option value="0.10">0.10</option>
                        </select>
                    </div>
                </div>
                
                <div>
                    <div className="flex justify-between items-center mb-1">
                        <label className={`flex items-center gap-2 text-sm font-medium cursor-pointer ${useUnityRule ? 'opacity-50 cursor-not-allowed' : ''}`}>
                            <input type="checkbox" checked={subtractBkg} onChange={e => setSubtractBkg(e.target.checked)} disabled={useUnityRule} className="form-checkbox h-4 w-4 text-sky-600 rounded" />
                            Subtract Instrument Background?
                        </label>
                        {subtractBkg && !useUnityRule && <input type="number" value={background} onChange={e => setBackground(e.target.value)} placeholder="Bkg" className="w-24 p-1 text-sm rounded bg-slate-100 dark:bg-slate-700 border" />}
                    </div>
                    <label className="block text-sm font-medium mt-2">Survey Measurements <span className="text-xs text-slate-500">{useUnityRule ? '(Unitless SOF)' : '(pCi/g)'}</span></label>
                    <textarea value={dataInput} onChange={e => setDataInput(e.target.value)} rows="6" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-mono text-sm" placeholder="Paste values..."></textarea>
                    <p className="text-right text-xs font-semibold text-slate-500 mt-1 pr-1">N: {parseData(dataInput).length}</p>
                </div>
            </div>
            
            <button onClick={handleSaveToHistory} className="w-full py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">Save to Calculations</button>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            
            {result && (
                <div className={`p-4 rounded-lg mt-4 text-center animate-fade-in ${result.conclusion === 'PASS' ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                    <p className={`text-3xl font-extrabold ${result.conclusion === 'PASS' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>UNIT {result.conclusion}ES</p>
                    <p className={`mt-2 text-sm ${result.conclusion === 'PASS' ? 'text-green-800 dark:text-green-200' : 'text-red-800 dark:text-red-200'}`}>{result.reason}</p>
                    <div className="mt-4 px-4">
                        <div className="flex justify-between text-xs font-bold mb-1 opacity-70"><span>0</span><span>Limit</span></div>
                        <div className="h-4 w-full bg-white/50 rounded-full overflow-hidden relative border border-black/10">
                            <div className={`h-full ${result.conclusion === 'FAIL' || result.stats.mean > result.dcgl ? 'bg-red-500' : 'bg-green-500'}`} style={{ width: `${Math.min((result.stats.mean / result.dcgl) * 100, 100)}%` }}></div>
                            <div className="absolute top-0 bottom-0 w-0.5 bg-black" style={{ left: `${Math.min((result.stats.max / result.dcgl) * 100, 100)}%` }} title="Max Value"></div>
                        </div>
                    </div>
                    <div className="mt-4 pt-4 border-t border-slate-300 dark:border-slate-600 grid grid-cols-2 gap-2 text-sm">
                        <p>N: <span className="font-bold">{result.n}</span></p><p>S+: <span className="font-bold">{result.S_plus}</span></p>
                    </div>
                </div>
            )}
        </div>
    );
};

// 2. WRS CALCULATOR
const WRS_Calculator = ({ dcgl, setDcgl, referenceData, setReferenceData, surveyData, setSurveyData, alpha, setAlpha, result, setResult, error, setError }) => {
    const { addHistory } = useCalculationHistory();
    const { addToast } = useToast();
    
    // Unity Rule State
    const [useUnityRule, setUseUnityRule] = React.useState(false);

    React.useEffect(() => {
        if (useUnityRule) setDcgl('1.0');
    }, [useUnityRule, setDcgl]);

    const zScores = { '0.05': 1.645, '0.025': 1.960, '0.01': 2.326, '0.10': 1.282 };
    
    const getStats = (data) => {
        if (!data || data.length === 0) return null;
        const sum = data.reduce((a, b) => a + b, 0);
        const mean = sum / data.length;
        const max = Math.max(...data);
        const min = Math.min(...data);
        const sqDiff = data.map(v => Math.pow(v - mean, 2));
        const avgSqDiff = sqDiff.reduce((a, b) => a + b, 0) / (data.length - 1); 
        const sd = Math.sqrt(avgSqDiff);
        return { mean, max, min, sd };
    };
    
    const handleCalculate = () => {
        setResult(null); setError('');
        
        // Parse Data
        const parse = (s) => s.split(/[\s,;\n]+/).filter(d => d.trim() !== '' && !isNaN(d)).map(Number);
        const refData = parse(referenceData);
        const suData = parse(surveyData);
        const dcgl_val = parseFloat(dcgl);
        
        if (isNaN(dcgl_val)) { setError('DCGL must be a valid number.'); return; }
        if (refData.length < 5 || suData.length < 5) { setError('Need at least 5 data points per area.'); return; }
        
        let combined = [...refData.map(v => ({ value: v + dcgl_val, group: 'ref' })), ...suData.map(v => ({ value: v, group: 'su' }))].sort((a, b) => a.value - b.value);
        
        // Handle Ties
        for (let i = 0; i < combined.length; i++) {
            let ties = [i]; const epsilon = 1e-9;
            while (i + 1 < combined.length && Math.abs(combined[i].value - combined[i + 1].value) < epsilon) { i++; ties.push(i); }
            if (ties.length > 1) { const avgRank = (ties[0] + 1 + ties[ties.length - 1] + 1) / 2; ties.forEach(index => { combined[index].rank = avgRank; }); } else { combined[i].rank = i + 1; }
        }
        
        const W_rs = combined.filter(d => d.group === 'ref').reduce((sum, d) => sum + d.rank, 0);
        const n = refData.length; const m = suData.length; const N = n + m;
        const mean_W = (n * (N + 1)) / 2; 
        
        // Variance with tie correction
        const tieGroups = {};
        combined.forEach(item => { tieGroups[item.value] = (tieGroups[item.value] || 0) + 1; });
        const tieCorrection = Object.values(tieGroups).filter(t => t > 1).reduce((sum, t) => sum + (Math.pow(t, 3) - t), 0);
        const variance_W = ((n * m * (N + 1)) / 12) - ((n * m * tieCorrection) / (12 * N * (N - 1)));
        
        const C_w = Math.round(mean_W + (zScores[alpha] * Math.sqrt(variance_W)) + 0.5); 
        const wrsTestPassed = W_rs >= C_w;
        
        const refStats = getStats(refData);
        const suStats = getStats(suData);
        const hotMeasurements = suData.filter(v => v > (refStats.max + dcgl_val)); 
        
        let warningMsg = null;
        if (refStats.sd > suStats.sd * 1.5) warningMsg = "Note: Ref area variability is significantly higher than Survey Unit.";
        
        setResult({
            conclusion: wrsTestPassed ? 'PASS' : 'FAIL',
            reason: wrsTestPassed ? `Rank Sum (${W_rs}) ≥ Critical Value (${C_w}).` : `Rank Sum (${W_rs}) < Critical Value (${C_w}).`,
            n, m, W_rs, C_w, rankedData: combined, hotCount: hotMeasurements.length, refStats, suStats, warning: warningMsg
        });
    };
    
    const handleSaveToHistory = () => {
        if (result) {
            addHistory({ id: Date.now(), type: 'WRS Test', icon: ICONS.labStats, inputs: `Ref(n)=${result.n}, SU(m)=${result.m}, DCGL=${dcgl} ${useUnityRule ? '(Unity Rule)' : ''}`, result: result.conclusion, view: VIEWS.MARSSIM_TESTS });
            addToast("Saved to history!");
        }
    };
    
    React.useEffect(() => { handleCalculate(); }, [dcgl, referenceData, surveyData, alpha, useUnityRule]);
    
    return (
        <div className="space-y-4">
            <div className="p-4 bg-sky-50 dark:bg-sky-900/20 border border-sky-200 dark:border-sky-800 rounded-lg text-sm text-sky-800 dark:text-sky-200">
                <strong>Applicability:</strong> Use WRS when the contaminant <em>is</em> present in background (Class 1, 2, or 3).
            </div>
            
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                <label className="flex items-center gap-2 font-bold text-sm text-sky-600 dark:text-sky-400 cursor-pointer mb-2">
                    <input type="checkbox" checked={useUnityRule} onChange={e => setUseUnityRule(e.target.checked)} className="form-checkbox h-4 w-4 rounded text-sky-600" />
                    Apply Unity Rule (Sum of Fractions)
                </label>
                {useUnityRule && <UnityRuleInfo />}

                <div className="grid grid-cols-2 gap-4">
                    <div>
                        <label className="block text-sm font-medium">{useUnityRule ? "DCGL (Unity Limit)" : "DCGLw (Limit)"}</label>
                        <input type="number" value={dcgl} onChange={e => setDcgl(e.target.value)} disabled={useUnityRule} className={`w-full mt-1 p-2 rounded-md border ${useUnityRule ? 'bg-slate-200 text-slate-500' : 'bg-slate-100'} dark:bg-slate-700`}/>
                    </div>
                    <div>
                        <label className="block text-sm font-medium">Alpha (&alpha;)</label>
                        <select value={alpha} onChange={e => setAlpha(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"><option value="0.05">0.05</option><option value="0.025">0.025</option><option value="0.01">0.01</option><option value="0.10">0.10</option></select>
                    </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <div className="flex justify-between items-center"><label className="block text-sm font-medium">Reference Area (n)</label><button onClick={() => setReferenceData('')} className="text-xs text-sky-600 dark:text-sky-400 hover:underline">Clear</button></div>
                        <textarea value={referenceData} onChange={e => setReferenceData(e.target.value)} rows="8" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-mono text-sm border border-slate-300 dark:border-slate-600" placeholder="1.2, 1.5..."></textarea>
                    </div>
                    <div>
                        <div className="flex justify-between items-center"><label className="block text-sm font-medium">Survey Unit (m) {useUnityRule ? '(SOF)' : '(pCi/g)'}</label><button onClick={() => setSurveyData('')} className="text-xs text-sky-600 dark:text-sky-400 hover:underline">Clear</button></div>
                        <textarea value={surveyData} onChange={e => setSurveyData(e.target.value)} rows="8" className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-mono text-sm border border-slate-300 dark:border-slate-600" placeholder="2.2, 2.5..."></textarea>
                    </div>
                </div>
            </div>
            
            <button onClick={handleSaveToHistory} className="w-full py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">Save to Calculations</button>
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            
            {result && (
                <div className={`p-4 rounded-lg mt-4 text-center animate-fade-in ${result.conclusion === 'PASS' ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                    <p className={`text-3xl font-extrabold ${result.conclusion === 'PASS' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>UNIT {result.conclusion}ES</p>
                    <p className={`mt-2 text-sm ${result.conclusion === 'PASS' ? 'text-green-800 dark:text-green-200' : 'text-red-800 dark:text-red-200'}`}>{result.reason}</p>
                    <div className="grid grid-cols-2 gap-4 mt-4 text-sm border-t border-slate-300 dark:border-slate-600 pt-2">
                        <p>Rank Sum: <span className="font-bold">{result.W_rs}</span></p><p>Critical: <span className="font-bold">{result.C_w}</span></p>
                        <p>Hot Spots ({'>'}Max Ref): <span className="font-bold">{result.hotCount}</span></p>
                    </div>
                </div>
            )}
        </div>
    );
};

// 3. UPDATED: EMC Evaluation (Multi-Spot Support)
const EMC_Evaluation_Calculator = ({ dcglw, setDcglw, areaFactor, setAreaFactor, avgConc, setAvgConc, maxConc, setMaxConc, result, setResult, error, setError }) => {
    const { addHistory } = useCalculationHistory();
    const { addToast } = useToast();
    
    // Local state for list of hot spots. 
    // We allow the user to input the FIRST one via props/state, then add more to this list.
    const [hotSpots, setHotSpots] = React.useState([{ id: 1, conc: maxConc, af: areaFactor }]);

    // Sync first row with parent props if they change externally (optional, but good for persistence)
    React.useEffect(() => {
        setHotSpots(prev => {
            const newSpots = [...prev];
            if (newSpots[0]) { newSpots[0].conc = maxConc; newSpots[0].af = areaFactor; }
            return newSpots;
        });
    }, [maxConc, areaFactor]);

    const updateSpot = (id, field, val) => {
        setHotSpots(prev => prev.map(s => s.id === id ? { ...s, [field]: val } : s));
        // Also update parent state if it's the first one
        if (id === 1) {
            if (field === 'conc') setMaxConc(val);
            if (field === 'af') setAreaFactor(val);
        }
    };

    const addSpot = () => {
        setHotSpots(prev => [...prev, { id: Date.now(), conc: '', af: '' }]);
    };

    const removeSpot = (id) => {
        if (hotSpots.length === 1) return; // Keep at least one
        setHotSpots(prev => prev.filter(s => s.id !== id));
    };

    const handleCalculate = () => {
        setResult(null); setError('');
        const dcgl = parseFloat(dcglw);
        const avg = parseFloat(avgConc);
        
        if (isNaN(dcgl) || dcgl <= 0) { setError('Invalid DCGLw'); return; }
        if (isNaN(avg) || avg < 0) { setError('Invalid Average Concentration'); return; }

        let totalUnity = avg / dcgl; // Term 1
        let term2Sum = 0;
        let details = [];

        // Term 1 Calculation
        details.push({ type: 'General Area', val: avg, limit: dcgl, fraction: totalUnity });

        for (let spot of hotSpots) {
            const c = parseFloat(spot.conc);
            const af = parseFloat(spot.af);
            if (isNaN(c) || isNaN(af)) continue; // Skip incomplete rows
            
            if (c < avg) { setError('Hot spot concentration cannot be less than average.'); return; }
            
            const dcgl_emc = dcgl * af;
            const term = (c - avg) / dcgl_emc;
            term2Sum += term;
            totalUnity += term;
            
            details.push({ type: 'Hot Spot', val: c, limit: dcgl_emc, fraction: term, af: af });
        }

        setResult({
            pass: totalUnity <= 1,
            totalUnity: totalUnity.toFixed(3),
            generalTerm: (avg/dcgl).toFixed(3),
            hotSpotTerm: term2Sum.toFixed(3),
            details
        });
    };

    const handleSaveToHistory = () => {
        if (result) {
            addHistory({ id: Date.now(), type: 'EMC Eval', icon: ICONS.labStats, inputs: `${hotSpots.length} Hot Spots`, result: result.pass ? 'PASS' : 'FAIL', view: VIEWS.MARSSIM_TESTS });
            addToast("Saved!");
        }
    };

    return (
        <div className="space-y-4">
            <div className="p-4 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg text-sm text-amber-800 dark:text-amber-200">
                <strong>Applicability:</strong> Use this to evaluate specific "hot spots". It ensures that small areas of elevated activity do not exceed the dose limit when averaged with the general area.
            </div>
            
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
                <div className="grid grid-cols-2 gap-4">
                    <div><label className="block text-sm font-medium">DCGL<sub>W</sub></label><input type="number" value={dcglw} onChange={e => setDcglw(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                    <div><label className="block text-sm font-medium">Average Conc.</label><input type="number" value={avgConc} onChange={e => setAvgConc(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700" /></div>
                </div>

                <div className="border-t border-slate-200 dark:border-slate-700 pt-4">
                    <div className="flex justify-between items-center mb-2">
                        <label className="block text-sm font-bold">Hot Spots Identified</label>
                        <button onClick={addSpot} className="text-xs bg-slate-200 dark:bg-slate-700 px-2 py-1 rounded hover:bg-slate-300">+ Add Spot</button>
                    </div>
                    
                    <div className="space-y-2">
                        {hotSpots.map((spot, index) => (
                            <div key={spot.id} className="flex gap-2 items-end">
                                <div className="flex-grow">
                                    <label className="text-xs text-slate-500">Max Conc.</label>
                                    <input type="number" value={spot.conc} onChange={e => updateSpot(spot.id, 'conc', e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 text-sm" />
                                </div>
                                <div className="w-24">
                                    <label className="text-xs text-slate-500">Area Factor</label>
                                    <input type="number" value={spot.af} onChange={e => updateSpot(spot.id, 'af', e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 text-sm" />
                                </div>
                                {hotSpots.length > 1 && (
                                    <button onClick={() => removeSpot(spot.id)} className="p-2 text-red-500 hover:bg-red-50 rounded"><Icon path={ICONS.clear} className="w-4 h-4" /></button>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            
            <button onClick={handleCalculate} className="w-full py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">Calculate EMC</button>
            
            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
            
            {result && (
                <div className={`p-4 rounded-lg mt-4 text-center animate-fade-in ${result.pass ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                    <p className={`text-3xl font-extrabold ${result.pass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>EMC {result.pass ? 'PASSES' : 'FAILS'}</p>
                    <p className="mt-1 font-bold">Total Unity Value: {result.totalUnity}</p>
                    
                    <div className="mt-4 text-sm text-left bg-white dark:bg-slate-800 p-2 rounded shadow-sm">
                        <table className="w-full">
                            <thead><tr className="text-xs text-slate-500 border-b"><th className="pb-1">Source</th><th className="pb-1 text-right">Value</th><th className="pb-1 text-right">Limit</th><th className="pb-1 text-right">Fraction</th></tr></thead>
                            <tbody>
                                {result.details.map((d, i) => (
                                    <tr key={i} className="border-b border-slate-100 dark:border-slate-700">
                                        <td className="py-1">{d.type} {d.af ? `(AF=${d.af})` : ''}</td>
                                        <td className="py-1 text-right font-mono">{d.val}</td>
                                        <td className="py-1 text-right font-mono">{d.limit}</td>
                                        <td className="py-1 text-right font-bold font-mono">{d.fraction.toFixed(3)}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            )}
        </div>
    );
};

// 4. MAIN CONTAINER: MARSSIM Tests
const MARSSIM_Statistical_Tests = () => {
    const TEST_WRS = 'wrs';
    const TEST_SIGN = 'sign';
    const TEST_EMC_EVAL = 'emc_eval';
    const [activeTest, setActiveTest] = React.useState(TEST_WRS);
    
    // WRS State
    const [wrs_dcgl, setWrs_dcgl] = React.useState(() => localStorage.getItem('wrs_dcgl') || '5');
    const [wrs_referenceData, setWrs_referenceData] = React.useState(() => localStorage.getItem('wrs_referenceData') || '1.6\n1.2\n1.4\n1.2\n0.5\n1.5\n0.8\n1.1\n1.9\n1.7\n1.8\n1.8\n1.7\n1.9\n2.1\n1.8\n2.1\n2.4\n2.2\n2.9\n2\n1.7\n2.3\n1.1\n2.3\n0.6\n1.1\n1.1\n1.4\n2.1');
    const [wrs_surveyData, setWrs_surveyData] = React.useState(() => localStorage.getItem('wrs_surveyData') || '2.928\n3.458\n3.31\n3.198\n2.218\n6.827\n2.269\n4.96\n2.766\n3.29\n10.833\n1.606\n1.856\n3.135\n1.808\n1.873\n3.373\n1.887\n1.457\n5.5\n1.973\n1.915\n2.205\n1.814\n3.7\n2.327\n1.919\n2.677\n3.253\n1.776\n5.201\n4.737\n2.585');
    const [wrs_alpha, setWrs_alpha] = React.useState(() => localStorage.getItem('wrs_alpha') || '0.05');
    const [wrs_result, setWrs_result] = React.useState(null);
    const [wrs_error, setWrs_error] = React.useState('');
    
    // Sign Test State
    const [sign_dcgl, setSign_dcgl] = React.useState(() => localStorage.getItem('sign_dcgl') || '100');
    const [sign_data, setSign_data] = React.useState(() => localStorage.getItem('sign_data') || '120, 90, 95, 80, 85, 110, 95, 70');
    const [sign_alpha, setSign_alpha] = React.useState(() => localStorage.getItem('sign_alpha') || '0.05');
    const [sign_subtractBkg, setSign_subtractBkg] = React.useState(() => JSON.parse(localStorage.getItem('sign_subtractBkg')) || false);
    const [sign_background, setSign_background] = React.useState(() => localStorage.getItem('sign_background') || '0');
    
    const [sign_result, setSign_result] = React.useState(null);
    const [sign_error, setSign_error] = React.useState('');
    
    // Persistence for new Sign Test fields
    React.useEffect(() => {
        localStorage.setItem('sign_subtractBkg', JSON.stringify(sign_subtractBkg));
        localStorage.setItem('sign_background', sign_background);
    }, [sign_subtractBkg, sign_background]);
    
    // EMC Evaluation State
    const [emc_dcglw, setEmc_dcglw] = React.useState(() => localStorage.getItem('emcEval_dcglw') || '100');
    const [emc_areaFactor, setEmc_areaFactor] = React.useState(() => localStorage.getItem('emcEval_areaFactor') || '3.0');
    const [emc_avgConc, setEmc_avgConc] = React.useState(() => localStorage.getItem('emcEval_avgConc') || '40');
    const [emc_maxConc, setEmc_maxConc] = React.useState(() => localStorage.getItem('emcEval_maxConc') || '150');
    const [emc_result, setEmc_result] = React.useState(null);
    const [emc_error, setEmc_error] = React.useState('');
    
    const handleClearActiveCalculator = () => {
        if (activeTest === TEST_WRS) {
            setWrs_dcgl('5'); setWrs_referenceData(''); setWrs_surveyData(''); setWrs_result(null); setWrs_error('');
            ['wrs_dcgl', 'wrs_referenceData', 'wrs_surveyData', 'wrs_alpha'].forEach(k => localStorage.removeItem(k));
        } else if (activeTest === TEST_SIGN) {
            setSign_dcgl('100'); setSign_data(''); setSign_result(null); setSign_error(''); setSign_subtractBkg(false); setSign_background('0');
            ['sign_dcgl', 'sign_data', 'sign_alpha', 'sign_subtractBkg', 'sign_background'].forEach(k => localStorage.removeItem(k));
        } else {
            setEmc_dcglw('100'); setEmc_areaFactor('3.0'); setEmc_avgConc('40'); setEmc_maxConc('150'); setEmc_result(null); setEmc_error('');
            ['emcEval_dcglw', 'emcEval_areaFactor', 'emcEval_avgConc', 'emcEval_maxConc'].forEach(k => localStorage.removeItem(k));
        }
    };
    
    return (
        <div className="p-4 animate-fade-in">
            <div className="max-w-2xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-slate-800 dark:text-white">MARSSIM Statistical Tests</h2>
                    <ClearButton onClick={handleClearActiveCalculator} />
                </div>
                
                <div className="flex w-full p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-4">
                    <button onClick={() => setActiveTest(TEST_WRS)} className={`flex-1 p-2 rounded-md text-xs sm:text-sm font-semibold transition-colors ${activeTest === TEST_WRS ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>WRS Test</button>
                    <button onClick={() => setActiveTest(TEST_SIGN)} className={`flex-1 p-2 rounded-md text-xs sm:text-sm font-semibold transition-colors ${activeTest === TEST_SIGN ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>Sign Test</button>
                    <button onClick={() => setActiveTest(TEST_EMC_EVAL)} className={`flex-1 p-2 rounded-md text-xs sm:text-sm font-semibold transition-colors ${activeTest === TEST_EMC_EVAL ? 'bg-white dark:bg-slate-800 text-sky-600' : 'text-slate-600 dark:text-slate-300'}`}>EMC Eval</button>
                </div>
                
                {activeTest === TEST_WRS && (
                    <WRS_Calculator
                        dcgl={wrs_dcgl} setDcgl={setWrs_dcgl}
                        referenceData={wrs_referenceData} setReferenceData={setWrs_referenceData}
                        surveyData={wrs_surveyData} setSurveyData={setWrs_surveyData}
                        alpha={wrs_alpha} setAlpha={setWrs_alpha}
                        result={wrs_result} setResult={setWrs_result}
                        error={wrs_error} setError={setWrs_error}
                    />
                )}
                {activeTest === TEST_SIGN && (
                    <SignTest_Calculator
                        dcgl={sign_dcgl} setDcgl={setSign_dcgl}
                        dataInput={sign_data} setDataInput={setSign_data}
                        alpha={sign_alpha} setAlpha={setSign_alpha}
                        subtractBkg={sign_subtractBkg} setSubtractBkg={setSign_subtractBkg}
                        background={sign_background} setBackground={setSign_background}
                        result={sign_result} setResult={setSign_result}
                        error={sign_error} setError={setSign_error}
                    />
                )}
                {activeTest === TEST_EMC_EVAL && (
                    <EMC_Evaluation_Calculator
                        dcglw={emc_dcglw} setDcglw={setEmc_dcglw}
                        areaFactor={emc_areaFactor} setAreaFactor={setEmc_areaFactor}
                        avgConc={emc_avgConc} setAvgConc={setEmc_avgConc}
                        maxConc={emc_maxConc} setMaxConc={setEmc_maxConc}
                        result={emc_result} setResult={setEmc_result}
                        error={emc_error} setError={setEmc_error}
                    />
                )}
            </div>
        </div>
    );
};
            
            // 1. NEW: MDA Calculator (Currie Equation)
            const MdaCalculator = ({ bkgCounts, setBkgCounts, countTime, setCountTime, bkgTime, setBkgTime, efficiency, setEfficiency, effUnit, setEffUnit, probeArea, setProbeArea, result, setResult }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            React.useEffect(() => {
            try {
            const Rb = parseFloat(bkgCounts) / parseFloat(bkgTime); // Rate Bkg
            const Ts = parseFloat(countTime);
            const Tb = parseFloat(bkgTime);
            const effVal = parseFloat(efficiency);
            const area = parseFloat(probeArea);
            
            if (isNaN(Rb) || isNaN(Ts) || isNaN(Tb) || isNaN(effVal) || Ts <= 0 || Tb <= 0) { setResult(null); return; }
            
            // Efficiency -> Decimal
            const effDec = effUnit === '%' ? effVal / 100 : effVal;
            if (effDec <= 0) { setResult(null); return; }
            
            // Currie Equation (Paired vs Unpaired)
            // Lc = Critical Level (Is it real?)
            // Ld = Detection Limit (Can I see it?)
            let Lc, Ld;
            
            if (Math.abs(Ts - Tb) < 0.01) {
              // Paired Observations (Ts = Tb) -> Simplified Currie
              // Ld = 2.71 + 4.65 * sqrt(BkgCounts)
              const B = Rb * Tb;
              Lc = 2.33 * Math.sqrt(B);
              Ld = 2.71 + 4.65 * Math.sqrt(B);
            } else {
              // Unpaired (Different times) -> NUREG-1507 exact formulation
              // Ld (rate) = (2.71/Ts) + 3.29 * sqrt( Rb * (1/Ts + 1/Tb) )
              const term1 = 2.71 / Ts;
              const term2 = 3.29 * Math.sqrt(Rb * (1/Ts + 1/Tb));
              const Ld_rate = term1 + term2;
              Ld = Ld_rate * Ts; // Convert back to counts for display consistency
            
              // Lc (rate) = 1.645 * sqrt( Rb * (1/Ts + 1/Tb) )
              const Lc_rate = 1.645 * Math.sqrt(Rb * (1/Ts + 1/Tb));
              Lc = Lc_rate * Ts;
            }
            
            // Calculate MDA (Activity)
            // MDA = Ld / (T * Eff * Yield * 2.22) -> Yield assumed 1 for now
            // Result in dpm = Ld / (T * Eff) if T is min
            const Ld_rate_cpm = Ld / Ts;
            const mda_dpm = Ld_rate_cpm / effDec;
            const mda_pCi = mda_dpm / 2.22;
            const mdc_dpm_100cm2 = (mda_dpm / area) * 100;
            
            setResult({ Lc: Math.round(Lc), Ld: Math.round(Ld), mda_dpm, mda_pCi, mdc: mdc_dpm_100cm2 });
            
            } catch (e) { setResult(null); }
            }, [bkgCounts, countTime, bkgTime, efficiency, effUnit, probeArea]);
            
            const handleSave = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'MDA Calc', icon: ICONS.microscope, inputs: `Bkg: ${bkgCounts}c/${bkgTime}m`, result: `MDA: ${result.mda_dpm.toFixed(1)} dpm`, view: VIEWS.LAB_STATS });
            addToast("Saved!");
            }
            };
            
            return (
            <div className="space-y-4">
            <ContextualNote type="info"><strong>Currie Equation:</strong> Calculates the <i>a priori</i> detection limit (Ld) ensuring 95% confidence of detection.</ContextualNote>
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
              <div className="grid grid-cols-2 gap-4">
                  <div><label className="block text-sm font-medium">Bkg Counts</label><input type="number" value={bkgCounts} onChange={e => setBkgCounts(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  <div><label className="block text-sm font-medium">Bkg Time (min)</label><input type="number" value={bkgTime} onChange={e => setBkgTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                  <div><label className="block text-sm font-medium">Sample Time (min)</label><input type="number" value={countTime} onChange={e => setCountTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
                  <div>
                      <label className="block text-sm font-medium">Efficiency</label>
                      <div className="flex">
                          <input type="number" value={efficiency} onChange={e => setEfficiency(e.target.value)} className="w-full mt-1 p-2 rounded-l-md bg-slate-100 dark:bg-slate-700"/>
                          <select value={effUnit} onChange={e => setEffUnit(e.target.value)} className="mt-1 p-2 rounded-r-md bg-slate-200 dark:bg-slate-600 text-xs"><option>%</option><option>dec</option></select>
                      </div>
                  </div>
              </div>
              <div><label className="block text-sm font-medium">Probe Area (cm²) <span className="text-xs text-slate-400 font-normal">(For MDC)</span></label><input type="number" value={probeArea} onChange={e => setProbeArea(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            </div>
            
            {result && (
              <div className="mt-4 p-5 bg-slate-100 dark:bg-slate-700 rounded-lg animate-fade-in shadow-sm">
                  <div className="flex justify-end -mt-3 -mr-3 mb-2"><button onClick={handleSave} className="text-slate-400 hover:text-sky-600"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></div>
            
                  <div className="text-center mb-4">
                      <p className="text-xs uppercase font-bold text-slate-500">Minimum Detectable Activity</p>
                      <div className="flex items-center justify-center gap-2">
                          <span className="text-3xl font-extrabold text-sky-600 dark:text-sky-400">{result.mda_dpm.toFixed(1)}</span>
                          <span className="text-lg font-semibold text-slate-600 dark:text-slate-300">dpm</span>
                      </div>
                      <p className="text-xs text-slate-500">({result.mda_pCi.toFixed(2)} pCi)</p>
                  </div>
            
                  <div className="grid grid-cols-2 gap-4 text-center border-t border-slate-200 dark:border-slate-600 pt-4">
                      <div>
                          <p className="text-xs text-slate-500">Critical Level (Lc)</p>
                          <p className="font-mono font-bold">{result.Lc} counts</p>
                      </div>
                      <div>
                          <p className="text-xs text-slate-500">Detection Limit (Ld)</p>
                          <p className="font-mono font-bold">{result.Ld} counts</p>
                      </div>
                  </div>
                  <div className="mt-3 pt-3 border-t border-slate-200 dark:border-slate-600 text-center">
                      <p className="text-xs text-slate-500">Surface MDC</p>
                      <p className="font-bold text-slate-700 dark:text-slate-200">{result.mdc.toFixed(0)} dpm/100cm²</p>
                  </div>
              </div>
            )}
            </div>
            );
            };
            
            // 2. UPDATED: ChiSquaredCalculator (Visual Polish)
            const ChiSquaredCalculator = ({ chiSquaredData, setChiSquaredData, alpha, setAlpha, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            // (Keep your existing CRITICAL_VALUES and UPPER_BOUNDS constants here...)
            const CHI_SQUARED_CRITICAL_VALUES = { '0.10': { lowerP: 0.05, upperP: 0.95, 1: 0.004, 2: 0.103, 3: 0.352, 4: 0.711, 5: 1.145, 6: 1.635, 7: 2.167, 8: 2.733, 9: 3.325, 10: 3.940, 11: 4.575, 12: 5.226, 13: 5.892, 14: 6.571, 15: 7.261, 16: 7.962, 17: 8.672, 18: 9.390, 19: 10.117, 20: 10.851, 21: 11.591, 22: 12.338, 23: 13.091, 24: 13.848, 25: 14.611, 26: 15.379, 27: 16.151, 28: 16.928, 29: 17.708, 30: 18.493, 40: 26.509 }, '0.05': { lowerP: 0.025, upperP: 0.975, 1: 0.001, 2: 0.051, 3: 0.216, 4: 0.484, 5: 0.831, 6: 1.237, 7: 1.690, 8: 2.180, 9: 2.700, 10: 3.247, 11: 3.816, 12: 4.404, 13: 5.009, 14: 5.629, 15: 6.262, 16: 6.908, 17: 7.564, 18: 8.231, 19: 8.907, 20: 9.591, 21: 10.283, 22: 10.982, 23: 11.689, 24: 12.401, 25: 13.120, 26: 13.844, 27: 14.573, 28: 15.308, 29: 16.047, 30: 16.791, 40: 24.433 }, '0.01': { lowerP: 0.005, upperP: 0.995, 1: 0.000, 2: 0.010, 3: 0.072, 4: 0.207, 5: 0.412, 6: 0.676, 7: 0.989, 8: 1.344, 9: 1.735, 10: 2.156, 11: 2.603, 12: 3.074, 13: 3.565, 14: 4.075, 15: 4.601, 16: 5.142, 17: 5.697, 18: 6.265, 19: 6.844, 20: 7.434, 21: 8.034, 22: 8.643, 23: 9.260, 24: 9.886, 25: 10.520, 26: 11.160, 27: 11.808, 28: 12.461, 29: 13.121, 30: 13.787, 40: 20.707 } };
            const UPPER_BOUNDS = { '0.10': { 1: 3.841, 2: 5.991, 3: 7.815, 4: 9.488, 5: 11.070, 6: 12.592, 7: 14.067, 8: 15.507, 9: 16.919, 10: 18.307, 11: 19.675, 12: 21.026, 13: 22.362, 14: 23.685, 15: 24.996, 16: 26.296, 17: 27.587, 18: 28.869, 19: 30.144, 20: 31.410, 21: 32.671, 22: 33.924, 23: 35.172, 24: 36.415, 25: 37.652, 26: 38.885, 27: 40.113, 28: 41.337, 29: 42.557, 30: 43.773, 40: 55.758 }, '0.05': { 1: 5.024, 2: 7.378, 3: 9.348, 4: 11.143, 5: 12.833, 6: 14.449, 7: 16.013, 8: 17.535, 9: 19.023, 10: 20.483, 11: 21.920, 12: 23.337, 13: 24.736, 14: 26.119, 15: 27.488, 16: 28.845, 17: 30.191, 18: 31.526, 19: 32.852, 20: 34.170, 21: 35.479, 22: 36.781, 23: 38.076, 24: 39.364, 25: 40.646, 26: 41.923, 27: 43.195, 28: 44.461, 29: 45.722, 30: 46.979, 40: 59.342 }, '0.01': { 1: 7.879, 2: 10.597, 3: 12.838, 4: 14.860, 5: 16.750, 6: 18.548, 7: 20.278, 8: 21.955, 9: 23.589, 10: 25.188, 11: 26.757, 12: 28.300, 13: 29.819, 14: 31.319, 15: 32.801, 16: 34.267, 17: 35.718, 18: 37.156, 19: 38.582, 20: 39.997, 21: 41.401, 22: 42.796, 23: 44.181, 24: 45.559, 25: 46.928, 26: 48.290, 27: 49.645, 28: 50.993, 29: 52.336, 30: 53.672, 40: 66.766 } };
            
            React.useEffect(() => {
            try {
            setError('');
            const dataPoints = chiSquaredData.split(/[\s,]+/).filter(v => v.trim() !== '').map(Number);
            if (dataPoints.some(isNaN)) { if (chiSquaredData.trim().length > 0) setError("Data contains non-numeric values."); setResult(null); return; }
            
            const n = dataPoints.length;
            if (n < 2) { setResult(null); return; }
            
            const mean = dataPoints.reduce((sum, val) => sum + val, 0) / n;
            const chiSquared = dataPoints.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / mean;
            const df = n - 1;
            
            let lowerCrit, upperCrit;
            const tableRow = CHI_SQUARED_CRITICAL_VALUES?.[alpha];
            if (tableRow && tableRow[df] !== undefined) {
              if (Array.isArray(tableRow[df])) [lowerCrit, upperCrit] = tableRow[df];
              else { lowerCrit = tableRow[df]; upperCrit = UPPER_BOUNDS[alpha][df] || Infinity; } // Handle your logic
            } else {
              // Wilson-Hilferty approx
              const zScoreMap = { '0.10': 1.645, '0.05': 1.960, '0.01': 2.576 };
              const z = zScoreMap[alpha];
              const term1 = 2 / (9 * df);
              lowerCrit = df * Math.pow(1 - term1 - z * Math.sqrt(term1), 3);
              upperCrit = df * Math.pow(1 - term1 + z * Math.sqrt(term1), 3);
            }
            
            const pass = chiSquared >= lowerCrit && chiSquared <= upperCrit;
            setResult({ n, df, mean: mean.toFixed(2), chiSquared: chiSquared.toFixed(4), lowerBound: lowerCrit.toFixed(3), upperBound: upperCrit.toFixed(3), conclusion: pass ? 'PASS' : 'FAIL' });
            } catch (e) { setError("Calculation Error"); setResult(null); }
            }, [chiSquaredData, alpha]);
            
            const handleSave = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'χ² Test', icon: ICONS.labStats, inputs: `N=${result.n}, α=${alpha}`, result: `χ²=${result.chiSquared} (${result.conclusion})`, view: VIEWS.LAB_STATS });
            addToast("Saved!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="p-4 border border-slate-200 dark:border-slate-700 rounded-lg space-y-4">
              <div><label className="block text-sm font-medium">Count Data</label><textarea value={chiSquaredData} onChange={e => setChiSquaredData(e.target.value)} rows="5" className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700 font-mono text-sm" placeholder="Paste counts..."></textarea></div>
              <div><label className="block text-sm font-medium">Significance Level (α)</label><select value={alpha} onChange={e => setAlpha(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"><option value="0.10">0.10 (90%)</option><option value="0.05">0.05 (95%)</option><option value="0.01">0.01 (99%)</option></select></div>
            </div>
            
            {result && (
              <div className={`p-5 rounded-lg mt-4 text-center animate-fade-in shadow-sm ${result.conclusion === 'PASS' ? 'bg-green-100 dark:bg-green-900/50' : 'bg-red-100 dark:bg-red-900/50'}`}>
                  <div className="flex justify-end -mt-3 -mr-3 mb-1"><button onClick={handleSave} className="text-slate-500 hover:text-black dark:hover:text-white"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></div>
                  <p className={`text-3xl font-extrabold ${result.conclusion === 'PASS' ? 'text-green-700 dark:text-green-300' : 'text-red-700 dark:text-red-300'}`}>SYSTEM {result.conclusion}ES</p>
                  <div className="mt-4 grid grid-cols-3 gap-2 text-sm border-t border-black/10 pt-4">
                      <div><p className="text-xs text-slate-500">Lower Limit</p><p className="font-mono font-bold">{result.lowerBound}</p></div>
                      <div><p className="text-xs text-slate-500">Calculated χ²</p><p className="font-mono font-bold text-lg">{result.chiSquared}</p></div>
                      <div><p className="text-xs text-slate-500">Upper Limit</p><p className="font-mono font-bold">{result.upperBound}</p></div>
                  </div>
              </div>
            )}
            </div>
            );
            };
            
            // 3. UPDATED: DeadTimeCorrector (Visual Polish)
            const DeadTimeCorrector = ({ observedCpm, setObservedCpm, deadTime, setDeadTime, result, setResult, error, setError }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            React.useEffect(() => {
            try {
            setError('');
            const R = parseFloat(observedCpm); const tau = parseFloat(deadTime);
            if (isNaN(R) || isNaN(tau) || R < 0 || tau < 0) { setResult(null); return; }
            
            const R_cps = R / 60.0;
            const tau_s = tau / 1e6;
            const denom = 1 - (R_cps * tau_s);
            if (denom <= 0) throw new Error("Detector Saturated!");
            
            const N_cpm = (R_cps / denom) * 60;
            setResult({ trueCpm: N_cpm, loss: (1 - R/N_cpm)*100 });
            } catch(e) { setError(e.message); setResult(null); }
            }, [observedCpm, deadTime]);
            
            const handleSave = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Dead Time', icon: ICONS.stopwatch, inputs: `Obs: ${observedCpm}, τ: ${deadTime}µs`, result: `True: ${Math.round(result.trueCpm)} cpm`, view: VIEWS.LAB_STATS });
            addToast("Saved!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="grid grid-cols-2 gap-4 p-4 border border-slate-200 dark:border-slate-700 rounded-lg">
              <div><label className="block text-sm font-medium">Observed CPM</label><input type="number" value={observedCpm} onChange={e => setObservedCpm(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
              <div><label className="block text-sm font-medium">Dead Time (µs)</label><input type="number" value={deadTime} onChange={e => setDeadTime(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            </div>
            {error && <p className="text-red-500 text-center text-sm">{error}</p>}
            {result && (
              <div className="mt-4 p-5 bg-slate-100 dark:bg-slate-700 rounded-lg text-center shadow-sm">
                  <div className="flex justify-end -mt-3 -mr-3 mb-2"><button onClick={handleSave} className="text-slate-400 hover:text-sky-600"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></div>
                  <p className="text-xs uppercase font-bold text-slate-500">True Count Rate</p>
                  <p className="text-3xl font-extrabold text-sky-600 dark:text-sky-400 my-1">{Math.round(result.trueCpm).toLocaleString()}</p>
                  <p className="text-sm text-slate-500 font-medium">cpm</p>
                  <div className="mt-3 pt-3 border-t border-slate-200 dark:border-slate-600">
                      <p className={`font-bold ${result.loss > 10 ? 'text-amber-500' : 'text-slate-600 dark:text-slate-300'}`}>{result.loss.toFixed(2)}% Loss</p>
                  </div>
              </div>
            )}
            </div>
            );
            };
            
            // 4. UPDATED: RpdCalculator (Visual Polish)
            const RpdCalculator = ({ sample1, setSample1, sample2, setSample2, result, setResult }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            React.useEffect(() => {
            const s1 = parseFloat(sample1); const s2 = parseFloat(sample2);
            if (!isNaN(s1) && !isNaN(s2) && (s1+s2 > 0)) {
            const rpd = Math.abs(s1 - s2) / ((s1 + s2)/2) * 100;
            setResult({ rpd: rpd.toFixed(2), pass: rpd <= 20 });
            } else { setResult(null); }
            }, [sample1, sample2]);
            
            const handleSave = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'RPD', icon: ICONS.compare, inputs: `${sample1} vs ${sample2}`, result: `${result.rpd}%`, view: VIEWS.LAB_STATS });
            addToast("Saved!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="grid grid-cols-2 gap-4 p-4 border border-slate-200 dark:border-slate-700 rounded-lg">
              <div><label className="block text-sm font-medium">Sample 1</label><input type="number" value={sample1} onChange={e => setSample1(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
              <div><label className="block text-sm font-medium">Sample 2</label><input type="number" value={sample2} onChange={e => setSample2(e.target.value)} className="w-full mt-1 p-2 rounded-md bg-slate-100 dark:bg-slate-700"/></div>
            </div>
            {result && (
              <div className="mt-4 p-5 bg-slate-100 dark:bg-slate-700 rounded-lg text-center shadow-sm">
                  <div className="flex justify-end -mt-3 -mr-3 mb-2"><button onClick={handleSave} className="text-slate-400 hover:text-sky-600"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></div>
                  <p className="text-xs uppercase font-bold text-slate-500">Relative Percent Difference</p>
                  <p className={`text-4xl font-extrabold my-2 ${result.pass ? 'text-sky-600 dark:text-sky-400' : 'text-amber-500'}`}>{result.rpd}%</p>
                  {result.pass ? <p className="text-green-600 font-bold text-sm">Acceptable (≤ 20%)</p> : <p className="text-amber-600 font-bold text-sm">Investigate (&gt; 20%)</p>}
              </div>
            )}
            </div>
            );
            };
            
            // 5. UPDATED: FwhmCalculator (Visual Polish)
            const FwhmCalculator = ({ centroid, setCentroid, lower, setLower, upper, setUpper, result, setResult }) => {
            const { addHistory } = useCalculationHistory();
            const { addToast } = useToast();
            
            React.useEffect(() => {
            const c = parseFloat(centroid); const l = parseFloat(lower); const u = parseFloat(upper);
            if (!isNaN(c) && !isNaN(l) && !isNaN(u) && c > 0) {
            const fwhm = u - l;
            setResult({ fwhm: fwhm.toFixed(2), res: (fwhm/c)*100 });
            } else { setResult(null); }
            }, [centroid, lower, upper]);
            
            const handleSave = () => {
            if (result) {
            addHistory({ id: Date.now(), type: 'Resolution', icon: ICONS.gammaSpec, inputs: `Peak: ${centroid}`, result: `${result.res.toFixed(2)}%`, view: VIEWS.LAB_STATS });
            addToast("Saved!");
            }
            };
            
            return (
            <div className="space-y-4">
            <div className="grid grid-cols-3 gap-2 p-4 border border-slate-200 dark:border-slate-700 rounded-lg">
              <div><label className="block text-xs font-bold mb-1">Centroid</label><input type="number" value={centroid} onChange={e => setCentroid(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
              <div><label className="block text-xs font-bold mb-1">Lower ½</label><input type="number" value={lower} onChange={e => setLower(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
              <div><label className="block text-xs font-bold mb-1">Upper ½</label><input type="number" value={upper} onChange={e => setUpper(e.target.value)} className="w-full p-2 rounded-md bg-slate-100 dark:bg-slate-700 text-sm"/></div>
            </div>
            {result && (
              <div className="mt-4 p-5 bg-slate-100 dark:bg-slate-700 rounded-lg text-center shadow-sm">
                  <div className="flex justify-end -mt-3 -mr-3 mb-2"><button onClick={handleSave} className="text-slate-400 hover:text-sky-600"><Icon path={ICONS.notepad} className="w-5 h-5"/></button></div>
                  <div className="grid grid-cols-2 gap-4">
                      <div><p className="text-xs uppercase font-bold text-slate-500">FWHM</p><p className="text-2xl font-bold text-slate-700 dark:text-slate-200">{result.fwhm}</p></div>
                      <div><p className="text-xs uppercase font-bold text-slate-500">Resolution</p><p className="text-2xl font-bold text-sky-600 dark:text-sky-400">{result.res.toFixed(2)}%</p></div>
                  </div>
              </div>
            )}
            </div>
            );
            };
            
            // 6. MAIN CONTAINER: LabStatistics
            const LabStatistics = () => {
            const [activeTab, setActiveTab] = React.useState('mda');
            
            // MDA State
            const [mda_bkgCounts, setMda_bkgCounts] = React.useState('50');
            const [mda_countTime, setMda_countTime] = React.useState('1');
            const [mda_bkgTime, setMda_bkgTime] = React.useState('1');
            const [mda_eff, setMda_eff] = React.useState('10');
            const [mda_effUnit, setMda_effUnit] = React.useState('%');
            const [mda_area, setMda_area] = React.useState('100');
            const [mda_result, setMda_result] = React.useState(null);
            
            // ChiSq State
            const [chi_data, setChi_data] = React.useState('');
            const [chi_alpha, setChi_alpha] = React.useState('0.05');
            const [chi_result, setChi_result] = React.useState(null);
            const [chi_error, setChi_error] = React.useState('');
            
            // DeadTime State
            const [dt_obs, setDt_obs] = React.useState('50000');
            const [dt_tau, setDt_tau] = React.useState('100');
            const [dt_result, setDt_result] = React.useState(null);
            const [dt_error, setDt_error] = React.useState('');
            
            // RPD State
            const [rpd_s1, setRpd_s1] = React.useState('1250');
            const [rpd_s2, setRpd_s2] = React.useState('1180');
            const [rpd_result, setRpd_result] = React.useState(null);
            
            // FWHM State
            const [fw_cent, setFw_cent] = React.useState('661.7');
            const [fw_low, setFw_low] = React.useState('658.2');
            const [fw_up, setFw_up] = React.useState('665.2');
            const [fw_result, setFw_result] = React.useState(null);
            
            const handleClear = () => {
            if(activeTab === 'mda') { setMda_bkgCounts('50'); setMda_result(null); }
            if(activeTab === 'chi') { setChi_data(''); setChi_result(null); }
            if(activeTab === 'dt') { setDt_obs('50000'); setDt_result(null); }
            if(activeTab === 'rpd') { setRpd_s1(''); setRpd_result(null); }
            if(activeTab === 'fwhm') { setFw_cent(''); setFw_result(null); }
            };
            
            return (
            <div className="p-4 animate-fade-in">
            <div className="max-w-xl mx-auto bg-white dark:bg-slate-800 p-6 rounded-xl shadow-lg">
              <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-bold text-slate-800 dark:text-white">Lab Statistics</h2>
                  <ClearButton onClick={handleClear} />
              </div>
            
               <div className="grid grid-cols-3 md:grid-cols-5 gap-1 p-1 bg-slate-200 dark:bg-slate-700 rounded-lg mb-6">
                   {['mda', 'chi', 'dt', 'rpd', 'fwhm'].map(id => {
                       const labels = { mda: 'MDA/MDC', chi: 'Chi-Sq', dt: 'Dead Time', rpd: 'RPD', fwhm: 'Resolution' };
                       return (
                           <button key={id} onClick={() => setActiveTab(id)}
                               className={`p-2 rounded-md text-xs sm:text-sm font-bold text-center transition-all duration-200
                               ${activeTab === id
                                   ? 'bg-white dark:bg-slate-800 text-sky-600 shadow-sm ring-1 ring-black/5 dark:ring-white/10'
                                   : 'text-slate-600 dark:text-slate-300 hover:bg-slate-300/50 dark:hover:bg-slate-600'
                               }`}>
                               {labels[id]}
                           </button>
                       )
                   })}
               </div>
            
              <div className="mt-2">
                  {activeTab === 'mda' && <MdaCalculator
                      bkgCounts={mda_bkgCounts} setBkgCounts={setMda_bkgCounts} countTime={mda_countTime} setCountTime={setMda_countTime}
                      bkgTime={mda_bkgTime} setBkgTime={setMda_bkgTime} efficiency={mda_eff} setEfficiency={setMda_eff}
                      effUnit={mda_effUnit} setEffUnit={setMda_effUnit} probeArea={mda_area} setProbeArea={setMda_area}
                      result={mda_result} setResult={setMda_result}
                  />}
                  {activeTab === 'chi' && <ChiSquaredCalculator
                      chiSquaredData={chi_data} setChiSquaredData={setChi_data} alpha={chi_alpha} setAlpha={setChi_alpha}
                      result={chi_result} setResult={setChi_result} error={chi_error} setError={setChi_error}
                  />}
                  {activeTab === 'dt' && <DeadTimeCorrector
                      observedCpm={dt_obs} setObservedCpm={setDt_obs} deadTime={dt_tau} setDeadTime={setDt_tau}
                      result={dt_result} setResult={setDt_result} error={dt_error} setError={setDt_error}
                  />}
                  {activeTab === 'rpd' && <RpdCalculator
                      sample1={rpd_s1} setSample1={setRpd_s1} sample2={rpd_s2} setSample2={setRpd_s2}
                      result={rpd_result} setResult={setRpd_result}
                  />}
                  {activeTab === 'fwhm' && <FwhmCalculator
                      centroid={fw_cent} setCentroid={setFw_cent} lower={fw_low} setLower={setFw_low} upper={fw_up} setUpper={setFw_up}
                      result={fw_result} setResult={setFw_result}
                  />}
              </div>
            </div>
            </div>
            );
            };
            
            /**
            * @description A React component that renders a line chart for simple decay (Parent/Daughter) using Chart.js.
            */
            const DecayChart = ({ chartData, useLogScale, theme }) => {
             const chartRef = React.useRef(null);
             const chartInstance = React.useRef(null);
            
             React.useEffect(() => {
                 if (chartInstance.current) {
                     chartInstance.current.destroy();
                 }
            
                 if (chartRef.current && chartData) {
                     const isDarkMode = theme === 'dark';
                     const textColor = isDarkMode ? '#94a3b8' : '#475569';
                     const gridColor = isDarkMode ? '#334155' : '#e2e8f0';
                     const legendColor = isDarkMode ? '#cbd5e1' : '#334155';
            
                     const ctx = chartRef.current.getContext('2d');
            
                     // LOG SCALE SAFETY LOGIC ---
                     let safeMin = undefined;
                     if (useLogScale) {
                         // Combine parent and daughter data to find the range
                         const allValues = [...chartData.parentData];
                         if (chartData.daughterData) {
                             allValues.push(...chartData.daughterData);
                         }
                         
                         const maxVal = Math.max(...allValues);
                         
                         if (maxVal > 0) {
                             // Set floor to 5 orders of magnitude below peak
                             safeMin = maxVal * 1e-5;
                         } else {
                             safeMin = 1e-5;
                         }
                     }
            
                     chartInstance.current = new Chart(ctx, {
                         type: 'line',
                         data: {
                             labels: chartData.labels,
                             datasets: [
                                 {
                                     label: chartData.parentName,
                                     data: chartData.parentData,
                                     borderColor: '#0284c7', // Sky-600
                                     backgroundColor: 'rgba(2, 132, 199, 0.1)',
                                     fill: true,
                                     tension: 0, // Straight lines for log scale accuracy
                                     pointRadius: 0,
                                     pointHoverRadius: 6
                                 },
                                 ...(chartData.daughterData ? [{
                                     label: chartData.daughterName,
                                     data: chartData.daughterData,
                                     borderColor: '#e11d48', // Rose-600
                                     backgroundColor: 'rgba(225, 29, 72, 0.1)',
                                     fill: true,
                                     tension: 0,
                                     pointRadius: 0,
                                     pointHoverRadius: 6
                                 }] : [])
                             ]
                         },
                         options: {
                             responsive: true,
                             maintainAspectRatio: false,
                             interaction: { mode: 'index', intersect: false },
                             scales: {
                                 x: {
                                     title: { display: true, text: `Time (${chartData.timeUnit})`, color: textColor },
                                     ticks: { color: textColor },
                                     grid: { color: gridColor }
                                 },
                                 y: {
                                     type: useLogScale ? 'logarithmic' : 'linear',
                                     title: { display: true, text: 'Activity', color: textColor, padding: { bottom: 10 }  },
                                     min: safeMin,
                                     beginAtZero: !useLogScale,
                                     ticks: { 
                                         color: textColor,
                                         callback: function(value) {
                                              if (value !== 0 && (Math.abs(value) < 1e-3 || Math.abs(value) >= 1e4)) {
                                                  return value.toExponential(1);
                                              }
                                              return value.toLocaleString();
                                         }
                                     },
                                     grid: { color: gridColor }
                                 }
                             },
                             plugins: {
                                 legend: { labels: { color: legendColor } }
                             }
                         }
                     });
                 }
            
                 return () => {
                     if (chartInstance.current) {
                         chartInstance.current.destroy();
                     }
                 };
             }, [chartData, useLogScale, theme]);
            
             const handleExport = () => {
                 if (chartInstance.current) {
                     const link = document.createElement('a');
                     link.href = chartInstance.current.toBase64Image();
                     const filename = `Decay_${chartData.parentName || 'Chart'}.png`;
                     link.download = filename;
                     link.click();
                 }
             };
            
             return (
                 <div className="mt-4">
                     <div className="h-64 w-full">
                         <canvas ref={chartRef}></canvas>
                     </div>
                     <div className="text-center mt-3">
                         <button
                             onClick={handleExport}
                             className="flex items-center justify-center gap-2 mx-auto px-4 py-2 text-xs font-bold bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-200 rounded-lg hover:bg-sky-100 dark:hover:bg-sky-900 transition-colors"
                         >
                             <Icon path={ICONS.download} className="w-3 h-3" />
                             Save Chart Image
                         </button>
                     </div>
                 </div>
             );
            };
            
            // Final step: Render the main App component into the DOM.
            
            ReactDOM.createRoot(document.getElementById('root')).render(
            <SettingsProvider>
            <ToastProvider>
                <App />
            </ToastProvider>
            </SettingsProvider>
            );
            
            ReactDOM.createRoot(document.getElementById('back-to-top-root')).render(
            <BackToTopButton />
            );
            
            // After the app is rendered, find the loader and fade it out.
            
            const loader = document.getElementById('loader');
            if (loader) {
            
            // A small timeout ensures the app has painted before the loader disappears.
            
            setTimeout(() => {
            
            loader.classList.add('hidden');
            }, 100); // 100ms delay
            }
        </script>
    </body>
</html>
