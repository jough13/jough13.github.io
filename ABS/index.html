<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ancient Battle Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            color: #333;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #d1d5db; /* Light gray for battlefield */
            border: 2px solid #6b7280;
            border-radius: 0.75rem;
            display: block;
            touch-action: none; /* Prevent browser touch actions */
            width: 100%; /* Make canvas responsive */
            max-width: 700px; /* Max width for larger screens */
            height: auto; /* Maintain aspect ratio */
            position: relative; /* For tooltip positioning */
        }
        .controls {
            width: 100%;
            max-width: 700px;
            margin-top: 1rem;
            display: flex; /* Use flexbox for horizontal buttons */
            gap: 1rem; /* Space between buttons */
            justify-content: center; /* Center the buttons */
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }
        button, select {
            background-color: #4f46e5; /* Indigo */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            cursor: pointer;
            flex: 1; /* Allow buttons to grow and fill space */
            max-width: 200px; /* Limit individual button width */
            appearance: none; /* Remove default select styles */
            -webkit-appearance: none;
            -moz-appearance: none;
            text-align: center;
        }
        button:hover, select:hover {
            background-color: #4338ca; /* Darker indigo */
            transform: translateY(-2px);
        }
        button:active, select:active {
            background-color: #3730a3; /* Even darker indigo */
            transform: translateY(0);
        }
        .log-area {
            background-color: #e2e8f0; /* Light blue-gray */
            border-radius: 0.5rem;
            padding: 1rem;
            height: 150px;
            overflow-y: auto;
            border: 1px solid #cbd5e1;
            font-size: 0.9rem;
            margin-top: 1rem;
            width: 100%; /* Ensure log area takes full width */
            max-width: 700px;
        }
        .log-area p {
            margin-bottom: 0.25rem;
        }
        .faction-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .faction-roman {
            color: #dc2626; /* Red */
        }
        .faction-gaul {
            color: #16a34a; /* Green */
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            font-size: 0.85rem;
            color: #555;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .legend-color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }
        /* Style for the select element's arrow */
        select {
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%20197.35L150.3%2060.65%2013.6%20197.35z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7em top 50%, 0 0;
            background-size: 0.65em auto, 100%;
            padding-right: 2.5em; /* Make space for the arrow */
        }

        /* Tooltip styles */
        #unitTooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 0.5rem;
            font-size: 0.85rem;
            pointer-events: none; /* Allows mouse events to pass through to canvas */
            white-space: nowrap;
            display: none; /* Hidden by default */
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Popup menu styles */
        #unitPopupMenu {
            position: absolute;
            background-color: #ffffff;
            border: 1px solid #cbd5e1;
            border-radius: 0.75rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            z-index: 2000;
            display: none; /* Hidden by default */
            min-width: 200px;
            max-width: 300px;
            font-size: 0.95rem;
            color: #333;
        }
        #unitPopupMenu h3 {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #4f46e5;
        }
        #unitPopupMenu p {
            margin-bottom: 0.25rem;
        }
        #unitPopupMenu button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            width: 100%;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #unitPopupMenu button:hover {
            background-color: #4338ca;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-4 text-center">Ancient Battle Simulation</h1>
        <div class="w-full flex justify-around mb-4">
            <div class="text-center">
                <p class="faction-title faction-roman">Roman Army</p>
                <p id="roman-units-display" class="text-lg font-semibold">Units: 0</p>
            </div>
            <div class="text-center">
                <p class="faction-title faction-gaul">Barbarian Horde</p> <p id="gaul-units-display" class="text-lg font-semibold">Units: 0</p>
            </div>
        </div>
        <canvas id="battleCanvas"></canvas>
        <div id="unitTooltip"></div> <div id="unitPopupMenu"></div> <div class="legend">
            <div class="legend-item"><div class="legend-color-box" style="background-color: #8BC34A;"></div>Plain</div>
            <div class="legend-item"><div class="legend-color-box" style="background-color: #4CAF50;"></div>Forest</div>
            <div class="legend-item"><div class="legend-color-box" style="background-color: #A1887F;"></div>Hill</div>
            <div class="legend-item"><div class="legend-color-box" style="background-color: #4169E1;"></div>Water</div>
            <div class="legend-item"><div class="legend-color-box" style="background-color: #FFD700; border: 1px solid #FFD700;"></div>Commander Aura</div>
        </div>
        <div class="controls">
            <select id="scenarioSelect" class="bg-indigo-600">
                <option value="Random Battle">Random Battle</option>
                <option value="Clash of Legions">Clash of Legions</option>
                <option value="Barbarian Ambush">Barbarian Ambush</option>
                <option value="River Crossing">River Crossing</option>
            </select>
            <button id="nextTurnButton">Begin!</button>
            <button id="autoBattleButton">Auto Battle</button>
            <button id="restartButton" style="display: none;">Restart</button>
        </div>
        <div class="log-area" id="logArea">
            <p class="text-gray-700">Battle Log:</p>
        </div>
    </div>

    <script>
        // Check if the simulation has already been initialized globally
        if (!window.ancientBattleSimInitialized) {
            window.ancientBattleSimInitialized = true; // Set flag to true immediately

            // Define the global battleSim object
            window.battleSim = window.battleSim || {};

            (function() { // Start of IIFE encapsulating private variables and helper functions
                // Canvas and context - declared here, assigned in DOMContentLoaded
                let canvas;
                let ctx;

                // UI elements - declared here, assigned in DOMContentLoaded
                let nextTurnButton;
                let autoBattleButton;
                let restartButton;
                let logArea;
                let romanUnitsDisplay;
                let gaulUnitsDisplay;
                let unitTooltip;
                let unitPopupMenu; // New: Reference to the popup menu
                let scenarioSelect;

                // ### CORE PARAMETERS ###
                window.battleSim.GRID_SIZE = 20;
                window.battleSim.MAP_WIDTH_CELLS = 40;
                window.battleSim.MAP_HEIGHT_CELLS = 30;
                window.battleSim.VERSION_NUMBER = "v1.4";

                // ### TIMING & ANIMATION ###
                window.battleSim.ANIMATION_DURATION = 300;
                window.battleSim.AUTO_BATTLE_TURN_DELAY = 800;
                window.battleSim.FLANKED_FLASH_INTERVAL = 150;
                window.battleSim.PROJECTILE_LIFETIME_MS = 200;

                // ### GAME BALANCE CONSTANTS ###

// --- AI Scoring Weights (for findOptimalMoveForUnit) ---
window.battleSim.AI_SCORE_COHESION_BONUS = 75; // Bonus for moving with nearby allies

                // --- Morale ---
                window.battleSim.MORALE_BREAK_THRESHOLD = 20;
                window.battleSim.MORALE_MODIFIER_MIN = 0.7; // At 0 morale, units retain this % of base stats
                window.battleSim.MORALE_LOSS_DAMAGE_MULTIPLIER = 0.08;
                window.battleSim.HEAVY_DAMAGE_THRESHOLD_PERCENT = 0.2; // % of max health lost to count as "heavy damage"
                window.battleSim.MORALE_LOSS_HEAVY_DAMAGE_FLAT = 0.05; // Extra morale loss from heavy damage
                window.battleSim.MORALE_GAIN_ON_ENEMY_BREAK = 5;
                window.battleSim.MORALE_GAIN_RADIUS = 2; // How close friendlies must be to gain morale from enemy break

                // --- Fatigue ---
                window.battleSim.FATIGUE_MORALE_PENALTY_PER_POINT = 0.5;
                window.battleSim.BASE_FATIGUE_GAIN = 1; // Fatigue gained per turn for active units
                window.battleSim.FATIGUE_GAIN_TERRAIN_SCALAR = 0.5;

                // --- Combat ---
                window.battleSim.ARCHER_RANGE = 7;
                window.battleSim.MINIMUM_DAMAGE = 1;
                window.battleSim.COMBAT_RANDOMNESS_FACTOR = 0.2; // +/- 20%
                window.battleSim.RANGED_COMBAT_RANDOMNESS_FACTOR = 0.1; // +/- 10%
                window.battleSim.CAVALRY_VS_INFANTRY_BONUS = 1.2;
                window.battleSim.INFANTRY_VS_CAVALRY_BONUS = 1.1;
                window.battleSim.CHARIOT_ATTACK_BONUS = 1.3;
                window.battleSim.CHARGE_DAMAGE_MODIFIER = 1.5;
                window.battleSim.FLANKED_DAMAGE_MODIFIER = 1.5;
                window.battleSim.FLANKED_COUNTERATTACK_PENALTY = 0.7;
                window.battleSim.MELEE_STRENGTH_DAMAGE_SCALAR = 0.8;
                window.battleSim.MELEE_FINAL_DAMAGE_MULTIPLIER = 8;
                window.battleSim.RANGED_STRENGTH_DAMAGE_SCALAR = 0.4;
                window.battleSim.RANGED_FINAL_DAMAGE_MULTIPLIER = 8;
                window.battleSim.RANGED_DEFENSE_EFFECTIVENESS = 0.5; // Ranged attacks ignore 50% of defense

                // --- Commander & Leadership ---
                window.battleSim.LEADERSHIP_RADIUS = 6;
                window.battleSim.LEADERSHIP_MORALE_BOOST = 10;
                window.battleSim.LEADERSHIP_FATIGUE_REDUCTION = 0.5;
                window.battleSim.COMMANDER_LOSS_MORALE_SHOCK = 20;

                // --- Unit Behavior & AI ---
                window.battleSim.INITIAL_AGGRESSION_TURNS = 15;
                window.battleSim.IDLE_TURNS_FOR_FORCED_MOVE = 4;
                window.battleSim.TURNS_TO_READY_AMBUSH = 1;
                window.battleSim.ROUTING_BEHAVIOR_MORALE_BUFFER = 10;
                window.battleSim.ROUTING_BEHAVIOR_STRENGTH_THRESHOLD = 20; // In %
                window.battleSim.DEFENSIVE_BEHAVIOR_THRESHOLD = 40; // In % (for morale and strength)

                // --- AI Scoring Weights (for findOptimalMoveForUnit) ---
                window.battleSim.AI_SCORE_DISTANCE_WEIGHT = 100;
                window.battleSim.AI_SCORE_TERRAIN_DEFENSE_WEIGHT = 10;
                window.battleSim.AI_SCORE_TERRAIN_FATIGUE_PENALTY = 2;
                window.battleSim.AI_SCORE_AMBUSH_SETUP_BONUS = 200;
                window.battleSim.AI_SCORE_RANGED_ADJACENT_PENALTY = 1500; // HUGE penalty
                window.battleSim.AI_SCORE_RANGED_OUT_OF_RANGE_PENALTY = 50;
                window.battleSim.AI_SCORE_RANGED_STAY_IN_RANGE_BONUS = 10;
                window.battleSim.AI_SCORE_MELEE_NOT_ADJACENT_PENALTY = 50;
                window.battleSim.AI_SCORE_ENGAGE_MELEE_BONUS = 100;
                window.battleSim.AI_SCORE_FORM_BATTLE_LINE_BONUS = 50;
                window.battleSim.AI_SCORE_CHASE_ROUTING_BONUS = 200;
                window.battleSim.AI_SCORE_ADVANCE_BONUS = 200;
                window.battleSim.AI_SCORE_RANGED_ON_HILL_BONUS = 60;
                window.battleSim.AI_SCORE_RANGED_IN_FOREST_BONUS = 150; // Increased from 50
                window.battleSim.AI_SCORE_ADJACENT_TO_WATER_PENALTY = 100;
                window.battleSim.AI_SCORE_SKIRMISH_MOVE_BONUS = 15;
                window.battleSim.AI_SCORE_TARGET_COMMANDER_BONUS = 200;
                window.battleSim.AI_SCORE_TARGET_RANGED_BONUS = 50;
                window.battleSim.AI_SCORE_TARGET_INFANTRY_BONUS = 20;
                window.battleSim.AI_SCORE_WEAKEST_TARGET_WEIGHT = 0.5;
                window.battleSim.AI_SCORE_RANGED_IN_RANGE_BONUS = 10;
                window.battleSim.AI_SCORE_ROUTING_ENEMY_PROXIMITY_WEIGHT = 100;
                window.battleSim.AI_SCORE_ROUTING_RETREAT_DIRECTION_WEIGHT = 200;
                window.battleSim.AI_SCORE_ROUTING_MOVE_COST_PENALTY = 50;
                window.battleSim.AI_SCORE_ROUTING_MAP_CENTER_PENALTY = 5;

                // --- Map Generation ---
                window.battleSim.TERRAIN_SPREAD_PROBABILITY_DECAY = 0.2;

                // Retreat Zone definitions
                window.battleSim.ROMAN_RETREAT_X = window.battleSim.MAP_WIDTH_CELLS - 1;
                window.battleSim.GAUL_RETREAT_X = 0;

                // Animation and game state flags
                let animationStartTime;
                let isAnimating = false;
                let isAutoBattleActive = false;
                let autoBattleIntervalId = null;

                // Game state variables - these will be reset by initGame()
                let turn = 0;
                let units = [];
                let map = [];
                let projectiles = [];
                let currentHoveredUnit = null;
                let currentClickedUnit = null; 

                // Mouse position variables
                window.lastMouseX = 0;
                window.lastMouseY = 0;
                window.lastTime = 0;

                // Offscreen canvas for terrain textures
                const terrainTextureCanvas = document.createElement('canvas');
                let terrainTextureCtx;

                window.battleSim.TERRAIN_DATA = {
                    'plain': { color: '#8BC34A', movementCost: 1, defenseBonus: 0, fatigueCost: 0 },
                    'forest': { color: '#4CAF50', movementCost: 2, defenseBonus: 0.15, fatigueCost: 0.5 },
                    'hill': { color: '#A1887F', movementCost: 1.5, defenseBonus: 0.25, fatigueCost: 0.2 },
                    'water': { color: '#4169E1', movementCost: Infinity, defenseBonus: 0, fatigueCost: 0 }
                };

                window.battleSim.MORALE_TIERS_DATA = {
                    'Steady': { minMorale: 70, color: '#28A745', attackPenalty: 0, defensePenalty: 0, movementPenalty: 0, name: 'Steady' },
                    'Shaken': { minMorale: 40, color: '#FFC107', attackPenalty: 0.05, defensePenalty: 0.05, movementPenalty: 0, name: 'Shaken' },
                    'Wavering': { minMorale: 10, color: '#FD7E14', attackPenalty: 0.15, defensePenalty: 0.15, movementPenalty: 0.1, name: 'Wavering' },
                    'Routing': { minMorale: -Infinity, color: '#DC3545', attackPenalty: 0.3, defensePenalty: 0.3, movementPenalty: 0.5, name: 'Routing' }
                };

                window.battleSim.AI_BEHAVIOR_DATA = {
                    'aggressive': { movementModifier: 1.1, attackModifier: 1.1, defenseModifier: 0.9, moraleModifier: 1, fatigueModifier: 1.1 },
                    'defensive': { movementModifier: 0.9, attackModifier: 0.9, defenseModifier: 1.2, moraleModifier: 1.1, fatigueModifier: 0.9 },
                    'skirmishing': { movementModifier: 1.2, attackModifier: 1, defenseModifier: 0.8, moraleModifier: 1, fatigueModifier: 0.8 },
                    'routing': { movementModifier: 1.5, attackModifier: 0.1, defenseModifier: 0.1, moraleModifier: 0.1, fatigueModifier: 0.5 }
                };

                window.battleSim.FORMATION_DATA = {
                    'default': { movementModifier: 1, attackModifier: 1, defenseModifier: 1, moraleModifier: 1, fatigueModifier: 1 },
                    'tight_formation': { movementModifier: 0.8, attackModifier: 1.1, defenseModifier: 1.2, moraleModifier: 1.1, fatigueModifier: 1.2 },
                    'loose_formation': { movementModifier: 1.2, attackModifier: 1, defenseModifier: 0.8, moraleModifier: 0.9, fatigueModifier: 0.9 },
                    'charge_formation': { movementModifier: 1.1, attackModifier: 1.3, defenseModifier: 0.9, moraleModifier: 1.1, fatigueModifier: 1.5 },
                    'shield_wall': { movementModifier: 0.7, attackModifier: 0.9, defenseBonus: 1.5, moraleModifier: 1.2, fatigueModifier: 1.3 }
                };

                window.battleSim.UNIT_TYPE_DATA = {
                    'infantry': { baseStrength: 100, baseMorale: 80, baseAttack: 10, baseDefense: 8, baseMovement: 2, identifier: 'I', defaultFormation: 'tight_formation', targetPreference: 'closest', defaultBehavior: 'aggressive' },
                    'cavalry': { baseStrength: 60, baseMorale: 90, baseAttack: 12, baseDefense: 6, baseMovement: 3, identifier: 'C', defaultFormation: 'charge_formation', targetPreference: 'ranged_units', defaultBehavior: 'aggressive' },
                    'chariot': { baseStrength: 70, baseMorale: 95, baseAttack: 15, baseDefense: 5, baseMovement: 4, identifier: 'T', defaultFormation: 'charge_formation', targetPreference: 'ranged_units', defaultBehavior: 'aggressive' },
                    'archer': { baseStrength: 50, baseMorale: 70, baseAttack: 7, baseDefense: 5, baseMovement: 2, identifier: 'A', defaultFormation: 'loose_formation', targetPreference: 'closest', defaultBehavior: 'skirmishing' },
                    'skirmisher': { baseStrength: 45, baseMorale: 80, baseAttack: 6, baseDefense: 4, baseMovement: 3, identifier: 'S', defaultFormation: 'loose_formation', targetPreference: 'weakest', defaultBehavior: 'skirmishing' },
                    'commander': { baseStrength: 70, baseMorale: 100, baseAttack: 5, baseDefense: 10, baseMovement: 2, identifier: '★', defaultFormation: 'default', targetPreference: 'closest', defaultBehavior: 'defensive' }
                };
                
                function getScenarioData() {
                    return {
                        "Random Battle": {
                            description: "Generates a random map with a balanced set of units.",
                            mapSettings: null,
                            romanUnits: null,
                            gaulUnits: null,
                        },
                        "Clash of Legions": {
                            description: "Two large infantry forces meet head-on in an open field.",
                            mapSettings: { numForestClumps: 0, numHillClumps: 0, numWaterClumps: 0 },
                            romanUnits: [
                                { type: 'infantry', count: 6, color: '#dc2626', spreadX: 0, spreadY: 2, startX: 5, startY: 10 },
                                { type: 'cavalry', count: 1, color: '#b91c1c', spreadX: 0, spreadY: 0, startX: 3, startY: 14 },
                                { type: 'commander', count: 1, color: '#800080', spreadX: 0, spreadY: 0, startX: 5, startY: 15 },
                            ],
                            gaulUnits: [
                                { type: 'infantry', count: 6, color: '#16a34a', spreadX: 0, spreadY: 2, startX: window.battleSim.MAP_WIDTH_CELLS - 6, startY: 10 },
                                { type: 'chariot', count: 1, color: '#047857', spreadX: 0, spreadY: 0, startX: window.battleSim.MAP_WIDTH_CELLS - 4, startY: 14 },
                                { type: 'commander', count: 1, color: '#B22222', spreadX: 0, spreadY: 0, startX: window.battleSim.MAP_WIDTH_CELLS - 6, startY: 15 },
                            ]
                        },
                        "Barbarian Ambush": {
                            description: "Romans advance through a forest, ambushed by hidden Gauls.",
                            mapSettings: { numForestClumps: 8, numHillClumps: 2, numWaterClumps: 0, spreadRadiusMax: 8, waterSpreadRadiusMax: 0 },
                            romanUnits: [
                                { type: 'infantry', count: 4, color: '#dc2626', spreadX: 0, spreadY: 1, startX: 5, startY: 10 },
                                { type: 'archer', count: 2, color: '#00BFFF', spreadX: 0, spreadY: 0, startX: 3, startY: 12 },
                                { type: 'commander', count: 1, color: '#800080', spreadX: 0, spreadY: 0, startX: 4, startY: 15 },
                            ],
                            gaulUnits: [
                                { type: 'infantry', count: 5, color: '#16a34a', spreadX: 1, spreadY: 1, startX: window.battleSim.MAP_WIDTH_CELLS - 8, startY: 8 },
                                { type: 'skirmisher', count: 3, color: '#FFD700', spreadX: 1, spreadY: 1, startX: window.battleSim.MAP_WIDTH_CELLS - 5, startY: 12 },
                                { type: 'commander', count: 1, color: '#B22222', spreadX: 0, spreadY: 0, startX: window.battleSim.MAP_WIDTH_CELLS - 4, startY: 15 },
                            ]
                        },
                        "River Crossing": {
                            description: "Forces clash over a central river.",
                            mapSettings: { numForestClumps: 0, numHillClumps: 0, numWaterClumps: 1, waterSpreadRadiusMax: 7 },
                            romanUnits: [
                                { type: 'infantry', count: 4, color: '#dc2626', spreadX: 1, spreadY: 1, startX: 5, startY: 5 },
                                { type: 'archer', count: 2, color: '#00BFFF', spreadX: 0, spreadY: 0, startX: 7, startY: 3 },
                                { type: 'cavalry', count: 1, color: '#b91c1c', spreadX: 0, spreadY: 0, startX: 4, startY: 8 },
                                { type: 'commander', count: 1, color: '#800080', spreadX: 0, spreadY: 0, startX: 6, startY: 6 },
                            ],
                            gaulUnits: [
                                { type: 'infantry', count: 4, color: '#16a34a', spreadX: 1, spreadY: 1, startX: window.battleSim.MAP_WIDTH_CELLS - 6, startY: window.battleSim.MAP_HEIGHT_CELLS - 5 },
                                { type: 'skirmisher', count: 2, color: '#FFD700', spreadX: 0, spreadY: 0, startX: window.battleSim.MAP_WIDTH_CELLS - 8, startY: window.battleSim.MAP_HEIGHT_CELLS - 3 },
                                { type: 'chariot', count: 1, color: '#047857', spreadX: 0, spreadY: 0, startX: window.battleSim.MAP_WIDTH_CELLS - 5, startY: window.battleSim.MAP_HEIGHT_CELLS - 8 },
                                { type: 'commander', count: 1, color: '#B22222', spreadX: 0, spreadY: 0, startX: window.battleSim.MAP_WIDTH_CELLS - 7, startY: window.battleSim.MAP_HEIGHT_CELLS - 6 },
                            ]
                        }
                    };
                }


                class Unit {
                    constructor(id, name, type, faction, x, y, color) {
                        const typeData = window.battleSim.UNIT_TYPE_DATA[type];
                        if (!typeData) {
                            console.error(`Unknown unit type: ${type}`);
                            Object.assign(this, window.battleSim.UNIT_TYPE_DATA['infantry']);
                        } else {
                            Object.assign(this, typeData);
                        }

                        this.id = id;
                        this.name = name;
                        this.type = type;
                        this.faction = faction;
                        this.x = x;
                        this.y = y;
                        this.strength = this.baseStrength;
                        this.maxStrength = this.baseStrength;
                        this.morale = this.baseMorale;
                        this.initialMorale = this.baseMorale;
                        this.attack = this.baseAttack;
                        this.defense = this.baseDefense;
                        this.movementPoints = this.baseMovement;
                        this.remainingMovement = this.baseMovement;
                        this.color = color;
                        this.broken = false;
                        this.hasCharged = false;
                        this.isFlashing = false;
                        this.isFlankedStatus = false;

                        this.displayX = x;
                        this.displayY = y;
                        this.prevX = x;
                        this.prevY = y;
                        this.pathHistory = [];

                        this.fatigue = 0;
                        this.idleTurns = 0;
                        this.isAmbushReady = false;
                        this.ambushRestTurns = 0;

                        this.hasCommanderAura = false;
                        this.appliedCommanderBuff = false;

                        this.currentFormation = this.defaultFormation;
                        this.targetPreference = typeData.targetPreference;
                        this.currentBehavior = typeData.type === 'commander' ? 'defensive' : (typeData.defaultBehavior || 'aggressive');
                    }

                    getMoraleState() {
                        const currentMorale = Math.max(0, this.morale - (this.fatigue * window.battleSim.FATIGUE_MORALE_PENALTY_PER_POINT));
                        if (currentMorale >= window.battleSim.MORALE_TIERS_DATA.Steady.minMorale) return window.battleSim.MORALE_TIERS_DATA.Steady;
                        if (currentMorale >= window.battleSim.MORALE_TIERS_DATA.Shaken.minMorale) return window.battleSim.MORALE_TIERS_DATA.Shaken;
                        if (currentMorale >= window.battleSim.MORALE_TIERS_DATA.Wavering.minMorale) return window.battleSim.MORALE_TIERS_DATA.Wavering;
                        return window.battleSim.MORALE_TIERS_DATA.Routing;
                    }

                    getEffectiveAttack() {
                        let currentMorale = this.morale;
                        if (this.type !== 'commander' && this.appliedCommanderBuff) currentMorale += window.battleSim.LEADERSHIP_MORALE_BOOST;
                        currentMorale = Math.max(0, currentMorale - (this.fatigue * window.battleSim.FATIGUE_MORALE_PENALTY_PER_POINT));
                        const moraleModifier = (currentMorale / 100) * (1 - window.battleSim.MORALE_MODIFIER_MIN) + window.battleSim.MORALE_MODIFIER_MIN;
                        const formationAttackModifier = window.battleSim.FORMATION_DATA[this.currentFormation].attackModifier;
                        const moraleStatePenalty = this.getMoraleState().attackPenalty;
                        const behaviorAttackModifier = window.battleSim.AI_BEHAVIOR_DATA[this.currentBehavior].attackModifier;
                        
                        let totalAttack = this.attack * moraleModifier * formationAttackModifier * (1 - moraleStatePenalty) * behaviorAttackModifier;
                        
                        if (this.isAmbushReady) {
                            totalAttack *= 2;
                        }

                        return totalAttack;
                    }

                    getEffectiveDefense() {
                        let currentMorale = this.morale;
                        if (this.type !== 'commander' && this.appliedCommanderBuff) currentMorale += window.battleSim.LEADERSHIP_MORALE_BOOST;
                        currentMorale = Math.max(0, currentMorale - (this.fatigue * window.battleSim.FATIGUE_MORALE_PENALTY_PER_POINT));
                        const moraleModifier = (currentMorale / 100) * (1 - window.battleSim.MORALE_MODIFIER_MIN) + window.battleSim.MORALE_MODIFIER_MIN;
                        const terrain = window.battleSim.getTerrainAt(this.x, this.y);
                        const terrainDefenseBonus = window.battleSim.TERRAIN_DATA[terrain].defenseBonus;
                        const formationDefenseModifier = window.battleSim.FORMATION_DATA[this.currentFormation].defenseModifier;
                        const moraleStatePenalty = this.getMoraleState().defensePenalty;
                        const behaviorDefenseModifier = window.battleSim.AI_BEHAVIOR_DATA[this.currentBehavior].defenseModifier;
                        return this.defense * moraleModifier * (1 + terrainDefenseBonus) * formationDefenseModifier * (1 - moraleStatePenalty) * behaviorDefenseModifier;
                    }

                    takeDamage(damageAmount) {
                        if (this.broken) return;
                        this.strength -= damageAmount;
                        if (this.strength < 0) this.strength = 0;
                        this.checkMorale(damageAmount);
                        this.isFlashing = true;
                        setTimeout(() => { this.isFlashing = false; }, 100);
                    }

                    checkMorale(damageAmount) {
                        if (this.broken) return;
                        const strengthLossPercentage = damageAmount / this.maxStrength;
                        let moraleLoss = strengthLossPercentage * this.initialMorale * window.battleSim.MORALE_LOSS_DAMAGE_MULTIPLIER;
                        if (strengthLossPercentage > window.battleSim.HEAVY_DAMAGE_THRESHOLD_PERCENT) {
                            moraleLoss += this.initialMorale * window.battleSim.MORALE_LOSS_HEAVY_DAMAGE_FLAT;
                        }
                        this.morale -= moraleLoss;
                        if (this.morale <= window.battleSim.MORALE_BREAK_THRESHOLD) {
                            this.broken = true;
                            this.morale = 0;
                            window.battleSim.logBattleMessage(`${this.name} (${this.faction}) has broken and is routing!`);
                        }
                    }

                    moveTo(targetX, targetY) {
                        if (this.broken || this.remainingMovement <= 0) return false;
                        const currentGridX = this.x;
                        const currentGridY = this.y;
                        let nextGridX = currentGridX;
                        let nextGridY = currentGridY;

                        const dx = targetX - currentGridX;
                        const dy = targetY - currentGridY;

                        if (Math.abs(dx) > Math.abs(dy)) {
                            nextGridX += Math.sign(dx);
                        } else if (Math.abs(dy) > Math.abs(dx)) {
                            nextGridY += Math.sign(dy);
                        } else if (dx !== 0) {
                            nextGridX += Math.sign(dx);
                        } else if (dy !== 0) {
                            nextGridY += Math.sign(dy);
                        } else {
                            return false;
                        }

                        if (nextGridX < 0 || nextGridX >= window.battleSim.MAP_WIDTH_CELLS || nextGridY < 0 || nextGridY >= window.battleSim.MAP_HEIGHT_CELLS) return false;
                        
                        const isEnteringZoC = units.some(enemy =>
                            enemy.faction !== this.faction &&
                            enemy.strength > 0 &&
                            !enemy.broken &&
                            Math.abs(enemy.x - nextGridX) <= 1 &&
                            Math.abs(enemy.y - nextGridY) <= 1
                        );

                        const terrainType = window.battleSim.getTerrainAt(nextGridX, nextGridY);
                        let moveCost = window.battleSim.TERRAIN_DATA[terrainType].movementCost;
                        if (!window.battleSim.FORMATION_DATA[this.currentFormation]) {
                            console.error(`Formation data missing for: ${this.currentFormation}`);
                            return false;
                        }
                        moveCost *= window.battleSim.FORMATION_DATA[this.currentFormation].movementModifier;
                        moveCost *= (1 + this.getMoraleState().movementPenalty);
                        moveCost *= window.battleSim.AI_BEHAVIOR_DATA[this.currentBehavior].movementModifier;

                        if (moveCost === Infinity || this.remainingMovement < moveCost) return false;

                        const isOccupied = units.some(unit => unit.x === nextGridX && unit.y === nextGridY && unit.strength > 0 && unit.id !== this.id);
                        if (isOccupied) return false;

                        this.pathHistory.push({ x: this.x, y: this.y });
                        this.x = nextGridX;
                        this.y = nextGridY;
                        this.remainingMovement -= moveCost;
                        this.fatigue += window.battleSim.TERRAIN_DATA[terrainType].fatigueCost * window.battleSim.FORMATION_DATA[this.currentFormation].fatigueModifier * window.battleSim.AI_BEHAVIOR_DATA[this.currentBehavior].fatigueModifier;
                        
                        if (isEnteringZoC) {
                            this.remainingMovement = 0;
                            window.battleSim.logBattleMessage(`${this.name} stops after entering an enemy's zone of control.`);
                        }
                        
                        return true;
                    }

                    resetTurnStatus() {
                        this.remainingMovement = this.movementPoints;
                        this.hasCharged = false;
                        this.isFlankedStatus = false;
                        this.prevX = this.x;
                        this.prevY = this.y;
                        this.pathHistory = [];
                        
                        if (this.isAmbushReady && (this.x !== this.prevX || this.y !== this.prevY || this._attackedThisTurn)) {
                            this.isAmbushReady = false;
                            this.ambushRestTurns = 0;
                        } else if (!this.isAmbushReady && window.battleSim.getTerrainAt(this.x, this.y) === 'forest' && !(this.x !== this.prevX || this.y !== this.prevY || this._attackedThisTurn)) {
    // If in forest and didn't move/attack, setup is instant.
    this.isAmbushReady = true;

                        } else {
                            this.isAmbushReady = false;
                            this.ambushRestTurns = 0;
                        }
                        this._attackedThisTurn = false;
                        this.appliedCommanderBuff = false;
                    }

                    getTypeIdentifier() { return window.battleSim.UNIT_TYPE_DATA[this.type].identifier; }

                    updateUnitBehavior() {
                        if (this.broken) {
                            this.currentBehavior = 'routing';
                            return;
                        }

                        const currentMorale = Math.max(0, this.morale - (this.fatigue * window.battleSim.FATIGUE_MORALE_PENALTY_PER_POINT));
                        const currentStrengthPercent = (this.strength / this.maxStrength) * 100;

if (turn <= window.battleSim.INITIAL_AGGRESSION_TURNS && this.currentBehavior !== 'routing') {
    this.currentBehavior = 'aggressive';
    return;
}
                        
                        if (currentMorale <= window.battleSim.MORALE_BREAK_THRESHOLD + window.battleSim.ROUTING_BEHAVIOR_MORALE_BUFFER || currentStrengthPercent <= window.battleSim.ROUTING_BEHAVIOR_STRENGTH_THRESHOLD) {
                            this.currentBehavior = 'routing';
                            return;
                        }

                        if (currentMorale <= window.battleSim.DEFENSIVE_BEHAVIOR_THRESHOLD || currentStrengthPercent <= window.battleSim.DEFENSIVE_BEHAVIOR_THRESHOLD) {
                            if (this.type === 'archer' || this.type === 'skirmisher') {
                                this.currentBehavior = 'skirmishing';
                            } else {
                                this.currentBehavior = 'defensive';
                            }
                            return;
                        }

                        if (this.type === 'commander') {
                            this.currentBehavior = 'defensive';
                        } else if (this.type === 'archer' || this.type === 'skirmisher') {
                            this.currentBehavior = 'skirmishing';
                        } else {
                            this.currentBehavior = 'aggressive';
                        }
                    }
                }

                class Projectile {
                    constructor(startX, startY, targetX, targetY, color) {
                        this.startX = startX;
                        this.startY = startY;
                        this.targetX = targetX;
                        this.targetY = targetY;
                        this.color = color;
                        this.birthTime = performance.now();
                        this.lifeTime = window.battleSim.PROJECTILE_LIFETIME_MS;
                    }
                    isAlive(currentTime) { return (currentTime - this.birthTime) < this.lifeTime; }
                }

                window.battleSim.logBattleMessage = function(message) {
                    const p = document.createElement('p');
                    p.textContent = `Turn ${turn}: ${message}`;
                    logArea.appendChild(p);
                    logArea.scrollTop = logArea.scrollHeight;
                };

// NEW HELPER FUNCTION for Cohesion AI
window.battleSim.findFriendlyCentroid = function(unit, allUnits, radius) {
    const nearbyFriendlies = allUnits.filter(friend =>
        friend.id !== unit.id &&
        friend.faction === unit.faction &&
        Math.sqrt(Math.pow(unit.x - friend.x, 2) + Math.pow(unit.y - friend.y, 2)) <= radius
    );

    if (nearbyFriendlies.length === 0) {
        return null;
    }

    let totalX = 0;
    let totalY = 0;
    nearbyFriendlies.forEach(friend => {
        totalX += friend.x;
        totalY += friend.y;
    });

    return {
        x: totalX / nearbyFriendlies.length,
        y: totalY / nearbyFriendlies.length
    };
};

                window.battleSim.getTerrainAt = function(x, y) {
                    if (x < 0 || x >= window.battleSim.MAP_WIDTH_CELLS || y < 0 || y >= window.battleSim.MAP_HEIGHT_CELLS) return 'plain';
                    return map[y][x];
                };

                window.battleSim.isFlanked = function(unit) {
                    let adjacentEnemies = 0;
                    const dx = [-1, 0, 1, -1, 1, -1, 0, 1];
                    const dy = [0, 0, -1, 1, -1, 1, -1, 1];
                    for (let i = 0; i < dx.length; i++) {
                        const checkX = unit.x + dx[i];
                        const checkY = unit.y + dy[i];
                        const enemyAtPos = units.find(enemy => enemy.x === checkX && enemy.y === checkY && enemy.faction !== unit.faction && enemy.strength > 0 && !unit.broken);
                        if (enemyAtPos) adjacentEnemies++;
                    }
                    return adjacentEnemies >= 2;
                };

                window.battleSim.drawTerrainTexture = function(ctx, terrainType, x, y) {
                    const pixelX = x * window.battleSim.GRID_SIZE;
                    const pixelY = y * window.battleSim.GRID_SIZE;
                    const tileColor = window.battleSim.TERRAIN_DATA[terrainType].color;
                    ctx.fillStyle = tileColor;
                    ctx.fillRect(pixelX, pixelY, window.battleSim.GRID_SIZE, window.battleSim.GRID_SIZE);

                    const hexToRgbA = (hex, alpha) => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    };

                    if (terrainType === 'forest') {
                        const forestColor = 'rgba(0, 50, 0, 0.4)';
                        for (let i = 0; i < 3; i++) {
                            const rx = pixelX + Math.random() * window.battleSim.GRID_SIZE;
                            const ry = pixelY + Math.random() * window.battleSim.GRID_SIZE;
                            const rSize = 1 + Math.random() * 2;
                            ctx.fillStyle = forestColor;
                            ctx.beginPath();
                            ctx.arc(rx, ry, rSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (terrainType === 'hill') {
                        const hillBaseColor = window.battleSim.TERRAIN_DATA[terrainType].color;
                        const hillDarkerColor = hexToRgbA(hillBaseColor, 0.6);
                        const hillLightestColor = hexToRgbA(hillBaseColor, 0.3);
                        const centerX = pixelX + window.battleSim.GRID_SIZE / 2;
                        const centerY = pixelY + window.battleSim.GRID_SIZE / 2;
                        const radius = window.battleSim.GRID_SIZE * 0.9;
                        const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.1, centerX, centerY, radius);
                        gradient.addColorStop(0, hillLightestColor);
                        gradient.addColorStop(1, hillDarkerColor);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(pixelX, pixelY, window.battleSim.GRID_SIZE, window.battleSim.GRID_SIZE);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
                        for (let i = 0; i < 1; i++) {
                            const rx = pixelX + Math.random() * window.battleSim.GRID_SIZE;
                            const ry = pixelY + Math.random() * window.battleSim.GRID_SIZE;
                            const rSize = 0.5 + Math.random() * 0.5;
                            ctx.beginPath();
                            ctx.arc(rx, ry, rSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (terrainType === 'water') {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 0.5;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            const startY = pixelY + (i + 1) * (window.battleSim.GRID_SIZE / 4);
                            ctx.moveTo(pixelX, startY);
                            ctx.bezierCurveTo(
                                pixelX + window.battleSim.GRID_SIZE / 3, startY + (i % 2 === 0 ? 3 : -3),
                                pixelX + window.battleSim.GRID_SIZE * 2 / 3, startY + (i % 2 === 0 ? -3 : 3),
                                pixelX + window.battleSim.GRID_SIZE, startY
                            );
                            ctx.stroke();
                        }
                    }
                };

                window.battleSim.initGame = function(scenarioName = null) {
                    turn = 0;
                    units = [];
                    projectiles = [];
                    map = [];

                    window.battleSim.stopAutoBattle();

                    nextTurnButton.textContent = 'Begin!';
                    nextTurnButton.disabled = false;
                    nextTurnButton.style.display = 'block';
                    autoBattleButton.textContent = 'Auto Battle';
                    autoBattleButton.disabled = false;
                    autoBattleButton.style.display = 'block';
                    restartButton.style.display = 'none';

                    logArea.innerHTML = '<p class="text-gray-700">Battle Log:</p>';

                    const SCENARIO_DATA_LOCAL = getScenarioData();
                    let currentScenario = SCENARIO_DATA_LOCAL[scenarioName];
                    if (!currentScenario) {
                        console.warn(`Scenario "${scenarioName}" not found. Loading Random Battle.`);
                        currentScenario = SCENARIO_DATA_LOCAL["Random Battle"];
                    }

                    for (let y = 0; y < window.battleSim.MAP_HEIGHT_CELLS; y++) {
                        map[y] = [];
                        for (let x = 0; x < window.battleSim.MAP_WIDTH_CELLS; x++) {
                            map[y][x] = 'plain';
                        }
                    }

                    const mapSettings = currentScenario.mapSettings || {
                        numForestClumps: 4, numHillClumps: 3, numWaterClumps: 2,
                        spreadRadiusMax: 6, waterSpreadRadiusMax: 3
                    };

                    const isInDeploymentZone = (x, y) => {
                        const deploymentWidth = Math.floor(window.battleSim.MAP_WIDTH_CELLS / 4);
                        return x < deploymentWidth || x >= window.battleSim.MAP_WIDTH_CELLS - deploymentWidth;
                    };
                    const spreadTerrain = (terrainType, numClumps, maxRadius) => {
                        for (let i = 0; i < numClumps; i++) {
                            let startX, startY;
                            do {
                                startX = Math.floor(Math.random() * window.battleSim.MAP_WIDTH_CELLS);
                                startY = Math.floor(Math.random() * window.battleSim.MAP_HEIGHT_CELLS);
                            } while (isInDeploymentZone(startX, startY));

                            for (let dy = -maxRadius; dy <= maxRadius; dy++) {
                                for (let dx = -maxRadius; dx <= maxRadius; dx++) {
                                    const currentX = startX + dx;
                                    const currentY = startY + dy;
                                    if (currentX >= 0 && currentX < window.battleSim.MAP_WIDTH_CELLS && currentY >= 0 && currentY < window.battleSim.MAP_HEIGHT_CELLS && !isInDeploymentZone(currentX, currentY)) {
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        if (distance <= maxRadius) {
                                            const probability = 1 - (distance / maxRadius) * window.battleSim.TERRAIN_SPREAD_PROBABILITY_DECAY;
                                            if (Math.random() < probability) map[currentY][currentX] = terrainType;
                                        }
                                    }
                                }
                            }
                        }
                    };

                    spreadTerrain('forest', mapSettings.numForestClumps, mapSettings.spreadRadiusMax);
                    spreadTerrain('hill', mapSettings.numHillClumps, mapSettings.spreadRadiusMax);
                    spreadTerrain('water', mapSettings.numWaterClumps, mapSettings.waterSpreadRadiusMax);

                    for (let y = 0; y < window.battleSim.MAP_HEIGHT_CELLS; y++) {
                        const deploymentWidth = Math.floor(window.battleSim.MAP_WIDTH_CELLS / 4);
                        for (let x = 0; x < deploymentWidth; x++) map[y][x] = 'plain';
                        for (let x = window.battleSim.MAP_WIDTH_CELLS - deploymentWidth; x < window.battleSim.MAP_WIDTH_CELLS; x++) map[y][x] = 'plain';
                    }

                    for (let y = 0; y < window.battleSim.MAP_HEIGHT_CELLS; y++) {
                        for (let x = 0; x < window.battleSim.MAP_WIDTH_CELLS; x++) {
                            window.battleSim.drawTerrainTexture(terrainTextureCtx, map[y][x], x, y);
                        }
                    }

                    if (currentScenario.romanUnits && currentScenario.gaulUnits) {
                        currentScenario.romanUnits.forEach(unitDef => {
                            for (let i = 0; i < unitDef.count; i++) {
                                const x = unitDef.startX + (i % (unitDef.spreadX + 1));
                                const y = unitDef.startY + Math.floor(i / (unitDef.spreadY + 1));
                                units.push(new Unit(`R${units.length + 1}`, `${unitDef.type} ${i+1}`, unitDef.type, 'Roman', x, y, unitDef.color));
                            }
                        });
                        currentScenario.gaulUnits.forEach(unitDef => {
                            for (let i = 0; i < unitDef.count; i++) {
                                const x = unitDef.startX - (i % (unitDef.spreadX + 1));
                                const y = unitDef.startY + Math.floor(i / (unitDef.spreadY + 1));
                                units.push(new Unit(`B${units.length + 1}`, `${unitDef.type} ${i+1}`, unitDef.type, 'Gaul', x, y, unitDef.color));
                            }
                        });
                    } else {
                        const romanStartX = Math.floor(window.battleSim.MAP_WIDTH_CELLS / 8);
                        const romanStartYOffset = Math.floor(window.battleSim.MAP_HEIGHT_CELLS / 4);
                        units.push(new Unit('R1', 'Legion I', 'infantry', 'Roman', romanStartX, romanStartYOffset, '#dc2626'));
                        units.push(new Unit('R2', 'Legion II', 'infantry', 'Roman', romanStartX, romanStartYOffset + 2, '#dc2626'));
                        units.push(new Unit('R3', 'Legion III', 'infantry', 'Roman', romanStartX + 1, romanStartYOffset - 1, '#dc2626'));
                        units.push(new Unit('R4', 'Legion IV', 'infantry', 'Roman', romanStartX + 1, romanStartYOffset + 3, '#dc2626'));
                        units.push(new Unit('R5', 'Auxiliary Cavalry 1', 'cavalry', 'Roman', romanStartX - 2, romanStartYOffset + 1, '#b91c1c'));
                        units.push(new Unit('R6', 'Auxiliary Cavalry 2', 'cavalry', 'Roman', romanStartX + 3, romanStartYOffset + 1, '#b91c1c'));
                        units.push(new Unit('R7', 'Roman Archers 1', 'archer', 'Roman', romanStartX -1, romanStartYOffset - 3, '#00BFFF'));
                        units.push(new Unit('R8', 'Roman Archers 2', 'archer', 'Roman', romanStartX, romanStartYOffset + 5, '#00BFFF'));
                        units.push(new Unit('R9', 'Roman General', 'commander', 'Roman', romanStartX -2, romanStartYOffset + 4, '#800080'));

                        const barbarianStartX = window.battleSim.MAP_WIDTH_CELLS - Math.floor(window.battleSim.MAP_WIDTH_CELLS / 8) - 1;
                        const barbarianStartYOffset = Math.floor(window.battleSim.MAP_HEIGHT_CELLS / 4);
                        units.push(new Unit('B1', 'Warband A', 'infantry', 'Gaul', barbarianStartX, barbarianStartYOffset, '#16a34a'));
                        units.push(new Unit('B2', 'Warband B', 'infantry', 'Gaul', barbarianStartX, barbarianStartYOffset + 2, '#16a34a'));
                        units.push(new Unit('B3', 'Warband C', 'infantry', 'Gaul', barbarianStartX - 1, barbarianStartYOffset - 1, '#16a34a'));
                        units.push(new Unit('B4', 'Warband D', 'infantry', 'Gaul', barbarianStartX - 1, barbarianStartYOffset + 3, '#16a34a'));
                        units.push(new Unit('B5', 'Barbarian Chariots 1', 'chariot', 'Gaul', barbarianStartX + 2, barbarianStartYOffset + 1, '#047857'));
                        units.push(new Unit('B6', 'Barbarian Chariots 2', 'chariot', 'Gaul', barbarianStartX - 3, barbarianStartYOffset + 1, '#047857'));
                        units.push(new Unit('B7', 'Barbarian Skirmishers 1', 'skirmisher', 'Gaul', barbarianStartX + 1, barbarianStartYOffset - 3, '#FFD700'));
                        units.push(new Unit('B8', 'Barbarian Skirmishers 2', 'skirmisher', 'Gaul', barbarianStartX, barbarianStartYOffset + 5, '#FFD700'));
                        units.push(new Unit('B9', 'Barbarian Chieftain', 'commander', 'Gaul', barbarianStartX + 2, barbarianStartYOffset + 4, '#B22222'));
                    }

                    window.battleSim.logBattleMessage(`Battle initialized: ${currentScenario.description || 'Random Battle'}`);
                    window.requestAnimationFrame(window.battleSim.gameLoop);
                    window.battleSim.updateUnitCounts();
                };

                window.battleSim.drawGame = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(terrainTextureCanvas, 0, 0);

                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.2)';
                    for (let i = 0; i <= window.battleSim.MAP_WIDTH_CELLS; i++) { ctx.beginPath(); ctx.moveTo(i * window.battleSim.GRID_SIZE, 0); ctx.lineTo(i * window.battleSim.GRID_SIZE, canvas.height); ctx.stroke(); }
                    for (let i = 0; i <= window.battleSim.MAP_HEIGHT_CELLS; i++) { ctx.beginPath(); ctx.moveTo(0, i * window.battleSim.GRID_SIZE); ctx.lineTo(canvas.width, i * window.battleSim.GRID_SIZE); ctx.stroke(); }

                    units.forEach(unit => {
                        if (unit.type === 'commander' && unit.strength > 0 && !unit.broken) {
                            ctx.beginPath();
                            ctx.arc(unit.displayX * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2, unit.displayY * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2, window.battleSim.LEADERSHIP_RADIUS * window.battleSim.GRID_SIZE, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        if (unit.strength > 0 && !unit.broken) {
                            if (unit.pathHistory.length > 0) {
                                ctx.beginPath();
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                                ctx.lineWidth = 1;
                                ctx.moveTo(unit.pathHistory[0].x * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2, unit.pathHistory[0].y * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2);
                                for (let i = 1; i < unit.pathHistory.length; i++) { ctx.lineTo(unit.pathHistory[i].x * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2, unit.pathHistory[i].y * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2); }
                                ctx.lineTo(unit.displayX * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2, unit.displayY * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2);
                                ctx.stroke();
                            }
                            const currentSizeRatio = unit.strength / unit.maxStrength;
                            const unitDrawSize = window.battleSim.GRID_SIZE * currentSizeRatio;
                            const offset = (window.battleSim.GRID_SIZE - unitDrawSize) / 2;
                            const drawX = unit.displayX * window.battleSim.GRID_SIZE;
                            const drawY = unit.displayY * window.battleSim.GRID_SIZE;

                            ctx.fillStyle = unit.isFlashing ? 'white' : unit.color;
                            ctx.beginPath();
                            switch(unit.type) {
                                case 'infantry': ctx.roundRect(drawX + offset, drawY + offset, unitDrawSize, unitDrawSize, 5); break;
                                case 'cavalry': ctx.moveTo(drawX + offset + unitDrawSize / 2, drawY + offset); ctx.lineTo(drawX + offset + unitDrawSize, drawY + offset + unitDrawSize); ctx.lineTo(drawX + offset, drawY + offset + unitDrawSize); ctx.closePath(); break;
                                case 'archer': ctx.arc(drawX + offset + unitDrawSize / 2, drawY + offset + unitDrawSize / 2, unitDrawSize / 2, 0, Math.PI * 2); break;
                                case 'skirmisher': ctx.arc(drawX + offset + unitDrawSize / 2, drawY + offset + unitDrawSize / 2, unitDrawSize / 2 * 0.8, 0, Math.PI * 2); break;
                                case 'chariot': ctx.moveTo(drawX + offset + unitDrawSize / 2, drawY + offset); ctx.lineTo(drawX + offset + unitDrawSize, drawY + offset + unitDrawSize / 2); ctx.lineTo(drawX + offset + unitDrawSize / 2, drawY + offset + unitDrawSize); ctx.lineTo(drawX + offset, drawY + offset + unitDrawSize / 2); ctx.closePath(); break;
                                default: ctx.roundRect(drawX + offset, drawY + offset, unitDrawSize, unitDrawSize, 5);
                            }
                            ctx.fill();

                            if (unit === currentHoveredUnit) { ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 2; ctx.stroke(); }

                            const healthBarWidth = unitDrawSize * 0.8;
                            const healthBarHeight = 3;
                            const healthBarX = drawX + offset + (unitDrawSize - healthBarWidth) / 2;
                            const healthBarY = drawY + offset - healthBarHeight - 2;
                            ctx.fillStyle = 'black'; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                            const currentHealthWidth = healthBarWidth * (unit.strength / unit.maxStrength);
                            ctx.fillStyle = unit.strength > unit.maxStrength * 0.4 ? '#22c55e' : '#ef4444'; ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

                            const fatigueBarWidth = unitDrawSize * 0.8;
                            const fatigueBarHeight = 2;
                            const fatigueBarX = drawX + offset + (unitDrawSize - fatigueBarWidth) / 2;
                            const fatigueBarY = healthBarY - fatigueBarHeight - 2;
                            ctx.fillStyle = 'black'; ctx.fillRect(fatigueBarX, fatigueBarY, fatigueBarWidth, fatigueBarHeight);
                            const currentFatigueRatio = unit.fatigue / 10;
                            const currentFatigueWidth = fatigueBarWidth * Math.min(1, currentFatigueRatio);
                            ctx.fillStyle = '#A0522D'; ctx.fillRect(fatigueBarX, fatigueBarY, currentFatigueWidth, fatigueBarHeight);

                            ctx.fillStyle = 'white'; ctx.font = '10px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText(unit.strength.toFixed(0), drawX + offset + unitDrawSize / 2, drawY + offset + unitDrawSize / 2 - 5);
                            ctx.fillText(unit.morale.toFixed(0), drawX + offset + unitDrawSize / 2, drawY + offset + unitDrawSize / 2 + 5);

                            ctx.fillStyle = 'black'; ctx.font = 'bold 10px Inter'; ctx.textAlign = 'right'; ctx.textBaseline = 'top';
                            ctx.fillText(unit.getTypeIdentifier(), drawX + offset + unitDrawSize - 2, drawY + offset + 2);

                            ctx.fillStyle = '#333'; ctx.font = '8px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
                            ctx.fillText(unit.currentBehavior.substring(0,1).toUpperCase(), drawX + offset + unitDrawSize / 2, drawY + offset + unitDrawSize - 2);

                            const moraleState = unit.getMoraleState();
                            ctx.fillStyle = moraleState.color; ctx.beginPath(); ctx.arc(drawX + offset + unitDrawSize - 3, drawY + offset + 3, 3, 0, Math.PI * 2); ctx.fill();

                            if (unit.isFlankedStatus && unit.isFlashing) {
                                if (Math.floor(performance.now() / window.battleSim.FLANKED_FLASH_INTERVAL) % 2 === 0) {
                                    ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 12px Inter'; ctx.textAlign = 'center';
                                    ctx.fillText('FLANKED!', drawX + window.battleSim.GRID_SIZE / 2, drawY + window.battleSim.GRID_SIZE / 2 - (unitDrawSize / 2) - 15);
                                }
                            }
                        } else if (unit.broken) {
                            ctx.fillStyle = 'rgba(107, 114, 128, 0.5)'; ctx.beginPath(); ctx.roundRect(unit.x * window.battleSim.GRID_SIZE + 2, unit.y * window.battleSim.GRID_SIZE + 2, window.battleSim.GRID_SIZE - 4, window.battleSim.GRID_SIZE - 4, 5); ctx.fill();
                            ctx.fillStyle = 'white'; ctx.font = '12px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                            ctx.fillText('X', unit.x * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2, unit.y * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2);
                        }
                    });

                    const currentTime = performance.now();
                    projectiles = projectiles.filter(p => p.isAlive(currentTime));
                    projectiles.forEach(p => {
                        const progress = (currentTime - p.birthTime) / p.lifeTime;
                        const currentX = p.startX * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2 + (p.targetX * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2 - (p.startX * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2)) * progress;
                        const currentY = p.startY * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2 + (p.targetY * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2 - (p.startY * window.battleSim.GRID_SIZE + window.battleSim.GRID_SIZE / 2)) * progress;
                        ctx.beginPath(); ctx.arc(currentX, currentY, 2, 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.fill();
                    });

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.font = 'bold 10px Inter';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(window.battleSim.VERSION_NUMBER, canvas.width - 5, canvas.height - 5);
                };

                window.battleSim.resolveMeleeCombat = function(attacker, defender) {
                    if (attacker.strength <= 0 || attacker.broken || defender.strength <= 0 || defender.broken) return;
                    const randFactor = () => (1 + (Math.random() * (window.battleSim.COMBAT_RANDOMNESS_FACTOR * 2) - window.battleSim.COMBAT_RANDOMNESS_FACTOR));
                    
                    const effectiveAttackerAttack = attacker.getEffectiveAttack();
                    const effectiveDefenderDefense = defender.getEffectiveDefense();
                    const effectiveDefenderAttack = defender.getEffectiveAttack();
                    const effectiveAttackerDefense = attacker.getEffectiveDefense();
                    let rawDamageToDefender = (effectiveAttackerAttack * randFactor()) - (effectiveDefenderDefense * randFactor());
                    let rawDamageToAttacker = (effectiveDefenderAttack * randFactor()) - (effectiveAttackerDefense * randFactor());

                    if (attacker.type === 'cavalry' && defender.type === 'infantry') rawDamageToDefender *= window.battleSim.CAVALRY_VS_INFANTRY_BONUS;
                    else if (attacker.type === 'infantry' && defender.type === 'cavalry') rawDamageToAttacker *= window.battleSim.INFANTRY_VS_CAVALRY_BONUS;
                    if (attacker.type === 'chariot') rawDamageToDefender *= window.battleSim.CHARIOT_ATTACK_BONUS;
                    if (attacker.hasCharged) { rawDamageToDefender *= window.battleSim.CHARGE_DAMAGE_MODIFIER; window.battleSim.logBattleMessage(`${attacker.name} (${attacker.faction}) charged ${defender.name} (${defender.faction})!`); }
                    if (window.battleSim.isFlanked(defender)) {
                        rawDamageToDefender *= window.battleSim.FLANKED_DAMAGE_MODIFIER;
                        rawDamageToAttacker *= window.battleSim.FLANKED_COUNTERATTACK_PENALTY;
                        defender.isFlankedStatus = true;
                        window.battleSim.logBattleMessage(`${defender.name} (${defender.faction}) is flanked and takes extra damage!`);
                    }

                    rawDamageToDefender = Math.max(0, rawDamageToDefender);
                    rawDamageToAttacker = Math.max(0, rawDamageToAttacker);
                    let actualDamageToDefender = (rawDamageToDefender / 100) * attacker.strength * window.battleSim.MELEE_STRENGTH_DAMAGE_SCALAR;
                    let actualDamageToAttacker = (rawDamageToAttacker / 100) * defender.strength * window.battleSim.MELEE_STRENGTH_DAMAGE_SCALAR;
                    actualDamageToDefender *= window.battleSim.MELEE_FINAL_DAMAGE_MULTIPLIER;
                    actualDamageToAttacker *= window.battleSim.MELEE_FINAL_DAMAGE_MULTIPLIER;
                    if (rawDamageToDefender > 0 && actualDamageToDefender < window.battleSim.MINIMUM_DAMAGE) actualDamageToDefender = window.battleSim.MINIMUM_DAMAGE;
                    if (rawDamageToAttacker > 0 && actualDamageToAttacker < window.battleSim.MINIMUM_DAMAGE) actualDamageToAttacker = window.battleSim.MINIMUM_DAMAGE;

                    defender.takeDamage(actualDamageToDefender);
                    attacker.takeDamage(actualDamageToAttacker);
                    window.battleSim.logBattleMessage(`${attacker.name} (${attacker.faction}) dealt ${actualDamageToDefender.toFixed(1)} damage to ${defender.name} (${defender.faction}).`);
                    window.battleSim.logBattleMessage(`${defender.name} (${defender.faction}) dealt ${actualDamageToAttacker.toFixed(1)} damage to ${attacker.name} (${attacker.faction}).`);
                };

                window.battleSim.resolveRangedCombat = function() {
                    units.forEach(archerUnit => {
                        if (archerUnit.type !== 'archer' && archerUnit.type !== 'skirmisher' || archerUnit.strength <= 0 || archerUnit.broken) return;
                        let target = null;
                        let minDist = Infinity;
                        units.filter(enemy => enemy.faction !== archerUnit.faction && enemy.strength > 0 && !enemy.broken)
                             .forEach(enemy => {
                            const isEnemyEngagedWithFriendly = units.some(friendly => friendly.faction === archerUnit.faction && friendly.strength > 0 && !friendly.broken && Math.abs(friendly.x - enemy.x) + Math.abs(friendly.y - enemy.y) === 1);
                            if (!isEnemyEngagedWithFriendly) {
                                const dist = Math.sqrt(Math.pow(archerUnit.x - enemy.x, 2) + Math.pow(archerUnit.y - enemy.y, 2));
                                if (dist <= window.battleSim.ARCHER_RANGE && dist < minDist) { minDist = dist; target = enemy; }
                            }
                        });

                        if (target) {
                            const randFactor = () => (1 + (Math.random() * (window.battleSim.RANGED_COMBAT_RANDOMNESS_FACTOR * 2) - window.battleSim.RANGED_COMBAT_RANDOMNESS_FACTOR));
                            const effectiveArcherAttack = archerUnit.getEffectiveAttack();
                            const effectiveTargetDefense = target.getEffectiveDefense();
                            let rawRangedDamage = (effectiveArcherAttack * randFactor()) - (effectiveTargetDefense * randFactor() * window.battleSim.RANGED_DEFENSE_EFFECTIVENESS);
                            rawRangedDamage = Math.max(0, rawRangedDamage);
                            let actualRangedDamage = (rawRangedDamage / 100) * archerUnit.strength * window.battleSim.RANGED_STRENGTH_DAMAGE_SCALAR;
                            actualRangedDamage *= window.battleSim.RANGED_FINAL_DAMAGE_MULTIPLIER;
                            if (rawRangedDamage > 0 && actualRangedDamage < window.battleSim.MINIMUM_DAMAGE) actualRangedDamage = window.battleSim.MINIMUM_DAMAGE;

                            target.takeDamage(actualRangedDamage);
                            window.battleSim.logBattleMessage(`${archerUnit.name} (${archerUnit.faction}) shot at ${target.name} (${target.faction}), dealing ${actualRangedDamage.toFixed(1)} ranged damage.`);
                            projectiles.push(new Projectile(archerUnit.x, archerUnit.y, target.x, target.y, archerUnit.color));
                            archerUnit._attackedThisTurn = true; // NEW: Set attacked flag for ambush reset
                        }
                    });
                };

                window.battleSim.getPreferredTarget = function(unit, enemies) {
                    let target = null;
                    let bestScore = -Infinity;
                    
                    if (unit.currentBehavior === 'routing') {
                        const retreatX = unit.faction === 'Roman' ? window.battleSim.GAUL_RETREAT_X : window.battleSim.ROMAN_RETREAT_X; // Retreat to opposite side
                        let closestRetreatY = unit.y;
                        if (unit.y < 0) closestRetreatY = 0;
                        if (unit.y >= window.battleSim.MAP_HEIGHT_CELLS) closestRetreatY = window.battleSim.MAP_HEIGHT_CELLS -1;
                        return { x: retreatX, y: closestRetreatY, isRetreatTarget: true };
                    }

                    const activeEnemies = enemies.filter(enemy => enemy.strength > 0 && !enemy.broken);
                    if (activeEnemies.length === 0) return null;
                    const getDistance = (u1, u2) => Math.sqrt(Math.pow(u1.x - u2.x, 2) + Math.pow(u1.y - u2.y, 2));

                    activeEnemies.forEach(enemy => {
                        const distance = getDistance(unit, enemy);
                        let score = -distance;

                        switch (unit.targetPreference) {
                            case 'closest': break;
                            case 'weakest': score += (100 - (enemy.strength / enemy.maxStrength) * 100) * window.battleSim.AI_SCORE_WEAKEST_TARGET_WEIGHT; break;
                            case 'commander': if (enemy.type === 'commander') score += window.battleSim.AI_SCORE_TARGET_COMMANDER_BONUS; break;
                            case 'ranged_units': if (enemy.type === 'archer' || enemy.type === 'skirmisher') score += window.battleSim.AI_SCORE_TARGET_RANGED_BONUS; break;
                            case 'infantry': if (enemy.type === 'infantry') score += window.battleSim.AI_SCORE_TARGET_INFANTRY_BONUS; break;
                            default: break;
                        }
                        if ((unit.type === 'archer' || unit.type === 'skirmisher') && distance <= window.battleSim.ARCHER_RANGE) score += window.battleSim.AI_SCORE_RANGED_IN_RANGE_BONUS;
                        if (score > bestScore) { bestScore = score; target = enemy; }
                    });
                    return target;
                };

                window.battleSim.findPathBFS = function(startPos, unit, allUnits, map, targetPositions) {
                    const queue = [{x: startPos.x, y: startPos.y, path: [], cost: 0}];
                    const visited = new Set();
                    visited.add(`${startPos.x},${startPos.y}`);
                    const dx = [-1, 1, 0, 0, -1, -1, 1, 1];
                    const dy = [0, 0, -1, 1, -1, 1, -1, 1];
                    let closestPath = null;
                    let minDistanceToTarget = Infinity;

                    while (queue.length > 0) {
                        const {x, y, path, cost} = queue.shift();
                        for (const targetP of targetPositions) {
                            if (x === targetP.x && y === targetP.y) {
                                const euclideanDistance = Math.sqrt(Math.pow(startPos.x - x, 2) + Math.pow(startPos.y - y, 2));
                                if (euclideanDistance < minDistanceToTarget) {
                                    minDistanceToTarget = path.length;
                                    closestPath = path;
                                }
                            }
                        }

                        for (let i = 0; i < dx.length; i++) {
                            const nextX = x + dx[i];
                            const nextY = y + dy[i];
                            const nextCoord = `${nextX},${nextY}`;
                            if (visited.has(nextCoord)) continue;
                            if (nextX < 0 || nextX >= window.battleSim.MAP_WIDTH_CELLS || nextY < 0 || nextY >= window.battleSim.MAP_HEIGHT_CELLS) continue;

                            const terrainType = window.battleSim.getTerrainAt(nextX, nextY);
                            let moveCost = window.battleSim.TERRAIN_DATA[terrainType].movementCost;
                            if (!window.battleSim.FORMATION_DATA[unit.currentFormation]) continue;
                            moveCost *= window.battleSim.FORMATION_DATA[unit.currentFormation].movementModifier;
                            moveCost *= (1 + unit.getMoraleState().movementPenalty);
                            moveCost *= window.battleSim.AI_BEHAVIOR_DATA[unit.currentBehavior].movementModifier;

                            if (moveCost === Infinity || cost + moveCost > unit.movementPoints) continue;

                            let isOccupiedByOtherUnit = false;
                            for (const otherUnit of units) {
                                if (otherUnit.id !== unit.id && otherUnit.x === nextX && otherUnit.y === nextY && otherUnit.strength > 0 && !otherUnit.broken) {
                                    isOccupiedByOtherUnit = true;
                                    break;
                                }
                            }
                            if (isOccupiedByOtherUnit) continue;

                            visited.add(nextCoord);
                            queue.push({x: nextX, y: nextY, path: [...path, {x: nextX, y: nextY}], cost: cost + moveCost});
                        }
                    }
                    return closestPath;
                };

                window.battleSim.findOptimalMoveForUnit = function(unit, targetEnemy, allUnits, map) {
                    const startPos = {x: unit.x, y: unit.y};
                    let finalTargetX = unit.x;
                    let finalTargetY = unit.y;

                    const possibleMoves = [
                        { dx: 0, dy: 0 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 },
                        { dx: 0, dy: 1 }, { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: 1, dy: 1 }
                    ];

                    const maxMapDistance = Math.sqrt(window.battleSim.MAP_WIDTH_CELLS * window.battleSim.MAP_WIDTH_CELLS + window.battleSim.MAP_HEIGHT_CELLS * window.battleSim.MAP_HEIGHT_CELLS);
                    const currentDistanceToTarget = Math.sqrt(Math.pow(unit.x - targetEnemy.x, 2) + Math.pow(unit.y - targetEnemy.y, 2));
                    const isCurrentlyAdjacentToEnemy = currentDistanceToTarget <= 1.5;

                    const validTraversableMoves = possibleMoves.filter(move => {
                        const nextX = unit.x + move.dx;
                        const nextY = unit.y + move.dy;
                        if (nextX < 0 || nextX >= window.battleSim.MAP_WIDTH_CELLS || nextY < 0 || nextY >= window.battleSim.MAP_HEIGHT_CELLS) return false;
                        const terrainType = window.battleSim.getTerrainAt(nextX, nextY);
                        let moveCost = window.battleSim.TERRAIN_DATA[terrainType].movementCost;
                        if (!window.battleSim.FORMATION_DATA[unit.currentFormation]) { console.error(`Formation data missing for: ${unit.currentFormation}`); return false; }
                        moveCost *= window.battleSim.FORMATION_DATA[unit.currentFormation].movementModifier;
                        moveCost *= (1 + unit.getMoraleState().movementPenalty);
                        moveCost *= window.battleSim.AI_BEHAVIOR_DATA[unit.currentBehavior].movementModifier;
                        if (moveCost === Infinity || unit.remainingMovement < moveCost) return false;

                        let isOccupiedByOtherUnit = false;
                        for (const otherUnit of allUnits) {
                            if (otherUnit.id !== unit.id && otherUnit.x === nextX && otherUnit.y === nextY && otherUnit.strength > 0 && !otherUnit.broken) {
                                isOccupiedByOtherUnit = true;
                                break;
                            }
                        }
                        const isMoving = (move.dx !== 0 || move.dy !== 0);
                        if (isOccupiedByOtherUnit && isMoving) return false;
                        return true;
                    });

                    if (validTraversableMoves.length === 0) return { x: unit.x, y: unit.y };

                    let bestScore = -Infinity;
                    let bestCandidateX = unit.x;
                    let bestCandidateY = unit.y;

                    const stayPutMove = possibleMoves.find(m => m.dx === 0 && m.dy === 0);
                    const isStayPutMoveValid = validTraversableMoves.includes(stayPutMove);

                    if (targetEnemy.isRetreatTarget) {
                        let bestFleeScore = -Infinity;
                        let bestFleeMove = { x: unit.x, y: unit.y };

                        validTraversableMoves.forEach(move => {
                            const nextX = unit.x + move.dx;
                            const nextY = unit.y + move.dy;
                            let score = 0;
                            const enemyProximityPenalty = units.filter(e => e.faction !== unit.faction && e.strength > 0 && !e.broken)
                                                            .reduce((minDist, e) => Math.min(minDist, Math.sqrt(Math.pow(nextX - e.x, 2) + Math.pow(nextY - e.y, 2))), Infinity);
                            
                            score += enemyProximityPenalty * window.battleSim.AI_SCORE_ROUTING_ENEMY_PROXIMITY_WEIGHT;

                            if (unit.faction === 'Roman') score += (nextX - unit.x) * window.battleSim.AI_SCORE_ROUTING_RETREAT_DIRECTION_WEIGHT;
                            else score -= (nextX - unit.x) * window.battleSim.AI_SCORE_ROUTING_RETREAT_DIRECTION_WEIGHT;
                            
                            const terrainType = window.battleSim.getTerrainAt(nextX, nextY);
                            let moveCost = window.battleSim.TERRAIN_DATA[terrainType].movementCost;
                            moveCost *= window.battleSim.FORMATION_DATA[unit.currentFormation].movementModifier;
                            moveCost *= (1 + unit.getMoraleState().movementPenalty);
                            moveCost *= window.battleSim.AI_BEHAVIOR_DATA[unit.currentBehavior].movementModifier;
                            score -= moveCost * window.battleSim.AI_SCORE_ROUTING_MOVE_COST_PENALTY;

                            const mapCenterX = window.battleSim.MAP_WIDTH_CELLS / 2;
                            const distToCenter = Math.abs(nextX - mapCenterX);
                            score -= distToCenter * window.battleSim.AI_SCORE_ROUTING_MAP_CENTER_PENALTY;

                            if (score > bestFleeScore) {
                                bestFleeScore = score;
                                bestFleeMove = { x: nextX, y: nextY };
                            }
                        });
                        return bestFleeMove;
                    }

                    if (isStayPutMoveValid) {
                        let currentScoreForStay = 0;
                        const terrainTypeForStay = window.battleSim.getTerrainAt(unit.x, unit.y);
                        currentScoreForStay += (1 - (currentDistanceToTarget / maxMapDistance)) * window.battleSim.AI_SCORE_DISTANCE_WEIGHT;
                        currentScoreForStay += window.battleSim.TERRAIN_DATA[terrainTypeForStay].defenseBonus * window.battleSim.AI_SCORE_TERRAIN_DEFENSE_WEIGHT;
                        currentScoreForStay -= window.battleSim.TERRAIN_DATA[terrainTypeForStay].fatigueCost * window.battleSim.AI_SCORE_TERRAIN_FATIGUE_PENALTY * window.battleSim.FORMATION_DATA[unit.currentFormation].fatigueModifier;

                        const isRangedUnit = (unit.type === 'archer' || unit.type === 'skirmisher');
                        const isRangedUnitInFiringRange = isRangedUnit && currentDistanceToTarget <= window.battleSim.ARCHER_RANGE;
                        const isUnitInForest = window.battleSim.getTerrainAt(unit.x, unit.y) === 'forest';

                        if (isRangedUnit && !unit.isAmbushReady && isUnitInForest) {
                            currentScoreForStay += window.battleSim.AI_SCORE_AMBUSH_SETUP_BONUS;
                        }

                        if (isRangedUnit) {
                            if (isCurrentlyAdjacentToEnemy) currentScoreForStay -= window.battleSim.AI_SCORE_RANGED_ADJACENT_PENALTY;
                            else if (!isRangedUnitInFiringRange) currentScoreForStay -= window.battleSim.AI_SCORE_RANGED_OUT_OF_RANGE_PENALTY;
                            else currentScoreForStay += window.battleSim.AI_SCORE_RANGED_STAY_IN_RANGE_BONUS;
                        } else {
                            if (!isCurrentlyAdjacentToEnemy) currentScoreForStay -= window.battleSim.AI_SCORE_MELEE_NOT_ADJACENT_PENALTY;
                        }

                        if (currentScoreForStay > bestScore) {
                            bestScore = currentScoreForStay;
                            bestCandidateX = unit.x;
                            bestCandidateY = unit.y;
                        }
                    }

                    validTraversableMoves.forEach(move => {
                        const nextX = unit.x + move.dx;
                        const nextY = unit.y + move.dy;
                        let currentScore = 0;
                        const distToEnemyFromNext = Math.sqrt(Math.pow(nextX - targetEnemy.x, 2) + Math.pow(nextY - targetEnemy.y, 2));
                        currentScore += (1 - (distToEnemyFromNext / maxMapDistance)) * window.battleSim.AI_SCORE_DISTANCE_WEIGHT;

                        const terrainType = window.battleSim.getTerrainAt(nextX, nextY);
                        const terrainDefenseBonus = window.battleSim.TERRAIN_DATA[terrainType].defenseBonus;
                        const terrainFatigueCost = window.battleSim.TERRAIN_DATA[terrainType].fatigueCost;
                        const moveCost = window.battleSim.TERRAIN_DATA[terrainType].movementCost * window.battleSim.FORMATION_DATA[unit.currentFormation].movementModifier * (1 + unit.getMoraleState().movementPenalty) * window.battleSim.AI_BEHAVIOR_DATA[unit.currentBehavior].movementModifier;

                        if (unit.type !== 'archer' && unit.type !== 'skirmisher') { // Melee units
                            currentScore += terrainDefenseBonus * window.battleSim.AI_SCORE_TERRAIN_DEFENSE_WEIGHT;
                            currentScore -= terrainFatigueCost * window.battleSim.AI_SCORE_TERRAIN_FATIGUE_PENALTY * window.battleSim.FORMATION_DATA[unit.currentFormation].fatigueModifier;
                            
                            if (distToEnemyFromNext <= 1.5) currentScore += window.battleSim.AI_SCORE_ENGAGE_MELEE_BONUS;
                            
                            const potentialAdjacentEnemies = allUnits.filter(enemy => 
                                enemy.faction !== unit.faction && enemy.strength > 0 && !enemy.broken &&
                                (Math.abs(nextX - enemy.x) + Math.abs(nextY - enemy.y) === 1)
                            );
                            if (potentialAdjacentEnemies.length >= 2) currentScore += window.battleSim.AI_SCORE_FORM_BATTLE_LINE_BONUS;
                            
                            if (unit.currentBehavior === 'aggressive' && targetEnemy.currentBehavior === 'routing') currentScore += window.battleSim.AI_SCORE_CHASE_ROUTING_BONUS;
                            
                            if (unit.currentBehavior === 'aggressive' && unit.faction === 'Roman' && (move.dx > 0)) currentScore += window.battleSim.AI_SCORE_ADVANCE_BONUS;
                            if (unit.currentBehavior === 'aggressive' && unit.faction === 'Gaul' && (move.dx < 0)) currentScore += window.battleSim.AI_SCORE_ADVANCE_BONUS;

                        } else { // Ranged units
                            if (terrainType === 'hill') currentScore += window.battleSim.AI_SCORE_RANGED_ON_HILL_BONUS;
                            else if (terrainType === 'forest') currentScore += window.battleSim.AI_SCORE_RANGED_IN_FOREST_BONUS;
                            
                            currentScore -= terrainFatigueCost * 1 * window.battleSim.FORMATION_DATA[unit.currentFormation].fatigueModifier;

                            if (distToEnemyFromNext <= window.battleSim.ARCHER_RANGE && distToEnemyFromNext > 1.5) currentScore += window.battleSim.AI_SCORE_RANGED_STAY_IN_RANGE_BONUS * 10;
                            else if (distToEnemyFromNext <= 1.5) currentScore -= window.battleSim.AI_SCORE_RANGED_ADJACENT_PENALTY;
                            else if (distToEnemyFromNext > window.battleSim.ARCHER_RANGE) currentScore -= window.battleSim.AI_SCORE_RANGED_OUT_OF_RANGE_PENALTY;
                            
                            const adjacentToWater = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
                            let isAdjacentToWater = false;
                            for (const adj of adjacentToWater) {
                                const checkX = nextX + adj.dx; const checkY = nextY + adj.dy;
                                if (checkX >= 0 && checkX < window.battleSim.MAP_WIDTH_CELLS && checkY >= 0 && checkY < window.battleSim.MAP_HEIGHT_CELLS && window.battleSim.getTerrainAt(checkX, checkY) === 'water') {
                                    isAdjacentToWater = true; break;
                                }
                            }
                            if (isAdjacentToWater) currentScore -= window.battleSim.AI_SCORE_ADJACENT_TO_WATER_PENALTY;
                            
                            if (unit.currentBehavior === 'skirmishing' && (move.dx !== 0 || move.dy !== 0)) {
                                if (!(distToEnemyFromNext <= window.battleSim.ARCHER_RANGE && distToEnemyFromNext > 1.5)) currentScore += window.battleSim.AI_SCORE_SKIRMISH_MOVE_BONUS;
                            }
                            
                            if (unit.currentBehavior === 'aggressive' && unit.faction === 'Roman' && (move.dx > 0)) currentScore += window.battleSim.AI_SCORE_ADVANCE_BONUS * 0.6;
                            if (unit.currentBehavior === 'aggressive' && unit.faction === 'Gaul' && (move.dx < 0)) currentScore += window.battleSim.AI_SCORE_ADVANCE_BONUS * 0.6;
                        }

const friendlyCentroid = findFriendlyCentroid(unit, allUnits, 8); // Find center of friends within 8 tiles
if (friendlyCentroid) {
    const distToCentroidFromNext = Math.sqrt(Math.pow(nextX - friendlyCentroid.x, 2) + Math.pow(nextY - friendlyCentroid.y, 2));
    const currentDistToCentroid = Math.sqrt(Math.pow(unit.x - friendlyCentroid.x, 2) + Math.pow(unit.y - friendlyCentroid.y, 2));
    
    // If the move keeps the unit near the center of its allies, give it a bonus
    if (distToCentroidFromNext <= currentDistToCentroid) {
        currentScore += window.battleSim.AI_SCORE_COHESION_BONUS;
    }
}

                        currentScore -= moveCost * 1;

                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestCandidateX = nextX;
                            bestCandidateY = nextY;
                        }
                    });

                    if (bestScore === -Infinity && validTraversableMoves.length > 0 && isStayPutMoveValid) {
                        return { x: unit.x, y: unit.y };
                    }


                    let shortestPath = window.battleSim.findPathBFS(startPos, unit, allUnits, map, [{x: bestCandidateX, y: bestCandidateY}]);

                    if (shortestPath && shortestPath.length > 0) {
                        return shortestPath[0];
                    } else {
                        // Fallback: If BFS found no path to the best candidate, try any valid adjacent tile
                        const adjacentTiles = [
                            { dx: 0, dy: 0 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                            { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: 1, dy: 1 }
                        ];
                        adjacentTiles.sort(() => Math.random() - 0.5); // Randomize attempts

                        for (const move of adjacentTiles) {
                            const testX = unit.x + move.dx;
                            const testY = unit.y + move.dy;
                            if (testX >= 0 && testX < window.battleSim.MAP_WIDTH_CELLS && testY >= 0 && testY < window.battleSim.MAP_HEIGHT_CELLS &&
                                window.battleSim.getTerrainAt(testX, testY) !== 'water') {
                                let isOccupiedTest = false;
                                for (const otherUnit of allUnits) {
                                    if (otherUnit.id !== unit.id && otherUnit.x === testX && otherUnit.y === testY && otherUnit.strength > 0 && !otherUnit.broken) {
                                        isOccupiedTest = true;
                                        break;
                                    }
                                }
                                if (!isOccupiedTest) {
                                    return { x: testX, y: testY }; // Return the first valid adjacent move found
                                }
                            }
                        }
                        return { x: unit.x, y: unit.y }; // If all else fails, stay put
                    }
                };


                window.battleSim.processNextTurn = function() {
                    turn++;
                    window.battleSim.logBattleMessage(`--- Turn ${turn} ---`);

                    units.forEach(unit => {
                        unit.updateUnitBehavior(); // Call the new behavior update
                        unit.resetTurnStatus(); // This will handle ambush setup incrementing if conditions are met
                    });

                    const activeCommanders = units.filter(unit => unit.type === 'commander' && unit.strength > 0 && !unit.broken);
                    const lostCommandersThisTurn = units.filter(unit => unit.type === 'commander' && unit.strength <= 0 && !unit.broken);

                    units.forEach(unit => {
                        if (unit.type === 'commander' || unit.broken || unit.strength <= 0) return;

                        let inAura = false;
                        for (const commander of activeCommanders) {
                            const dist = Math.sqrt(Math.pow(unit.x - commander.x, 2) + Math.pow(unit.y - commander.y, 2));
                            if (dist <= window.battleSim.LEADERSHIP_RADIUS) {
                                unit.appliedCommanderBuff = true;
                                unit.morale = Math.min(unit.initialMorale, unit.morale + window.battleSim.LEADERSHIP_MORALE_BOOST);
                                unit.fatigue = Math.max(0, unit.fatigue - window.battleSim.LEADERSHIP_FATIGUE_REDUCTION);
                                inAura = true;
                                break;
                            }
                        }
                        unit.hasCommanderAura = inAura;
                    });

                    if (lostCommandersThisTurn.length > 0) {
                        lostCommandersThisTurn.forEach(lostCommander => {
                            window.battleSim.logBattleMessage(`COMMANDER LOST! ${lostCommander.name} (${lostCommander.faction}) has fallen!`);
                            units.forEach(unit => {
                                if (unit.faction === lostCommander.faction && unit.id !== lostCommander.id && unit.strength > 0 && !unit.broken) {
                                    const dist = Math.sqrt(Math.pow(unit.x - lostCommander.x, 2) + Math.pow(unit.y - lostCommander.y, 2));
                                    if (dist <= window.battleSim.LEADERSHIP_RADIUS * 2) {
                                        unit.morale = Math.max(window.battleSim.MORALE_BREAK_THRESHOLD, unit.morale - window.battleSim.COMMANDER_LOSS_MORALE_SHOCK);
                                        window.battleSim.logBattleMessage(`${unit.name} (${unit.faction}) suffers morale shock from leader loss! Morale: ${unit.morale.toFixed(0)}`);
                                        if (unit.morale <= window.battleSim.MORALE_BREAK_THRESHOLD) {
                                            unit.broken = true;
                                            unit.morale = 0;
                                            window.battleSim.logBattleMessage(`${unit.name} (${unit.faction}) has broken due to leader loss!`);
                                        }
                                    }
                                }
                            });
                        });
                    }

                    window.battleSim.resolveRangedCombat();

                    units.forEach(unit => {
                        if (unit.strength <= 0 || unit.broken) return;

                        const enemies = units.filter(enemy => enemy.faction !== unit.faction && enemy.strength > 0 && !unit.broken);
                        if (enemies.length === 0) return;

                        const targetEnemy = window.battleSim.getPreferredTarget(unit, enemies);
                        if (!targetEnemy) return;

                        let optimalMove = window.battleSim.findOptimalMoveForUnit(unit, targetEnemy, units, map);







                        
                        const originalX = unit.x;
                        const originalY = unit.y;

                        let moved = unit.moveTo(optimalMove.x, optimalMove.y);

                        if (!moved) {
                            unit.idleTurns++;
                            if (unit.idleTurns >= window.battleSim.IDLE_TURNS_FOR_FORCED_MOVE) {
                                window.battleSim.logBattleMessage(`${unit.name} (${unit.faction}) has been idle/stuck; forcing a move attempt.`);
                                
                                const adjacentTiles = [
                                    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                                    { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: 1, dy: 1 }
                                ];
                                adjacentTiles.sort(() => Math.random() - 0.5);

                                let forcedMoveSuccessful = false;
                                for (const move of adjacentTiles) {
                                    const testX = originalX + move.dx; 
                                    const testY = originalY + move.dy;

                                    if (testX >= 0 && testX < window.battleSim.MAP_WIDTH_CELLS && testY >= 0 && testY < window.battleSim.MAP_HEIGHT_CELLS) {
                                        const terrainType = window.battleSim.getTerrainAt(testX, testY);
                                        let isOccupiedByOtherUnit = false; 
                                        for (const otherUnit of units) {
                                            if (otherUnit.id !== unit.id && otherUnit.x === testX && otherUnit.y === testY && otherUnit.strength > 0 && !otherUnit.broken) {
                                                isOccupiedByOtherUnit = true;
                                                break;
                                            }
                                        }
                                        if (window.battleSim.TERRAIN_DATA[terrainType].movementCost !== Infinity && !isOccupiedByOtherUnit) {
                                            if (unit.moveTo(testX, testY)) {
                                                window.battleSim.logBattleMessage(`${unit.name} (${unit.faction}) successfully made a forced move to (${testX}, ${testY}).`);
                                                forcedMoveSuccessful = true;
                                                break;
                                            }
                                        }
                                    }
                                } 
                                if (forcedMoveSuccessful) {
                                    unit._wasActiveThisTurn = true;
                                    unit.idleTurns = 0;
                                }
                            }
                        }

                        if (moved || (unit.x !== originalX || unit.y !== originalY)) {
                            unit._wasActiveThisTurn = true;
                            const isAdjacentAfterMove = units.some(enemy => enemy.faction !== unit.faction && enemy.strength > 0 && !enemy.broken &&
                                (Math.abs(unit.x - enemy.x) + Math.abs(unit.y - enemy.y) === 1));
                            if (isAdjacentAfterMove) {
                                unit.hasCharged = true;
                            }
                        }
                    });

                    const engagedPairs = new Set();
                    units.forEach(unitA => {
                        if (unitA.strength <= 0 || unitA.broken) return;
                        units.forEach(unitB => {
                            if (unitA.id === unitB.id || unitA.faction === unitB.faction || unitB.strength <= 0 || unitB.broken) return;
                            if (Math.abs(unitA.x - unitB.x) + Math.abs(unitA.y - unitB.y) === 1) {
                                const pairKey1 = `${unitA.id}-${unitB.id}`;
                                const pairKey2 = `${unitB.id}-${unitA.id}`;
                                if (!engagedPairs.has(pairKey1) && !engagedPairs.has(pairKey2)) {
                                    window.battleSim.resolveMeleeCombat(unitA, unitB);
                                    engagedPairs.add(pairKey1);
                                    unitA._wasActiveThisTurn = true;
                                    unitB._wasActiveThisTurn = true;
                                }
                            }
                        });
                    });

                    units.forEach(unit => {
                        if (unit.strength <= 0 && !unit.broken) {
                            unit.broken = true;
                            window.battleSim.logBattleMessage(`${unit.name} (${unit.faction}) has been destroyed!`);
                            units.forEach(friendlyUnit => {
                                if (friendlyUnit.faction === unit.faction && friendlyUnit.id !== unit.id && friendlyUnit.strength > 0 && !friendlyUnit.broken) {
                                    const dist = Math.sqrt(Math.pow(friendlyUnit.x - unit.x, 2) + Math.pow(friendlyUnit.y - unit.y, 2));
                                    if (dist <= window.battleSim.MORALE_GAIN_RADIUS) {
                                        friendlyUnit.morale = Math.min(friendlyUnit.initialMorale, friendlyUnit.morale + window.battleSim.MORALE_GAIN_ON_ENEMY_BREAK);
                                        window.battleSim.logBattleMessage(`${friendlyUnit.name} (${friendlyUnit.faction}) gains morale from ${unit.name} breaking!`);
                                    }
                                }
                            });
                        }
                        if (unit.strength > 0 && !unit.broken) {
                            if (unit._wasActiveThisTurn || unit.isFlashing) {
                                unit.idleTurns = 0;
                                let fatigueGain = window.battleSim.BASE_FATIGUE_GAIN;
                                const currentTerrain = window.battleSim.getTerrainAt(unit.x, unit.y);
                                fatigueGain += window.battleSim.TERRAIN_DATA[currentTerrain].fatigueCost * window.battleSim.FATIGUE_GAIN_TERRAIN_SCALAR;
                                if (unit.appliedCommanderBuff) fatigueGain *= window.battleSim.LEADERSHIP_FATIGUE_REDUCTION;
                                unit.fatigue += fatigueGain;
                            } else {
                                unit.idleTurns++;
                            }
                        }
                        if (unit.strength <=0 || unit.broken) unit.idleTurns = 0;
                    });

                    window.battleSim.updateUnitCounts();
                    window.battleSim.checkVictoryConditions();

                    isAnimating = false;
                    nextTurnButton.disabled = false;
                    if (isAutoBattleActive) {
                        autoBattleButton.disabled = false;
                    }

                    if (isAutoBattleActive) {
                        if (!window.battleSim.isBattleOver()) {
                            autoBattleIntervalId = setTimeout(window.battleSim.startNextTurnSequence, window.battleSim.AUTO_BATTLE_TURN_DELAY);
                        } else {
                            window.battleSim.stopAutoBattle();
                        }
                    }
                };

                window.battleSim.isBattleOver = function() {
                    const romanActiveUnits = units.filter(unit => unit.faction === 'Roman' && unit.strength > 0 && !unit.broken).length;
                    const gaulActiveUnits = units.filter(unit => unit.faction === 'Gaul' && unit.strength > 0 && !unit.broken).length;
                    return romanActiveUnits === 0 || gaulActiveUnits === 0;
                };

                window.battleSim.gameLoop = function(currentTime) {
                    if (!isAnimating) {
                        window.battleSim.drawGame();
                        return;
                    }

                    if (window.lastTime === undefined || window.lastTime === 0) {
                        window.lastTime = currentTime;
                    }

                    const elapsedTime = currentTime - window.lastTime;
                    const progress = Math.min(1, elapsedTime / window.battleSim.ANIMATION_DURATION);

                    let animationComplete = true;
                    units.forEach(unit => {
                        unit.displayX = unit.prevX * (1 - progress) + unit.x * progress;
                        unit.displayY = unit.prevY * (1 - progress) + unit.y * progress;
                        if (Math.abs(unit.displayX - unit.x) > 0.01 || Math.abs(unit.displayY - unit.y) > 0.01) {
                            animationComplete = false;
                        }
                    });
                    
                    window.battleSim.drawGame();

                    if (animationComplete && elapsedTime >= window.battleSim.ANIMATION_DURATION) {
                        window.lastTime = 0;
                        animationStartTime = 0;
                        units.forEach(unit => {
                            unit.displayX = unit.x;
                            unit.displayY = unit.y;
                        });
                        window.battleSim.drawGame();
                        window.battleSim.processNextTurn();
                    } else {
                        window.requestAnimationFrame(window.battleSim.gameLoop);
                    }
                };

                window.battleSim.startNextTurnSequence = function() {
                    if (isAnimating) return;
                    nextTurnButton.textContent = 'Next Turn';
                    restartButton.style.display = 'block';
                    nextTurnButton.disabled = true;
                    autoBattleButton.disabled = true;
                    isAnimating = true;
                    animationStartTime = performance.now();
                    window.requestAnimationFrame(window.battleSim.gameLoop);
                };

                window.battleSim.toggleAutoBattle = function() {
                    isAutoBattleActive = !isAutoBattleActive;
                    if (isAutoBattleActive) {
                        autoBattleButton.textContent = 'Stop Auto Battle';
                        nextTurnButton.disabled = true;
                        if (!isAnimating && !window.battleSim.isBattleOver()) {
                            autoBattleIntervalId = setTimeout(window.battleSim.startNextTurnSequence, window.battleSim.AUTO_BATTLE_TURN_DELAY);
                        }
                    } else {
                        window.battleSim.stopAutoBattle();
                    }
                };

                window.battleSim.stopAutoBattle = function() {
                    isAutoBattleActive = false;
                    autoBattleButton.textContent = 'Auto Battle';
                    nextTurnButton.disabled = false;
                    clearTimeout(autoBattleIntervalId);
                    autoBattleIntervalId = null;
                };

                window.battleSim.updateUnitCounts = function() {
                    const romanActiveUnits = units.filter(unit => unit.faction === 'Roman' && unit.strength > 0 && !unit.broken).length;
                    const gaulActiveUnits = units.filter(unit => unit.faction === 'Gaul' && unit.strength > 0 && !unit.broken).length;
                    romanUnitsDisplay.textContent = `Units: ${romanActiveUnits}`;
                    gaulUnitsDisplay.textContent = `Units: ${gaulActiveUnits}`;
                };

                window.battleSim.checkVictoryConditions = function() {
                    const romanActiveUnits = units.filter(unit => unit.faction === 'Roman' && unit.strength > 0 && !unit.broken);
                    const gaulActiveUnits = units.filter(unit => unit.faction === 'Gaul' && unit.strength > 0 && !unit.broken);

                    if (romanActiveUnits.length === 0 && gaulActiveUnits.length === 0) {
                        window.battleSim.logBattleMessage("All units destroyed or routed! It's a draw!");
                        nextTurnButton.disabled = true;
                        window.battleSim.stopAutoBattle();
                        return;
                    } else if (romanActiveUnits.length === 0) {
                        window.battleSim.logBattleMessage("Barbarian Horde is victorious! The Roman Army has been defeated!");
                        nextTurnButton.disabled = true;
                        window.battleSim.stopAutoBattle();
                        return;
                    } else if (gaulActiveUnits.length === 0) {
                        window.battleSim.logBattleMessage("Roman Army is victorious! The Barbarian Horde has been defeated!");
                        nextTurnButton.disabled = true;
                        window.battleSim.stopAutoBattle();
                        return;
                    }

                    const allRomansRetreated = romanActiveUnits.every(unit => unit.x >= window.battleSim.ROMAN_RETREAT_X);
                    const allGaulsRetreated = gaulActiveUnits.every(unit => unit.x <= window.battleSim.GAUL_RETREAT_X);

                    if (allRomansRetreated && romanActiveUnits.length > 0) {
                        window.battleSim.logBattleMessage("Barbarian Horde wins by forcing Roman retreat!");
                        nextTurnButton.disabled = true;
                        window.battleSim.stopAutoBattle();
                        return;
                    } else if (allGaulsRetreated && gaulActiveUnits.length > 0) {
                        window.battleSim.logBattleMessage("Roman Army wins by forcing Barbarian retreat!");
                        nextTurnButton.disabled = true;
                        window.battleSim.stopAutoBattle();
                        return;
                    }
                };

                // Initialize DOM elements and attach events after DOM is loaded
                document.addEventListener('DOMContentLoaded', function() {
                    canvas = document.getElementById('battleCanvas');
                    ctx = canvas.getContext('2d');
                    nextTurnButton = document.getElementById('nextTurnButton');
                    autoBattleButton = document.getElementById('autoBattleButton');
                    restartButton = document.getElementById('restartButton');
                    logArea = document.getElementById('logArea');
                    romanUnitsDisplay = document.getElementById('roman-units-display');
                    gaulUnitsDisplay = document.getElementById('gaul-units-display');
                    unitTooltip = document.getElementById('unitTooltip');
                    unitPopupMenu = document.getElementById('unitPopupMenu'); // Initialize popup menu element
                    scenarioSelect = document.getElementById('scenarioSelect');

                    canvas.width = window.battleSim.MAP_WIDTH_CELLS * window.battleSim.GRID_SIZE;
                    canvas.height = window.battleSim.MAP_HEIGHT_CELLS * window.battleSim.GRID_SIZE;
                    terrainTextureCanvas.width = window.battleSim.MAP_WIDTH_CELLS * window.battleSim.GRID_SIZE;
                    terrainTextureCanvas.height = window.battleSim.MAP_HEIGHT_CELLS * window.battleSim.GRID_SIZE;
                    terrainTextureCtx = terrainTextureCanvas.getContext('2d'); // Correct initialization

                    // Mousemove for tooltip
                    canvas.addEventListener('mousemove', (event) => {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        window.lastMouseX = (event.clientX - rect.left) * scaleX;
                        window.lastMouseY = (event.clientY - rect.top) * scaleY;

                        let foundUnit = null;
                        for (const unit of units) {
                            const unitPixelX = unit.displayX * window.battleSim.GRID_SIZE;
                            const unitPixelY = unit.displayY * window.battleSim.GRID_SIZE;
                            if (window.lastMouseX >= unitPixelX && window.lastMouseX < unitPixelX + window.battleSim.GRID_SIZE &&
                                window.lastMouseY >= unitPixelY && window.lastMouseY < unitPixelY + window.battleSim.GRID_SIZE &&
                                unit.strength > 0 && !unit.broken) {
                                foundUnit = unit;
                                break;
                            }
                        }
                        if (foundUnit !== currentHoveredUnit) {
                            currentHoveredUnit = foundUnit;
                            window.battleSim.drawGame(); // Redraw to update highlight
                        }
                        if (currentHoveredUnit) {
                            unitTooltip.style.display = 'block';
                            // Position tooltip relative to mouse, with offset
                            const tooltipOffsetX = 15;
                            const tooltipOffsetY = 15;
                            let tooltipX = event.clientX + tooltipOffsetX;
                            let tooltipY = event.clientY + tooltipOffsetY;

                            // Keep tooltip within viewport
                            if (tooltipX + unitTooltip.offsetWidth > window.innerWidth) {
                                tooltipX = window.innerWidth - unitTooltip.offsetWidth - 5;
                            }
                            if (tooltipY + unitTooltip.offsetHeight > window.innerHeight) {
                                tooltipY = window.innerHeight - unitTooltip.offsetHeight - 5;
                            }

                            unitTooltip.style.left = `${tooltipX}px`;
                            unitTooltip.style.top = `${tooltipY}px`;
                            unitTooltip.innerHTML = `
                                <strong>${currentHoveredUnit.name}</strong><br>
                                Faction: ${currentHoveredUnit.faction}<br>
                                Type: ${currentHoveredUnit.type}<br>
                                Strength: ${currentHoveredUnit.strength.toFixed(0)}/${currentHoveredUnit.maxStrength}<br>
                                Morale: ${currentHoveredUnit.morale.toFixed(0)}% (${currentHoveredUnit.getMoraleState().name})<br>
                                Fatigue: ${currentHoveredUnit.fatigue.toFixed(0)}<br>
                                Idle Turns: ${currentHoveredUnit.idleTurns}<br>
                                Formation: ${currentHoveredUnit.currentFormation.replace(/_/g, ' ')}<br>
                                Behavior: ${currentHoveredUnit.currentBehavior}<br>
                                Ambush Ready: ${currentHoveredUnit.isAmbushReady ? 'Yes' : 'No'}<br>
                                Rest Turns: ${currentHoveredUnit.ambushRestTurns}
                            `;
                        } else {
                            unitTooltip.style.display = 'none';
                        }
                    });

                    // Mouseout to hide tooltip
                    canvas.addEventListener('mouseout', () => {
                        unitTooltip.style.display = 'none';
                        currentHoveredUnit = null;
                        window.battleSim.drawGame(); // Redraw to remove highlight
                    });

                    // Click for popup menu
                    canvas.addEventListener('click', (event) => {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        const clickX = (event.clientX - rect.left) * scaleX;
                        const clickY = (event.clientY - rect.top) * scaleY;

                        let clickedUnit = null;
                        for (const unit of units) {
                            const unitPixelX = unit.x * window.battleSim.GRID_SIZE; // Use actual unit position for click
                            const unitPixelY = unit.y * window.battleSim.GRID_SIZE; // Use actual unit position for click
                            if (clickX >= unitPixelX && clickX < unitPixelX + window.battleSim.GRID_SIZE &&
                                clickY >= unitPixelY && clickY < unitPixelY + window.battleSim.GRID_SIZE &&
                                unit.strength > 0 && !unit.broken) {
                                clickedUnit = unit;
                                break;
                            }
                        }

                        if (clickedUnit) {
                            currentClickedUnit = clickedUnit; // Set clicked unit for popup management
                            unitPopupMenu.style.display = 'block';

                            // Position popup menu
                            let popupX = event.clientX + 10;
                            let popupY = event.clientY + 10;

                            // Adjust position to keep within viewport
                            if (popupX + unitPopupMenu.offsetWidth > window.innerWidth) {
                                popupX = window.innerWidth - unitPopupMenu.offsetWidth - 5;
                            }
                            if (popupY + unitPopupMenu.offsetHeight > window.innerHeight) {
                                popupY = window.innerHeight - unitPopupMenu.offsetHeight - 5;
                            }

                            unitPopupMenu.style.left = `${popupX}px`;
                            unitPopupMenu.style.top = `${popupY}px`;
                            unitPopupMenu.innerHTML = `
                                <h3>${currentClickedUnit.name} (${currentClickedUnit.faction})</h3>
                                <p>Type: ${currentClickedUnit.type}</p>
                                <p>Strength: ${currentClickedUnit.strength.toFixed(0)}/${currentClickedUnit.maxStrength}</p>
                                <p>Morale: ${currentClickedUnit.morale.toFixed(0)}% (${currentClickedUnit.getMoraleState().name})</p>
                                <p>Fatigue: ${currentClickedUnit.fatigue.toFixed(0)}</p>
                                <p>Idle Turns: ${currentClickedUnit.idleTurns}</p>
                                <p>Formation: ${currentClickedUnit.currentFormation.replace(/_/g, ' ')}</p>
                                <p>Behavior: ${currentClickedUnit.currentBehavior}</p>
                                <p>Ambush Ready: ${currentClickedUnit.isAmbushReady ? 'Yes' : 'No'}</p>
                                <p>Rest Turns: ${currentClickedUnit.ambushRestTurns}</p>
                                <button id="closePopupMenu">Close</button>
                            `;
                            document.getElementById('closePopupMenu').addEventListener('click', () => {
                                unitPopupMenu.style.display = 'none';
                                currentClickedUnit = null;
                            });
                        } else {
                            // If click is not on a unit, hide popup
                            unitPopupMenu.style.display = 'none';
                            currentClickedUnit = null;
                        }
                    });

                    // Click anywhere on document to close popup if open and not clicking the popup itself
                    document.body.addEventListener('click', (event) => {
                        if (unitPopupMenu.style.display === 'block' && !unitPopupMenu.contains(event.target) && event.target !== canvas) {
                            unitPopupMenu.style.display = 'none';
                            currentClickedUnit = null;
                        }
                    });


                    nextTurnButton.addEventListener('click', window.battleSim.startNextTurnSequence);
                    autoBattleButton.addEventListener('click', window.battleSim.toggleAutoBattle);
                    restartButton.addEventListener('click', () => window.battleSim.initGame(scenarioSelect.value));
                    scenarioSelect.addEventListener('change', (event) => { window.battleSim.initGame(event.target.value); });

                    window.battleSim.initGame(scenarioSelect.value);
                }); // End of DOMContentLoaded listener

            })(); // End of IIFE
        } // End of if (!window.ancientBattleSimInitialized)
    </script>
</body>
</html>
